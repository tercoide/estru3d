' Gambas module file

'
' estru3D
' Software para cálculo de estructuras mediante el método de la rigidez. Calcula estructuras tridimensionales, representa esfuerzos y solicitaciones en apoyos. Gráficas elásticas.
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 2 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
'

Public Struct extentstype
    MinX As Float
    MinY As Float
    MinZ As Float
    maxX As Float
    MaxY As Float
    MaxZ As Float

End Struct
' un type importante

Public Struct punto3d
    x As Float
    Y As Float
    z As Float
End Struct

Public Struct punto2d
    x As Float
    Y As Float
End Struct

Public Struct GLColorSt

    r As Float
    g As Float
    b As Float
    Alpha As Float

End Struct

Public Const N As Integer = 1
Public Const Qy As Integer = 2
Public Const Qz As Integer = 3
Public Const T As Integer = 4
Public Const My As Integer = 5
Public Const Mz As Integer = 6

Public matriz3d As New Float[3, 3]
Public MatrizRotacion As New Float[3, 3]
Public MatrizRVieja As New Float[3, 3]
Public MatrizRNueva As New Float[3, 3]
Public MatrizAux As New Float[3, 3]

Public MatrizLocal As New Float[3, 3]

Public CoordNroBarras As New Integer[]
Public CoordNroNudos As New Integer[]
Public CoordNroElem As New Integer[]

Public DibujadoNroNudos As New Boolean[]

Public ColorScale As New Float[3, 1001]

' para el zoom previous

Public MatrizR As New Float[3, 3]

Public mundo_max As New Punto3d ' limites de la estructura
Public mundo_min As New Punto3d
Public mundoCG As New Punto3d

Public maxmax As Float
Public zoom As Single

Public OrigenMin As Float ' esto se saber al definir las barras
Public OrigenMax As Float
Public ZoomMin As Float
Public ZoomMax As Float
Public maxX As Float
Public MaxY As Float

Public cgX As Float
Public cgY As Float
Public cgZ As Float

Public panned As Integer

' Parametros de representacion del grafico
Public Pov As New Punto3d
Public Pan As New Punto3d
Public Escala As Float
Public EscalaGL As Float ' esta es la relacion entre los pixeles de la pantalla y el viewport de GL

Public Rotacion As New Punto3d

Public FirstTime As Boolean
' estos son los angulos que forman los ejes con el plano de dibujo
' En la vista anterior (según la llamo yo)
' aX = 0 , aY = 0, aZ = 90º

' Vista lateral
' aX = 90º , aY = 0º, aZ = 0º

' Vista superior
' aX = 0º , aY = 90º, aZ = 0º

' Isométricas:

Public alfax As Single
Public alfay As Single
Public alfaz As Single
' delta es el angulo que forman con el eje x horizontal del dibujo
Public deltax As Single
Public deltay As Single
Public deltaz As Single
' eps es el angulo que forman con el eje y del dibujo
Public epsx As Single
Public epsy As Single
Public epsz As Single

Public Ptype As String
Public pr As New Punto3d

Public extents As New Extentstype

Public WheelInstance As Integer
Public DrawingInstance As Boolean
Public QuitDrawing As Boolean

Public glListaEstructura As Integer  '1
Public glListaCargas As New Integer[]
Public glListaApoyos As Integer

Public glListaEsfuerzos As New Integer[7]
Public glListaEsfuerzosLosas As New Integer[7]

Public glListaMz As Integer
Public glListaN As Integer
Public glListaQy As Integer
Public glListaQz As Integer
Public glListaT As Integer

Public glListaMy As Integer

Public glListaMzLosas As Integer
Public glListaNLosas As Integer
Public glListaQyLosas As Integer
Public glListaQzLosas As Integer
Public glListaTLosas As Integer
Public glListaMyLosas As Integer

Public glListaE As Integer
Public glListaNudos As Integer
Public glListaBarras As Integer
Public glListaLosas As Integer
Public glListaColumnas As Integer
Public glListaVigas As Integer  '15
Public glListaRender As Integer
Public glListaWireframe As Integer
Public glListaSubBarras As Integer
Public glListaLosasXXX As Integer
Public glListaColumnasXXX As Integer '20

Public glListaNumeroNudos As Integer
Public glListaNumeroBarras As Integer

Public glListaNumeroSubNudos As Integer
Public glListaNumeroSubBarras As Integer

Public GLP1 As New Punto3d
Public GLP2 As New Punto3d
Public GLP3 As New Punto3d

Public GLColor1 As New GLColorSt
Public GLColor2 As New GLColorSt
Public GLColor3 As New GLColorSt

Public GLColor4fCurrent As New GLColorSt

Public GLPushNumber As Integer

Public hText As New Integer[1]

Public imgNroNudos As New Object[]
Public imgNroElem As New Object[]
Public imgNroBarras As New Object[]

' VR
Public doVR As Boolean
Public fileVR As File
Public fileLines As File
Public fileColors As File
Public FileTriangles As File
Public FileTriangleColors As File
'Public FileTriangleNormals As File
Public FileUVs As File

Public Sub VR_Start()

    If Exist(modestru.datos.proyecto & ".VR.html") Then Kill modestru.datos.proyecto & ".VR.html"
    Copy Application.Path &/ "VirtualReality/HTML-Encabezado7.txt" To modestru.datos.proyecto & ".VR.html"
    fileVR = Open modestru.datos.proyecto & ".VR.html" For Write Append
    doVR = True

    ' Lineas
    fileLines = Open modestru.datos.proyecto & ".lines" For Write Create
    Print #fileLines, "vertices = [ 0,0,0,0,0,0"

    fileColors = Open modestru.datos.proyecto & ".colors" For Write Create

    Print #fileColors, "colores = [ 0,0,0,0,0,0"

    ' Triangulos
    FileTriangles = Open modestru.datos.proyecto & ".triangles" For Write Create

    Print #FileTriangles, "Tvertices = [ 0,0,0,0,0,0,0,0,0"

    FileTriangleColors = Open modestru.datos.proyecto & ".Tcolors" For Write Create
    Print #FileTriangleColors, "Tcolores = [ 0,0,0,0,0,0,0,0,0"

    'FileTriangleNormals = Open modestru.datos.proyecto & ".Tnormals" For Write Create
    'Print #FileTriangleNormals, "Tnormals = [ 0,0,0,0,0,0,0,0,0"

    FileUVs = Open modestru.datos.proyecto & ".TUVs" For Write Create
    Print #FileUVs, "TUVs = [ 0,0 ,0,0, 0,0 "

End

Public Sub VR_Finish()

    '  le agrego el final y cierro

    Dim fEnd As File, stLinea As String

    ' cierro losa colores y lineas

    Print #fileLines, " ];"

    fileLines.Close

    Print #FileUVs, " ];"
    FileUVs.Close

    Print #fileColors, " ]; "
    fileColors.Close

    ' Triangulos
    Print #FileTriangles, " ];"
    FileTriangles.Close

    ' Ahora las calculo en JS
    ' Print #FileTriangleNormals, " ];"
    ' FileTriangleNormals.Close
    '
    Print #FileTriangleColors, " ]; "
    FileTriangleColors.Close

    fileVR.Close

    doVR = False

    modUtils.FileAppend(modestru.datos.proyecto & ".VR.html", modestru.datos.proyecto & ".lines")
    modUtils.FileAppend(modestru.datos.proyecto & ".VR.html", modestru.datos.proyecto & ".colors")
    modUtils.FileAppend(modestru.datos.proyecto & ".VR.html", modestru.datos.proyecto & ".triangles")
    ' modUtils.FileAppend(modestru.datos.proyecto & ".VR.html", modestru.datos.proyecto & ".Tnormals") ' Ahora se calculan en JS
    modUtils.FileAppend(modestru.datos.proyecto & ".VR.html", modestru.datos.proyecto & ".TUVs")
    modUtils.FileAppend(modestru.datos.proyecto & ".VR.html", modestru.datos.proyecto & ".Tcolors")

    modUtils.FileAppend(modestru.datos.proyecto & ".VR.html", Application.Path &/ "VirtualReality//HTML-Final7.txt")

    ' Message("HTML Creado")

End

Public Sub GenerarGrafico()

    ' Esta rutina se corre luego de cambios o del calculo

    ' Genera listas de dibujos de OpenGL, que luego son invocadas por dibujar_Estructura3D
    ' si es necesario graficarlas

    ' 12/9/16
    ' Voy a dividir todos los graficos por tipo y sector, para poder hacer vistas parciales cuando la estructura
    ' es muy grande asi se pueden distinguir las partes

    '

    Dim a As Integer
    Dim estadoViejo As Integer

    ' 2020
    ' VR

    VR_Start

    glListaCargas.Resize(20)

    hText = Gl.GenTextures(1)

    ' Primero borro las listas anteriores, si ya las hube creado

    If gl.IsList(glListaEstructura) Then gl.DeleteLists(glListaEstructura, 25) 'debo eliminar tantas listas como he creado
    If gl.IsList(glListaCargas[0]) Then gl.DeleteLists(glListaCargas[0], 20) 'debo eliminar tantas listas como he creado
    If gl.IsList(glListaEsfuerzos[0]) Then gl.DeleteLists(glListaEsfuerzos[0], 6) 'debo eliminar tantas listas como he creado
    If gl.IsList(glListaEsfuerzosLosas[0]) Then gl.DeleteLists(glListaEsfuerzosLosas[0], 6) 'debo eliminar tantas listas como he creado

    glListaEstructura = gl.GenLists(25)

    glListaCargas[0] = gl.GenLists(20)

    For a = 1 To 19
        glListaCargas[a] = glListaCargas[0] + a
    Next

    glListaEsfuerzos[1] = gl.GenLists(6)

    For a = 2 To 6
        glListaEsfuerzos[a] = glListaEsfuerzos[1] + a
    Next

    glListaEsfuerzosLosas[1] = gl.GenLists(6)

    For a = 2 To 6
        glListaEsfuerzosLosas[a] = glListaEsfuerzosLosas[1] + a
    Next

    If Not gl.IsList(glListaEstructura) Then
        fmain.debugInfo(("ERROR: No pueden generarse las lista de graficos de OpenGL"))
    Endif

    'glxxxxxxxxx = glListaEstructura + 1
    glListaApoyos = glListaEstructura + 2
    glListaMz = glListaEstructura + 3
    glListaN = glListaEstructura + 4
    glListaQy = glListaEstructura + 5
    glListaQz = glListaEstructura + 6
    glListaT = glListaEstructura + 7
    glListaMy = glListaEstructura + 8

    glListaMzLosas = glListaEstructura + 9
    glListaNLosas = glListaEstructura + 10
    glListaQyLosas = glListaEstructura + 11
    glListaQzLosas = glListaEstructura + 12
    glListaTLosas = glListaEstructura + 13
    glListaMyLosas = glListaEstructura + 14

    glListaE = glListaEstructura + 15
    glListaNudos = glListaEstructura + 16
    glListaBarras = glListaEstructura + 17
    glListaLosas = glListaEstructura + 18
    glListaColumnas = glListaEstructura + 19
    glListaVigas = glListaEstructura + 20
    glListaRender = glListaEstructura + 21
    glListaWireframe = glListaEstructura + 22
    glListaSubBarras = glListaEstructura + 23
    glListaLosasXXX = glListaEstructura + 24
    glListaColumnasXXX = glListaEstructura + 25
    glListaNumeroBarras = glListaEstructura + 26

    'empiezo por generar la lista basica de barras

    'dibujar_numero_barras

    DibujarBarras

    estadoViejo = modestru.flags.Estado

    For a = 1 To 20
        modestru.flags.Estado = a
        gl.NewList(glListaCargas[a - 1], gl.COMPILE)
        DibujarCargas
        gl.EndList
    Next
    modestru.flags.Estado = estadoViejo

    DibujarApoyos

    If modestru.flags.calculado Then 'genero los dibujos correspondientes post-calculo

        doVR = False  ' No vamos a generar contenido VR para esto

        gl.NewList(glListaMz, gl.COMPILE)
        DibujarEsfuerzos(Mz)

        gl.EndList

        ' 2020

        gl.NewList(glListaQy, gl.COMPILE)
        DibujarEsfuerzos(Qy)

        gl.EndList

        gl.NewList(glListaN, gl.COMPILE)
        DibujarEsfuerzos(N)

        gl.EndList

        gl.NewList(glListaQz, gl.COMPILE)
        DibujarEsfuerzos(Qz)

        gl.EndList

        gl.NewList(glListaT, gl.COMPILE)
        DibujarEsfuerzos(T)

        gl.EndList

        gl.NewList(glListaMy, gl.COMPILE)
        DibujarEsfuerzos(My)

        gl.EndList

        ' ======================================================================================
        gl.NewList(glListaMzLosas, gl.COMPILE)

        DibujarEsfuerzosLosas(2, Mz)
        gl.EndList

        gl.NewList(glListaQyLosas, gl.COMPILE)

        DibujarEsfuerzosLosas(2, Qy)
        gl.EndList

        gl.NewList(glListaNLosas, gl.COMPILE)

        DibujarEsfuerzosLosas(2, N)
        gl.EndList

        gl.NewList(glListaQzLosas, gl.COMPILE)

        DibujarEsfuerzosLosas(2, Qz)
        gl.EndList

        gl.NewList(glListaTLosas, gl.COMPILE)

        DibujarEsfuerzosLosas(2, T)
        gl.EndList

        gl.NewList(glListaMyLosas, gl.COMPILE)

        DibujarEsfuerzosLosas(2, My)
        gl.EndList

        DibujarElastica

    End If

    DibujarLosas

    doVR = True

    DibujarRender

    doVR = False

    DibujarSubBarras

    GenerarImgNroBarras(12, Color.Blue)

    GenerarImgNroNudos(12, Color.Black, Color.LightGray)

    VR_Finish

End

Sub dibujarapoyo(x As Float, Y As Float, z As Float, l As Float, tipo As Integer, angulo As Float)

    Dim a As Integer
    Dim h As Float
    Dim x1 As Float
    Dim y1 As Float
    Dim x2 As Float
    Dim y2 As Float

    Dim xm1 As Float
    Dim ym1 As Float
    Dim xm2 As Float
    Dim ym2 As Float

    Dim hg As Float

    Dim cc As Long

    Dim p1 As New Punto3d
    Dim p2 As New Punto3d
    Dim p4 As New Punto3d
    Dim p3 As New Punto3d
    Dim p5 As New Punto3d

    Select Case tipo
        Case 1 ' fijo
            glColorRGB(Color.Black)
            gl.LineWidth(1) 'SetAnchoLinea(1)

            p1.x = x
            p1.Y = Y
            p1.z = z
            p2.x = p1.x - l / 2
            p2.z = p1.z - l / 2
            p2.Y = p1.Y - l

            linea(p1, p2)

            Copy3D(p1, p2)
            p2.x = p1.x + l
            linea(p1, p2)

            copy3d(p1, p2)
            p2.x = p1.x - l / 2
            p2.z = p1.z + l / 2
            p2.Y = p1.Y + l
            linea(p1, p2)

            copy3d(p1, p2)
            p2.x = p1.x + l / 2
            p2.z = p1.z + l / 2
            p2.Y = p1.Y - l
            linea(p2, p1)

            copy3d(p1, p2)
            p2.x = p1.x - l
            linea(p1, p2)

            copy3d(p1, p2)
            p2.x = p1.x + l / 2
            p2.z = p1.z - l / 2
            p2.Y = p1.Y + l
            linea(p1, p2)

            p1.x = x - l / 2
            p1.z = z - l / 2
            p1.Y = Y - l

            copy3d(p2, p1)
            p2.z = p1.z + l
            linea(p1, p2)

            p1.x = x + l / 2
            p1.z = z - l / 2
            p1.Y = Y - l

            copy3d(p2, p1)
            p2.z = p1.z + l
            linea(p1, p2)

        Case 2 'movil

            gl.LineWidth(1) 'SetAnchoLinea(1)

            glColorRGB(Color.Gray)

            p1.x = x
            p1.Y = Y
            p1.z = z
            p2.x = p1.x - l / 2
            p2.z = p1.z - l / 2
            p2.Y = p1.Y - l

            linea(p1, p2)

            copy3d(p1, p2)
            p2.x = p1.x + l
            linea(p1, p2)

            copy3d(p1, p2)
            p2.x = p1.x - l / 2
            p2.z = p1.z + l / 2
            p2.Y = p1.Y + l
            linea(p1, p2)

            copy3d(p1, p2)
            p2.x = p1.x + l / 2
            p2.z = p1.z + l / 2
            p2.Y = p1.Y - l
            linea(p1, p2)

            copy3d(p1, p2)
            p2.x = p1.x - l
            linea(p1, p2)

            copy3d(p1, p2)
            p2.x = p1.x + l / 2
            p2.z = p1.z - l / 2
            p2.Y = p1.Y + l
            linea(p1, p2)

            p1.x = x - l / 2
            p1.z = z - l / 2
            p1.Y = Y - l

            copy3d(p2, p1)
            p2.z = p1.z + l
            linea(p1, p2)

            p1.x = x + l / 2
            p1.z = z - l / 2
            p1.Y = Y - l

            copy3d(p2, p1)
            p2.z = p1.z + l
            linea(p1, p2)

            ' base , que representa lo movil del apoyo

        Case 3, 4 'empotramiento
            If tipo = 3 Then
                glcolorRGB(Color.Black)
            Else If tipo = 4 Then
                glcolorRGB(Color.Gray)
            End If
            p1.x = x - l / 2
            p1.Y = Y
            p1.z = z - l / 2

            p2.x = x + l / 2
            p2.Y = Y
            p2.z = z - l / 2

            p3.x = x + l / 2
            p3.Y = Y
            p3.z = z + l / 2

            p4.x = x - l / 2
            p4.Y = Y
            p4.z = z + l / 2

            linea(p1, p2)
            linea(p2, p3)
            linea(p3, p4)
            linea(p1, p4)

            p1.Y = Y - l / 4
            p2.Y = Y - l / 4
            p3.Y = Y - l / 4
            p4.Y = Y - l / 4

            linea(p1, p2)
            linea(p2, p3)
            linea(p3, p4)
            linea(p1, p4)

            copy3d(p5, p1)
            p5.Y = Y
            linea(p1, p5)

            copy3d(p5, p2)
            p5.Y = Y
            linea(p2, p5)

            copy3d(p5, p3)
            p5.Y = Y
            linea(p3, p5)

            copy3d(p5, p4)
            p5.Y = Y
            linea(p4, p5)

        Case 44545 'empotramiento parcial

            glcolorRGB(Color.black)
            p1.x = x - l / 2
            p1.Y = Y
            p1.z = z - l / 2

            p2.x = x + l / 2
            p2.Y = Y
            p2.z = z - l / 2

            p3.x = x + l / 2
            p3.Y = Y
            p3.z = z + l / 2

            p4.x = x - l / 2
            p4.Y = Y
            p4.z = z + l / 2

            linea(p1, p2)
            linea(p2, p3)
            linea(p3, p4)
            linea(p1, p4)

            p1.Y = Y - l / 4
            p2.Y = Y - l / 4
            p3.Y = Y - l / 4
            p4.Y = Y - l / 4

            linea(p1, p2)
            linea(p2, p3)
            linea(p3, p4)
            linea(p1, p4)

            p5 = p1
            p5.Y = Y
            linea(p1, p5)

            p5 = p2
            p5.Y = Y
            linea(p2, p5)

            p5 = p3
            p5.Y = Y
            linea(p3, p5)

            p5 = p4
            p5.Y = Y
            linea(p4, p5)

        Case 5 ' elastico
            gl.linewidth(1) 'SetAnchoLinea(1)

            glcolorRGB(Color.Black)
            'Stop
            Select Case angulo
                Case 1 ' segun x
                    p1.x = x
                    p1.Y = Y
                    p1.z = z
                    p2.x = p1.x - l / 4
                    p2.Y = p1.Y - l / 4
                    p2.z = p1.z
                    linea(p1, p2)

                    p1 = p2
                    p2.x = p1.x - l / 4
                    p2.Y = Y + l / 4

                    linea(p1, p2)

                    p1 = p2
                    p2.x = p1.x - l / 4
                    p2.Y = Y - l / 4
                    linea(p1, p2)

                    p1 = p2
                    p2.x = p1.x - l / 4
                    p2.Y = Y + l / 4
                    linea(p1, p2)

                    p1 = p2
                    p2.x = p1.x - l / 4
                    p2.Y = Y - l / 8
                    linea(p1, p2)

                Case 2 ' y
                    'Stop
                    p1.x = x
                    p1.Y = Y
                    p1.z = z
                    p2.x = p1.x - l / 4
                    p2.Y = p1.Y - l / 4
                    p2.z = p1.z

                    linea(p1, p2)

                    p1 = p2
                    p2.x = x + l / 4
                    p2.Y = p1.Y - l / 4

                    linea(p1, p2)

                    p1 = p2
                    p2.x = x - l / 4
                    p2.Y = p1.Y - l / 4
                    linea(p1, p2)

                    p1 = p2
                    p2.x = x + l / 4
                    p2.Y = p1.Y - l / 4
                    linea(p1, p2)

                    p1 = p2
                    p2.x = x - l / 8
                    p2.Y = p1.Y - l / 4
                    linea(p1, p2)

                Case 3 'z
                    p1.x = x
                    p1.Y = Y
                    p1.z = z
                    p2.x = p1.x - l / 4
                    p2.Y = p1.Y
                    p2.z = p1.z - l / 4
                    linea(p1, p2)

                    p1 = p2
                    p2.x = x + l / 4
                    p2.z = p1.z - l / 4

                    linea(p1, p2)

                    p1 = p2
                    p2.x = x - l / 4
                    p2.z = p1.z - l / 4
                    linea(p1, p2)

                    p1 = p2
                    p2.x = x + l / 4
                    p2.z = p1.z - l / 4
                    linea(p1, p2)

                    p1 = p2
                    p2.x = x - l / 8
                    p2.z = p1.z - l / 4
                    linea(p1, p2)

            End Select

    End Select

End Sub

Sub DibujarApoyos()
    ' grafica los apoyos y los nudos reticulados expresamente

    Dim a As Integer, b As Integer, x0 As Float, y0 As Float, z0 As Float
    Dim p1 As New Punto3d, p2 As New Punto3d
    Dim lll As Float

    ' para la escala hago un promedio entre la barra corta y la estructura
    lll = ((modestru.graficos.barra_larga * 0.25) + (modEstru.graficos.barra_corta * 0.25) + modEstru.graficos.largo_estructura * 0.025) / 3

    ' el tmaño del apoyo es el 25% del largo de la barra mas corta
    gl.NewList(glListaApoyos, gl.COMPILE)
    For a = 0 To modestru.apoyos.Max
        b = modestru.apoyos[a].nudo

        x0 = modestru.nudo[b].x
        y0 = modestru.nudo[b].Y
        z0 = modestru.nudo[b].z

        Select Case modestru.datos.tipo
            Case modestru.reticuladoplano, modestru.porticoplano

                If (((modestru.apoyos[a].rx <> 0) And (modestru.apoyos[a].ry <> 0)) And (modestru.apoyos[a].rmz = 0)) Then
                    dibujarapoyo(x0, y0, z0, lll, 1, 0)
                Else If (((modestru.apoyos[a].rx <> 0) Or (modestru.apoyos[a].ry <> 0)) And (modestru.apoyos[a].rmz = 0)) Then
                    dibujarapoyo(x0, y0, z0, lll, 2, 0)
                Else If (modestru.apoyos[a].rmz <> 0) Then

                    dibujarapoyo(x0, y0, z0, lll, 3, 180)
                End If

                If modestru.apoyos[a].ex <> 0 Then dibujarapoyo(x0, y0, z0, lll, 5, 1)

                If modestru.apoyos[a].ey <> 0 Then dibujarapoyo(x0, y0, z0, lll, 5, 2)

            Case modestru.reticuladoespacial, modestru.porticoespacial

                If ((modestru.apoyos[a].rx <> 0) And (modestru.apoyos[a].ry <> 0) And (modestru.apoyos[a].rz <> 0)) And ((modestru.apoyos[a].rmx = 0) Or (modestru.apoyos[a].rmy = 0) Or (modestru.apoyos[a].rmz = 0)) Then
                    dibujarapoyo(x0, y0, z0, lll, 1, 0)
                Else If ((modestru.apoyos[a].rx <> 0) Or (modestru.apoyos[a].ry <> 0) Or (modestru.apoyos[a].rz <> 0)) And ((modestru.apoyos[a].rmx = 0) And (modestru.apoyos[a].rmy = 0) And (modestru.apoyos[a].rmz = 0)) Then
                    dibujarapoyo(x0, y0, z0, lll, 2, 0)

                Else If (modestru.apoyos[a].rmx <> 0) And (modestru.apoyos[a].rmy <> 0) And (modestru.apoyos[a].rmz <> 0) Then

                    dibujarapoyo(x0, y0, z0, lll, 3, 180)
                Else If (modestru.apoyos[a].rmx <> 0) Or (modestru.apoyos[a].rmy <> 0) Or (modestru.apoyos[a].rmz <> 0) Then

                    dibujarapoyo(x0, y0, z0, lll, 4, 180)
                End If
                'Stop
                If modestru.apoyos[a].ex <> 0 Then dibujarapoyo(x0, y0, z0, lll, 5, 1)

                If modestru.apoyos[a].ey <> 0 Then dibujarapoyo(x0, y0, z0, lll, 5, 2)

                If modestru.apoyos[a].ez <> 0 Then dibujarapoyo(x0, y0, z0, lll, 5, 3)
        End Select

    Next

    For Each bar As ClsBarra In modestru.barra
        If (bar.restriccion And 1) = 1 Then
            a = bar.ni
            p1.x = modestru.nudo[a].x
            p1.Y = modestru.nudo[a].Y
            p1.z = modestru.nudo[a].z

            If x0 <> 0 And y0 <> 0 Then circulo(p1, fmain.gestru.Width / 160, Color.Black, True)

        End If
        If (bar.restriccion And 2) = 2 Then
            a = bar.nF
            p1.x = modestru.nudo[a].x
            p1.Y = modestru.nudo[a].Y
            p1.z = modestru.nudo[a].z

            If x0 <> 0 And y0 <> 0 Then circulo(p1, fmain.gestru.Width / 160, Color.Black, True)
        End If
    Next
    gl.EndList

End Sub

Sub dibujar_numero_vigas()

    Dim x0 As Float, y0 As Float
    Dim x1 As Float, y1 As Float, p1 As New Punto3d, p2 As New Punto3d, p3 As New Punto3d
    Dim ni As Integer, nF As Integer, a As Integer, q As String

    With modestru

        For a = 0 To .vigas.Max
            If ((.graficos.FiltroSector <= 0) Or (.vigas[a].sector = .graficos.FiltroSector)) And ((.graficos.FiltroTipo <= 0) Or (.graficos.FiltroTipo = .tipo_viga)) Then

                q = Format$(.vigas[a].numero, "0") & "-" & Format$(.vigas[a].piso, "0")
                ni = .vigas[a].nudo1
                nF = .vigas[a].nudo2

                p1.x = .nudo[ni].x
                p1.Y = .nudo[ni].Y
                p1.z = .nudo[ni].z

                p2.x = .nudo[nF].x
                p2.Y = .nudo[nF].Y
                p2.z = .nudo[nF].z

                p3.x = p1.x + (p2.x - p1.x) / 2
                p3.y = p1.y + (p2.y - p1.y) / 2
                p3.z = p1.z + (p2.z - p1.z) / 2

                txtRendering3D(q, p3, 12, Color.Black, Color.White, 2, 2)
            End If

        Next
    End With

End Sub

Sub dibujar_vigas()

    Dim x0 As Float, y0 As Float
    Dim x1 As Float, y1 As Float, p1 As New Punto3d, p2 As New Punto3d, p3 As New Punto3d
    Dim ni As Integer, nF As Integer, a As Integer, q As String

    With modestru

        For a = 0 To .vigas.Max

            If ((.graficos.FiltroSector <= 0) Or (.vigas[a].sector = .graficos.FiltroSector)) And ((.graficos.FiltroTipo <= 0) Or (.graficos.FiltroTipo = .tipo_viga)) Then

                prisma2(.nudo[.vigas[a].nudo1], .nudo[.vigas[a].nudo2], .secciones[.vigas[a].seccion].a, .secciones[.vigas[a].seccion].b, 1, True)

            End If
        Next

    End With

End Sub

Sub DibujarCargaPuntual2(punta As Punto3d, cola As Punto3d, colorflecha As Integer)

    DibujarCargaPuntual3(punta, cola, colorflecha)
    Return

    Dim lw As Float, co As Integer

    ' linea pricipal
    'If colorflecha >= 0 Then glcolorRGB Color.SetAlpha(colorflecha, 192)

    ' la linea principal
    linea(cola, punta, colorflecha, 1)

    cola.x = punta.x + (cola.x - punta.x) * 0.1
    cola.y = punta.y + (cola.y - punta.y) * 0.1
    cola.z = punta.z + (cola.z - punta.z) * 0.1

    linea(cola, punta, colorflecha, 2)

    punta.x = punta.x + (cola.x - punta.x) * 0.5
    punta.y = punta.y + (cola.y - punta.y) * 0.5
    punta.z = punta.z + (cola.z - punta.z) * 0.5

    linea(cola, punta, colorflecha, 4)

End Sub

Sub DibujarCargaPuntual3(punta As Punto3d, cola As Punto3d, colorflecha As Integer)

    ' esto podria llamarse dibujarFlecha

    Dim lw As Float, co As Integer, cola2 As New Punto3d

    ' linea pricipal

    ' 2020
    ' debido a limitaciones en WebGL voy a redibujar esto como una flecha hecha de lineas del mismo ancho

    ' la linea principal
    linea(cola, punta, colorflecha, 1)

    lw = ((cola.x - punta.x) * 0.1 + (cola.y - punta.y) * 0.1 + (cola.z - punta.z) * 0.1) / 6

    cola.x = punta.x + (cola.x - punta.x) * 0.1
    cola.y = punta.y + (cola.y - punta.y) * 0.1
    cola.z = punta.z + (cola.z - punta.z) * 0.1

    cola2.x = cola.x + lw
    cola2.y = cola.y
    cola2.z = cola.z

    linea(cola2, punta, colorflecha)

    cola2.x = cola.x
    cola2.y = cola.y + lw
    cola2.z = cola.z

    linea(cola2, punta, colorflecha)

    cola2.x = cola.x
    cola2.y = cola.y
    cola2.z = cola.z + lw

    linea(cola2, punta, colorflecha)

    cola2.x = cola.x - lw
    cola2.y = cola.y
    cola2.z = cola.z

    linea(cola2, punta, colorflecha)

    cola2.x = cola.x
    cola2.y = cola.y - lw
    cola2.z = cola.z

    linea(cola2, punta, colorflecha)

    cola2.x = cola.x
    cola2.y = cola.y
    cola2.z = cola.z - lw

    linea(cola2, punta, colorflecha)

End Sub

Public Sub DibujarElastica()

    Dim p0 As New Punto3d, p1 As New Punto3d, p As New Punto3d, pd As New Punto3d
    Dim XNI As Float, YNI As Float, ZNI As Float, XNF As Float, a As Integer, ca As Integer, cero As Integer, cero2 As Integer
    Dim YNF As Float, ZNF As Float, l As Float, xz As Float

    Dim dx As Float, dz As Float, tramo As Integer, dy As Float
    Dim x As Float, z As Float, Y As Float

    Dim NodeI, NodeF As ClsNudo

    'Dim XNI As Float, YNI As Float, ZNI As Float, XNF As Float, a As Integer, ca As Integer, cero As Integer, cero2 As Integer
    'Dim YNF As Float, ZNF As Float, l As Float, xz As Float

    panned = True

    ' corrijo el facrtor, en caso de ser 0
    If modestru.graficos.FactorFlecha = 0 Then modestru.graficos.FactorFlecha = 1
    'graficos.FactorFlecha = cpval(fmain.escela.Text)

    ' corrijo el facrtor, en caso de ser 0
    If modestru.setting.IntervaloElastica = 0 Then modestru.setting.IntervaloElastica = 20

    ' esto ya esta previsto para el maximo TODO
    gl.NewList(glListaE, gl.COMPILE)

    glcolorRGB(Color.Magenta)
    For Each bar As ClsBarra In modestru.barra
        nodeI = modestru.nudo[bar.ni]
        nodeF = modestru.nudo[bar.nf]

        If modestru.FiltroBarra(bar, IIf(modestru.graficos.FiltroSector > 0, modestru.graficos.FiltroSector, -1),, IIf(modestru.graficos.FiltroTipo > 0, modestru.graficos.FiltroTipo, -1)) Then

            cero = 1
            l = modestru.longitud(bar)
            ' uso la rutina que genera la elastica

            modCalculus.generar_elastica(bar)

            XNI = nodeI.x + modestru.graficos.FactorFlecha * nodei.dezplazamientos.dx
            YNI = nodeI.Y + modestru.graficos.FactorFlecha * nodei.dezplazamientos.dy
            ZNI = nodeI.z + modestru.graficos.FactorFlecha * nodei.dezplazamientos.dz

            XNF = nodef.x + modestru.graficos.FactorFlecha * nodef.dezplazamientos.dx
            YNF = nodef.Y + modestru.graficos.FactorFlecha * nodef.dezplazamientos.dy
            ZNF = nodef.z + modestru.graficos.FactorFlecha * nodef.dezplazamientos.dz
            '    Stop
            dx = (XNF - XNI) / (modestru.setting.IntervaloElastica)
            dy = (YNF - YNI) / (modestru.setting.IntervaloElastica)
            dz = (ZNF - ZNI) / (modestru.setting.IntervaloElastica)

            p0.x = XNI
            p0.Y = YNI
            p0.z = ZNI

            p1.x = XNF
            p1.Y = YNI
            p1.z = ZNI

            p.x = dx
            p.y = dy
            p.z = dz

            SetLocalMatrix(nodei.XYZ, nodef.XYZ)

            For tramo = 0 To modestru.setting.IntervaloElastica

                ' paso de elastica local a global
                ' sobreescribo la posición de nudo

                'If tramo = 5 Then Stop

                '
                ' p.x = XNI + dx * tramo + x
                ' p.Y = YNI + dy * tramo + Y
                ' p.z = ZNI + dz * tramo + z
                pd.x = 0
                pd.y = modestru.graficos.FactorFlecha * modestru.vectorE[tramo].Y
                pd.z = modestru.graficos.FactorFlecha * modestru.vectorE[tramo].z

                Local3D(pd, p)

                p.x += XNI + dx * tramo
                p.Y += YNI + dy * tramo
                p.z += ZNI + dz * tramo

                linea(p0, p)

                copy3d(p0, p)

            Next

        End If

    Next

    panned = False
    gl.EndList

End Sub

Sub dibujarmomento(cola As Punto3d, punta As Punto3d, colorflecha As Long)

    Dim p1 As New Punto3d, p2 As New Punto3d, p3 As New Punto3d, p4 As New Punto3d, p5 As New Punto3d

    p1.x = punta.x + (cola.x - punta.x) * 0.06
    p1.y = punta.y + (cola.y - punta.y) * 0.06
    p1.z = punta.z + (cola.z - punta.z) * 0.06

    p2.x = punta.x + (cola.x - punta.x) * 0.12
    p2.y = punta.y + (cola.y - punta.y) * 0.12
    p2.z = punta.z + (cola.z - punta.z) * 0.12

    p3.x = punta.x + (cola.x - punta.x) * 0.18
    p3.y = punta.y + (cola.y - punta.y) * 0.18
    p3.z = punta.z + (cola.z - punta.z) * 0.18

    p4.x = punta.x + (cola.x - punta.x) * 0.24
    p4.y = punta.y + (cola.y - punta.y) * 0.24
    p4.z = punta.z + (cola.z - punta.z) * 0.24

    p5.x = punta.x + (cola.x - punta.x) * 0.3
    p5.y = punta.y + (cola.y - punta.y) * 0.3
    p5.z = punta.z + (cola.z - punta.z) * 0.3

    ' linea pricipal
    glcolorRGB(colorflecha)
    linea(cola, punta)

    linea(punta, p1,, 2)

    linea(p1, p2,, 4)

    linea(p3, p4,, 2)

    linea(p4, p5,, 4)

End Sub

Sub dibujarmomento2(cola As Punto3d, punta As Punto3d, colorflecha As Long)

    '2020
    Dim p1 As New Punto3d

    p1.x = punta.x + (cola.x - punta.x) * 0.2
    p1.y = punta.y + (cola.y - punta.y) * 0.2
    p1.z = punta.z + (cola.z - punta.z) * 0.2

    ' linea pricipal
    glcolorRGB(colorflecha)

    DibujarCargaPuntual3(cola, punta, colorflecha)
    DibujarCargaPuntual3(cola, p1, colorflecha)

End Sub

Sub dibujarnudos()

    Dim a As Integer

    For a = 1 To modestru.nudo.max

        If modestru.nudo[a].grupo = 0 Then
            DibujarNudo(a, Color.Black)
        Else
            DibujarNudo(a, Color.LightGray)
        End If
    Next

End Sub

Public Sub SetLocalMatrix(Vector0 As Punto3d, Vector1 As Punto3d)

    ' establece la transformacion para un vector que va de vercor0 a vector1
    ' entonces las coordenadas de barra se transforman a globales con Local3D()

    Dim dx2z2 As Float, lx As Float, ly As Float, lz As Float, l As Float

    lx = (Vector1.x - Vector0.x)
    ly = (Vector1.y - Vector0.y)
    lz = (Vector1.z - Vector0.z)
    l = Sqr(lx ^ 2 + ly ^ 2 + lz ^ 2)

    dx2z2 = Sqr(lx ^ 2 + lz ^ 2)
    'Stop
    If dx2z2 <> 0 Then

        MatrizLocal[0, 0] = lx / l
        MatrizLocal[0, 1] = ly / l
        MatrizLocal[0, 2] = lz / l
        MatrizLocal[1, 0] = -ly * lx / l / dx2z2
        MatrizLocal[1, 1] = dx2z2 / l
        MatrizLocal[1, 2] = -ly * lz / l / dx2z2
        MatrizLocal[2, 0] = -lz / dx2z2
        MatrizLocal[2, 1] = 0
        MatrizLocal[2, 2] = lx / dx2z2

    Else
        ' en este caso voy a tener una indeterminación
        ' lo que pasa si yi > yf, es al reves--> pongo un if
        '    Stop
        If ly > 0 Then

            MatrizLocal[0, 0] = 0
            MatrizLocal[0, 1] = 1
            MatrizLocal[0, 2] = 0
            MatrizLocal[1, 0] = -1
            MatrizLocal[1, 1] = 0
            MatrizLocal[1, 2] = 0
            MatrizLocal[2, 0] = 0
            MatrizLocal[2, 1] = 0
            MatrizLocal[2, 2] = 1

        Else
            MatrizLocal[0, 0] = 0
            MatrizLocal[0, 1] = -1
            MatrizLocal[0, 2] = 0
            MatrizLocal[1, 0] = 1
            MatrizLocal[1, 1] = 0
            MatrizLocal[1, 2] = 0
            MatrizLocal[2, 0] = 0
            MatrizLocal[2, 1] = 0
            MatrizLocal[2, 2] = 1 ' esto lo puse a ojo

        End If
        '    Stop
    End If
    ' ahora debo transponer esta matriz
    matrix8.trasponer(MatrizLocal, 3)

    'modLibMatrix8.M8trasponerSQ(MatrizLocal, 3)

    'modLibMatrix8.SetMatrizRotacionLocal(MatrizLocal)

    '==============================================================
    ' hasta aca, se podría fijar una sola vez, para acelerar
    ' y lo que sigue sería la rutina transformadora.
End

Public Sub Local3D(p0 As Punto3d, result As Punto3d)

    result.x = MatrizLocal[0, 0] * p0.x + MatrizLocal[0, 1] * p0.y + MatrizLocal[0, 2] * p0.z

    result.y = MatrizLocal[1, 0] * p0.x + MatrizLocal[1, 1] * p0.y + MatrizLocal[1, 2] * p0.z

    result.z = MatrizLocal[2, 0] * p0.x + MatrizLocal[2, 1] * p0.y + MatrizLocal[2, 2] * p0.z

End

Public Sub valoresdelgrafico3D()
    ' Escalas de los grficos (la de esfuerzos esta en )

    'On Error GoTo zoom_malo:
    Dim a As Integer
    Dim pixell As Single
    Dim l As Float

    GetCG()

    'Stop
    mundo_max.x = 0
    mundo_max.Y = 0
    mundo_max.z = 0

    mundo_min.x = 0
    mundo_min.Y = 0
    mundo_min.z = 0
    'If modestru.nudo.max = 0 Then Return
    ' veo deonde esa ubicada la estructura segun ejes globales
    For Each n As Clsnudo In modestru.nudo
        ' maximos
        If n.x > mundo_max.x Then mundo_max.x = n.x
        If n.Y > mundo_max.Y Then mundo_max.Y = n.Y
        If n.z > mundo_max.z Then mundo_max.z = n.z

        ' minimos
        If n.x < mundo_min.x Then mundo_min.x = n.x
        If n.y < mundo_min.Y Then mundo_min.Y = n.y
        If n.z < mundo_min.z Then mundo_min.z = n.z
    Next

    maxmax = Abs(mundo_max.x - mundo_min.x)
    If maxmax < Abs(mundo_max.Y - mundo_min.Y) Then maxmax = Abs(mundo_max.Y - mundo_min.Y)
    If maxmax < Abs(mundo_max.z - mundo_min.z) Then maxmax = Abs(mundo_max.z - mundo_min.z)

    ' maxmax es el abs de la coordena de mas valor
    modestru.graficos.largo_estructura = Sqr((mundo_max.x - mundo_min.x) ^ 2 + (mundo_max.Y - mundo_min.Y) ^ 2 + (mundo_max.z - mundo_min.z) ^ 2)
    modestru.graficos.barra_corta = 1000000
    modestru.graficos.barra_larga = 0
    For Each b As ClsBarra In modestru.barra
        l = modestru.longitud(b)
        If modestru.graficos.barra_corta > l Then modestru.graficos.barra_corta = l
        If modestru.graficos.barra_larga < l Then modestru.graficos.barra_larga = l
    Next

    If maxmax = 0 Then maxmax = 1

    modestru.graficos.fMax = maxmax

    ' TODO en algul lado acomodar esto
    'fmain.gestru.Scale(- draw.Width, draw.Height, draw.Width, - draw.Height)

    ' el zoom normal lo defino por la altura, porque siempre sera menor
    If mundo_max.x = mundo_min.x Then
        mundo_max.x += maxmax / 100
        mundo_min.x -= maxmax / 100
    End If
    If mundo_max.y = mundo_min.y Then
        mundo_max.y += maxmax / 100
        mundo_min.y -= maxmax / 100
    End If
    If mundo_max.z = mundo_min.z Then
        mundo_max.z += maxmax / 100
        mundo_min.z -= maxmax / 100
    End If

    'esto previene erres de division por 0

    'pixell = fmain.gestru.Height / fmain.gestru.ScaleHeight

    'Snaping.SnapDistance = (150 / pixell) ^ 2
    'Snaping.MarkSize = 150 / pixell
    'Stop
    ' el paneo esta referido a escala pantalla, no mundo

    escala = 1 / maxmax

    'esto evita recalcular parametros innecesarios
    modestru.graficos.cambios = False

    GLCam.Initialize

    GLCam.Position.x = cgx
    GLCam.Position.y = cgy
    GLCam.Position.z = cgz + 2 * maxmax

    ' envio a C

End Sub

Public Sub dibujar_estructura3D()
    ' 26/4
    ' voy a reescribir la rutinita
    ' 0 - Chequeo que la estructura tenga suficientes nodos (>1) y barras (>0)
    ' 1'-Dibujo los ejes
    ' 1 - Dibujo las barras
    ' 2 - Dibujo los apoyos
    ' 3 - Dibujo las cargas
    ' 4 - Dibujo los esfuerzos
    ' 5 - Dibujo la elástica
    ' 6 - Escribo los nodos
    ' 7 - Escribo las barras

    ' Excepto la primera, las demas serán todas sub-rutinas
    Dim ok As Integer, tDraw As Date
    Dim a As Integer, b As Integer
    Dim x0 As Float, y0 As Float
    Dim x1 As Float, y1 As Float
    Dim p1 As New Punto3d, p2 As New Punto3d, p3 As New Punto3d, p4 As New Punto3d

    If modestru.flags.dibujando Then

        modUtils.DoEvents
        Debug "ya estoy dibujando " & Format$(Time, "mm:ss")
        Return
    End If

    If Not modestru.flags.dibujable Then Return

    gl.Clear(gl.DEPTH_BUFFER_BIT Or gl.COLOR_BUFFER_BIT)

    gl.Enable(gl.DEPTH_TEST)
    gl.Enable(gl.SMOOTH)

    gl.MatrixMode(gl.PROJECTION)

    gl.LoadIdentity()

    Glu.Perspective(45, fmain.gestru.w / fmain.gestru.h, 0.1, 100)

    gl.MatrixMode(gl.MODELVIEW)

    gl.LoadIdentity()

    p3.x = 0
    p3.y = 0
    p3.z = 0

    gl.Scalef(escala, escala, escala)

    'LucesOn

    GLCam.render
    LucesOn

    '
    If modestru.graficos.render Then
        'If .barra[b].seleccionado Then bColor = .graficos.colores.seleccion Else bcolor = .graficos.colores.barras

        'glMaterial(Color.Blue)
        gl.CallList(glListaRender)
    Else

        gl.CallList(glListaEstructura)

    End If

    LucesOff

    ' TODO generar mas listas para las combinaciones

    If modestru.graficos.SeDibujanCargas Then gl.CallList(glListaCargas[modestru.flags.Estado - 1])
    'If modestru.graficos.SeDibujanNudos Then dibujarnudos  '  --> ahora esta en la rutin barras
    If modestru.graficos.SeDibujanApoyos Then gl.CallList(glListaApoyos)

    If modestru.graficos.wireframe Then
        gl.CallList(glListaWireframe)

    End If

    If modestru.flags.calculado Then

        If modestru.graficos.n Then gl.CallList(glListaN)
        If modestru.graficos.Qy Then gl.CallList(glListaQy)
        If modestru.graficos.Qz Then gl.CallList(glListaQz)
        If modestru.graficos.t Then gl.CallList(glListaT)
        If modestru.graficos.My Then gl.CallList(glListaMy)
        If modestru.graficos.Mz Then gl.CallList(glListaMz)

        If modestru.graficos.n Then gl.CallList(glListaNLosas)
        If modestru.graficos.Qy Then gl.CallList(glListaQyLosas)
        If modestru.graficos.Qz Then gl.CallList(glListaQzLosas)
        If modestru.graficos.t Then gl.CallList(glListaTLosas)
        If modestru.graficos.My Then gl.CallList(glListaMyLosas)
        If modestru.graficos.Mz Then gl.CallList(glListaMzLosas)

        If modestru.graficos.e Then gl.CallList(glListaE)

        If modestru.flags.CalculadoEnvolventes Then
            dibujar_esfuerzos_env_neg
            dibujar_esfuerzos_env_pos
        Endif
    Else
        gl.CallList(glListaLosas)

    End If

    ' If modestru.graficos.SeDibujanNudos Then DibujarNroNudos(2, 2)

    If modestru.graficos.sedibujanbarras Then

        DibujarNroBarras(2, 2)
        dibujar_numero_vigas

        dibujar_numero_losas
    End If
    If modestru.graficos.sedibujanejes Then dibujarejes

    'testRender

    'tDraw = Timer
    DibujarEscalaColor

    ' hubo cambios?
    'If modestru.graficos.cambios Then valoresdelgrafico3D

    ' WheelInstance = 0
    ' DrawingInstance = 0
    '
    '
    ' QuitDrawing = False
    '
    ' modestru.flags.dibujando = False
    ' modestru.flags.dibujado = True
    '
    ' fmain.debugInfo("Dibujado en " & Format$(Timer - tDraw, "0.0000"))
    '
    ' modUtils.DoEvents

End Sub

Public Sub DibujarEjes()
    ' voy a utilizar los conversores

    Dim largo As Float, p1 As New Punto3d, p2 As New Punto3d

    largo = modestru.graficos.largo_estructura / 20

    p1.x = largo
    p1.Y = 0
    p1.z = 0

    p2.x = 0
    p2.Y = 0
    p2.z = 0

    DibujarCargaPuntual2(p1, p2, Color.Black)
    p1.x = 0
    p1.Y = largo
    p1.z = 0

    p2.x = 0
    p2.Y = 0
    p2.z = 0

    DibujarCargaPuntual2(p1, p2, Color.black)
    p1.x = 0
    p1.Y = 0
    p1.z = largo

    p2.x = 0
    p2.Y = 0
    p2.z = 0

    DibujarCargaPuntual2(p1, p2, Color.Black)

    p1.x = largo + largo / 4
    p1.Y = 0
    p1.z = 0

    txtRendering3D("X", p1, 10, Color.Black, Color.White, 2, 2)

    p1.x = 0
    p1.Y = largo + largo / 4
    p1.z = 0

    txtRendering3D("Y", p1, 10, Color.Black, Color.White, 2, 2)

    p1.x = 0
    p1.Y = 0
    p1.z = largo + largo / 4

    txtRendering3D("Z", p1, 10, Color.Black, Color.White, 2, 2)

End Sub

Public Sub DibujarCargas()
    ' en realidad esta es la rutina que dibuja todas las cargas de la estructura

    Dim bbb As Integer, NNI As Integer, nnf As Integer
    Dim a As Integer, p1 As New Punto3d, p2 As New Punto3d
    ' obtencion de la maxima carga puntual
    Dim maxmom As Float, maxrep As Float, maxpun As Float, laperra As Float, la As Float
    Dim lb As Float, escmom As Float, escrep As Float, escpun As Float, zpunta As Float
    Dim ypunta As Float, xpunta As Float, zcola As Float, ycola As Float, xcola As Float
    Dim Xi As Float, Yi As Float, Zi As Float, x As Float, Y As Float
    Dim z As Float, ppx As Float, ppy As Float, ppz As Float, Xf As Float
    Dim Yf As Float, Zf As Float, l As Float, yg As Float, xg As Float, alfa As Float
    Dim punta As New Punto3d, cola As New Punto3d
    Dim PasoAjustado As Integer
    Dim ColorCarga As Integer
    Dim CargaCierre As Boolean
    Dim n As ClsNudo, cn As ClsCargaNudo
    Dim b As ClsBarra, cb As ClsCargaBarra

    '----------------------------------------------------------------------------
    ' CALCULO DE LOS MAXIMOS PARA ESTABLECER LA ESCALA DE CARGAS
    maxpun = 0
    maxmom = 0
    maxrep = 0
    For Each n In modestru.nudo 'a = 1 To modestru.datos.totalcargasnudo
        For Each cn In n.cargas
            If cn.Estado = modestru.flags.Estado Then
                If Abs(cn.fx) > maxpun Then maxpun = Abs(cn.fx)
                If Abs(cn.fy) > maxpun Then maxpun = Abs(cn.fy)
                If Abs(cn.fz) > maxpun Then maxpun = Abs(cn.fz)
                If Abs(cn.mx) > maxmom Then maxmom = Abs(cn.mx)
                If Abs(cn.My) > maxmom Then maxmom = Abs(cn.My)
                If Abs(cn.Mz) > maxmom Then maxmom = Abs(cn.Mz)
            End If
        Next
    Next

    For Each b In modestru.barra ' a = 1 To modestru.cargasbarra.max
        For Each cb In b.cargas
            If (modestru.flags.Estado = cb.e) Then
                If (cb.tipo = 1) Or (cb.tipo = 21) Then
                    If (cb.px ^ 2 + cb.py ^ 2 + cb.pz ^ 2) ^ 0.5 Then
                        maxpun = Abs((cb.px ^ 2 + cb.py ^ 2 + cb.pz ^ 2) ^ 0.5)
                    End If
                End If
                If (cb.tipo = 2) Or (cb.tipo = 3) Or (cb.tipo = 22) Then
                    If maxrep < Abs((cb.px ^ 2 + cb.py ^ 2 + cb.pz ^ 2) ^ 0.5) Then
                        maxrep = Abs((cb.px ^ 2 + cb.py ^ 2 + cb.pz ^ 2) ^ 0.5)
                    End If
                End If
            End If
        Next
    Next

    If maxmom < 1E-300 Then maxmom = 1
    If maxrep < 1E-300 Then maxrep = 1
    If maxpun < 1E-300 Then maxpun = 1

    escpun = (modestru.graficos.barra_corta * 0.25 + modestru.graficos.largo_estructura * 0.15) / 2 / maxpun
    escrep = (modestru.graficos.barra_corta * 0.25 + modestru.graficos.largo_estructura * 0.15) / 2 / maxrep
    escmom = (modestru.graficos.barra_corta * 0.25 + modestru.graficos.largo_estructura * 0.15) / 2 / maxmom

    ' NUEVO
    If escpun < escrep Then escrep = escpun Else escpun = escrep

    '-----------------------------------------------------------------------------
    ColorCarga = Color.SetAlpha(Color.red, 128)
    '----------------------------------------------------------------------------
    'DIBUJO LAS CARGAS EN LOS NUDOS

    For Each n In modestru.nudo 'a = 1 To modestru.datos.totalcargasnudo
        For Each cn In n.cargas

            If (cn.Estado = modestru.flags.Estado) Then

                If (cn.fx <> 0) Or (cn.fy <> 0) Or (cn.fz <> 0) Then

                    ' coordenadas globales
                    punta = n.XYZ

                    cola.x = n.x - cn.fx * escpun
                    cola.Y = n.y - cn.fy * escpun
                    cola.z = n.z - cn.fz * escpun
                    ' paso directamente a coor. 2D de pantalla
                    DibujarCargaPuntual2(punta, cola, Color.Blue)
                End If
                If (cn.mx <> 0) Or (cn.My <> 0) Or (cn.Mz <> 0) Then
                    ' la carga de momento es un poco mas complicada
                    ' deberia ser una flecha doble --->> o en otro color

                    punta = n.XYZ

                    cola.x = n.x + cn.mx * escmom
                    cola.Y = n.y + cn.My * escmom
                    cola.z = n.z + cn.Mz * escmom

                    dibujarmomento2(cola, punta, Color.red)
                End If
            End If
        Next
    Next

    '-----------------------------------------------------------------------------

    '----------------------------------------------------------------------------
    'DIBUJO LAS CARGAS EN LOS BARRAS
    ' aca se pone interesante. voy a usar las rutinas nuevas de rotaciones

    For Each b In modestru.barra ' a = 1 To modestru.cargasbarra.max
        For Each cb In b.cargas
            'bbb = cb.barra  ' BARRA CONSIDERADA
            l = modestru.longitud(b)

            If (cb.tipo <> 0) And (modestru.flags.Estado = cb.e) And (l > 0) And modestru.FiltroBarra(b, IIf(modestru.graficos.FiltroSector > 0, modestru.graficos.FiltroSector, -1),, IIf(modestru.graficos.FiltroTipo > 0, modestru.graficos.FiltroTipo, -1)) Then

                ' Debug a, bbb, cb.py

                ' Lo que sigue es para no generar lineas largas
                ' CORDINATES OF INITIAL NODE
                'NNI = b.ni                ' NUDO INICIAL
                Xi = modestru.nudo[b.ni].x
                Yi = modestru.nudo[b.ni].y
                Zi = modestru.nudo[b.ni].z

                ' CORDINATES OF fINAL NODE
                'nnf = b.nF                ' NUDO FINAL
                Xf = modestru.nudo[b.nF].x
                Yf = modestru.nudo[b.nF].y
                Zf = modestru.nudo[b.nF].z

                ' datos en coordenadas LOCALES
                ppx = cb.px
                ppy = cb.py
                ppz = cb.pz

                ' o lo llamos p1 tambien
                p1.x = ppx
                p1.y = ppy
                p1.x = ppz

                PasoAjustado = GetPixelsLenght(b) / 15

                If PasoAjustado < 2 Then PasoAjustado = 2

                SetLocalMatrix(modestru.nudo[b.NI].xyz, modestru.nudo[b.Nf].xyz)

                Select Case cb.tipo
                    Case 21 'carga puntual gravitatoria

                        ' punto de aplicacion de la carga
                        'modCalculus.qLocal(bbb, ppx, ppy, ppz, ByRef ppx, ByRef ppy, ByRef ppz)

                        la = cb.a

                        ' esto esta en coord. globales
                        punta.x = Xi + (Xf - Xi) * la / l
                        punta.Y = Yi + (Yf - Yi) * la / l
                        punta.z = Zi + (Zf - Zi) * la / l

                        ' posicion de la cola

                        cola.x = punta.x - ppx * escpun
                        cola.y = punta.y - ppy * escpun
                        cola.z = punta.z - ppz * escpun

                        DibujarCargaPuntual2(punta, cola, Color.Green)

                    Case 22 'carga repartida gravitatoria
                        'modCalculus.qLocal(bbb, ppx, ppy, ppz, ByRef ppx, ByRef ppy, ByRef ppz)

                        If b.tipo = modestru.tipo_losa Then  'es una losa, vamos a hacer que el grafico sea mass limpio

                            ' esto esta en coord. globales
                            punta.x = Xi + (Xf - Xi) / 2
                            punta.Y = Yi + (Yf - Yi) / 2
                            punta.z = Zi + (Zf - Zi) / 2

                            cola.x = punta.x - ppx * escrep
                            cola.y = punta.y - ppy * escrep
                            cola.z = punta.z - ppz * escrep

                            DibujarCargaPuntual2(punta, cola, ColorCarga)

                        Else
                            For laperra = 0 To l Step l / PasoAjustado

                                punta.x = Xi + (Xf - Xi) * laperra / l
                                punta.Y = Yi + (Yf - Yi) * laperra / l
                                punta.z = Zi + (Zf - Zi) * laperra / l

                                ' posicion de la cola

                                'al ser cargas gravitatorias, no hay rotacion local ni nada, solo escala

                                cola.x = punta.x - ppx * escrep
                                cola.y = punta.y - ppy * escrep
                                cola.z = punta.z - ppz * escrep

                                DibujarCargaPuntual2(punta, cola, ColorCarga)

                                If laperra = l Then CargaCierre = True

                            Next

                            ' ' dibujo de nuevo la ultima parte, para el caso de que no la haya dibujado
                            If cargacierre = False Then
                                punta.x = Xf
                                punta.Y = Yf
                                punta.z = Zf

                                cola.x = punta.x - ppx * escrep
                                cola.y = punta.y - ppy * escrep
                                cola.z = punta.z - ppz * escrep

                                DibujarCargaPuntual2(punta, cola, ColorCarga)
                            End If
                            'y ahora la parte de cierre
                            punta.x = Xf - ppx * escrep
                            punta.Y = Yf - ppy * escrep
                            punta.z = Zf - ppz * escrep

                            cola.x = xi - ppx * escrep
                            cola.y = yi - ppy * escrep
                            cola.z = zi - ppz * escrep

                            linea(punta, cola, ColorCarga)
                        End If
                    Case 1 'carga puntual

                        ' punto de aplicacion de la carga

                        la = cb.a

                        ' esto esta en coord. globales
                        punta.x = Xi + (Xf - Xi) * la / l
                        punta.Y = Yi + (Yf - Yi) * la / l
                        punta.z = Zi + (Zf - Zi) * la / l

                        ' posicion de la cola

                        ' paso de coord de barra a  mundo
                        p1.x = la - escpun * ppx
                        p1.y = -escpun * ppy
                        p1.z = -escpun * ppz

                        Local3D(p1, cola)

                        cola.x += xi 'laperra - ppx
                        cola.y += yi
                        cola.z += zi

                        DibujarCargaPuntual2(punta, cola, Color.blue)

                    Case 2 ' carga repartida

                        If b.tipo = modestru.tipo_losa Then  'es una losa, vamos a hacer que el grafico sea mass limpio

                            ' esto esta en coord. globales
                            punta.x = Xi + (Xf - Xi) / 2
                            punta.Y = Yi + (Yf - Yi) / 2
                            punta.z = Zi + (Zf - Zi) / 2

                            ' posicion de la cola

                            p1.x = la - escpun * ppx
                            p1.y = -escpun * ppy
                            p1.z = -escpun * ppz

                            Local3D(p1, cola)

                            cola.x += xi 'laperra - ppx
                            cola.y += yi
                            cola.z += zi

                            DibujarCargaPuntual2(punta, cola, ColorCarga)
                        Else
                            For laperra = 0 To l Step l / PasoAjustado

                                punta.x = Xi + (Xf - Xi) * laperra / l
                                punta.Y = Yi + (Yf - Yi) * laperra / l   'la posicion en la barra
                                punta.z = Zi + (Zf - Zi) * laperra / l

                                ' posicion de la cola

                                p1.x = laperra - escrep * ppx
                                p1.y = -escrep * ppy
                                p1.z = -escrep * ppz

                                Local3D(p1, cola)

                                cola.x += xi 'laperra - ppx
                                cola.y += yi
                                cola.z += zi

                                DibujarCargaPuntual2(punta, cola, ColorCarga)

                                If laperra = l Then CargaCierre = True

                            Next

                            If cargacierre = False Then

                                ' dibujo de nuevo la ultima parte, para el caso de que no la haya dibujado
                                punta.x = Xf
                                punta.Y = Yf
                                punta.z = Zf
                                p1.x = l - escrep * ppx
                                p1.y = -escrep * ppy
                                p1.z = -escrep * ppz

                                Local3D(p1, cola)

                                cola.x += xi 'laperra - ppx
                                cola.y += yi
                                cola.z += zi

                                DibujarCargaPuntual2(punta, cola, ColorCarga)
                            End If

                            'y ahora la parte de cierre
                            p1.x = l - escrep * ppx
                            p1.y = -escrep * ppy
                            p1.z = -escrep * ppz

                            Local3D(p1, punta)
                            punta.x += xi 'laperra - ppx
                            punta.y += yi
                            punta.z += zi

                            p1.x = -escrep * ppx
                            p1.y = -escrep * ppy
                            p1.z = -escrep * ppz

                            Local3D(p1, cola)
                            cola.x += xi 'laperra - ppx
                            cola.y += yi
                            cola.z += zi

                            linea(punta, cola, ColorCarga)
                        End If

                    Case 3

                        For laperra = cb.a To cb.a + cb.b Step l / PasoAjustado
                            punta.x = Xi + (Xf - Xi) * laperra / l
                            punta.Y = Yi + (Yf - Yi) * laperra / l
                            punta.z = Zi + (Zf - Zi) * laperra / l

                            ' posicion de la cola
                            p1.x = laperra - escrep * ppx
                            p1.y = -escrep * ppy
                            p1.z = -escrep * ppz

                            Local3D(p1, cola)

                            cola.x += xi 'laperra - ppx
                            cola.y += yi
                            cola.z += zi
                            DibujarCargaPuntual2(punta, cola, ColorCarga)

                        Next
                        ' ultima flecha
                        punta.x = Xi + (Xf - Xi) * (cb.b + cb.a) / l
                        punta.Y = Yi + (Yf - Yi) * (cb.b + cb.a) / l
                        punta.z = Zi + (Zf - Zi) * (cb.b + cb.a) / l

                        ' posicion de la cola
                        p1.x = cb.a + cb.b - ppx * escrep - escrep * ppx
                        p1.y = -escrep * ppy
                        p1.z = -escrep * ppz

                        Local3D(p1, cola)

                        DibujarCargaPuntual2(punta, cola, ColorCarga)

                        p1.x = cb.a - ppx * escrep - escrep * ppx
                        p1.y = -escrep * ppy
                        p1.z = -escrep * ppz
                        Local3D(p1, punta) ' cb.a - ppx * escrep, - ppy * escrep, - ppz * escrep

                        p1.x = cb.a + cb.b - ppx * escrep - escrep * ppx
                        p1.y = -escrep * ppy
                        p1.z = -escrep * ppz
                        Local3D(p1, cola) ' cb.a + cb.b - ppx * escrep, - ppy * escrep, - ppz * escrep

                        linea(punta, cola, ColorCarga)

                    Case 4 ' temperatura

                        ' dibujo de nuevo la ultima parte, para el caso de que no la haya dibujado
                        p1.x = 0
                        p1.y = modestru.graficos.barra_corta / 10
                        p1.z = 0
                        Local3D(p1, punta)

                        p1.x = l
                        p1.y = modestru.graficos.barra_corta / 10
                        p1.z = 0
                        Local3D(p1, cola)

                        linea(punta, cola, ColorCarga)

                    Case 5 'triangulra

                        For laperra = 0 To l Step l / PasoAjustado

                            punta.x = Xi + (Xf - Xi) * laperra / l
                            punta.Y = Yi + (Yf - Yi) * laperra / l
                            punta.z = Zi + (Zf - Zi) * laperra / l
                            alfa = (l - laperra) / l

                            ' posicion de la cola
                            p1.x = laperra - ppx * escrep * alfa
                            p1.y = -ppy * escrep * alfa
                            p1.z = -ppz * escrep * alfa
                            Local3D(p1, cola)

                            dibujarcargapuntual2(punta, cola, ColorCarga)

                        Next

                        ' dibujo de nuevo la ultima parte, para el caso de que no la haya dibujado
                        punta.x = Xf
                        punta.Y = Yf
                        punta.z = Zf

                        'y ahora la parte de cierre

                        p1.x = -ppx * escrep * alfa
                        p1.y = -ppy * escrep * alfa
                        p1.z = -ppz * escrep * alfa
                        Local3D(p1, cola)

                        linea(punta, cola, ColorCarga)

                    Case 6 ' triangular invertida

                        For laperra = 0 To l Step l / PasoAjustado

                            punta.x = Xi + (Xf - Xi) * laperra / l
                            punta.Y = Yi + (Yf - Yi) * laperra / l
                            punta.z = Zi + (Zf - Zi) * laperra / l
                            alfa = laperra / l
                            ' posicion de la cola

                            p1.x = laperra - ppx * escrep * alfa
                            p1.y = -ppy * escrep * alfa
                            p1.z = -ppz * escrep * alfa
                            Local3D(p1, cola)

                            dibujarcargapuntual2(punta, cola, ColorCarga)

                        Next

                        ' dibujo de nuevo la ultima parte, para el caso de que no la haya dibujado
                        punta.x = Xi + (Xf - Xi)
                        punta.Y = Yi + (Yf - Yi)
                        punta.z = Zi + (Zf - Zi)

                        ' posicion de la cola

                        p1.x = l - ppx * escrep
                        p1.y = -ppy * escrep
                        p1.z = -ppz * escrep
                        Local3D(p1, cola)

                        dibujarcargapuntual2(punta, cola, ColorCarga)

                        punta.x = Xi
                        punta.Y = Yi
                        punta.z = Zi

                        'y ahora la parte de cierre
                        ' posicion de la cola
                        p1.x = l - ppx * escrep
                        p1.y = -ppy * escrep
                        p1.z = -ppz * escrep
                        Local3D(p1, cola)

                        linea(punta, cola, ColorCarga)

                End Select

            End If
        Next
    Next

End Sub

Public Sub DibujarEsfuerzos(esf As Integer)

    ' veamos
    Dim p0 As New Punto3d, p As New Punto3d
    Dim p00 As New Punto3d

    Dim p0q As New Punto3d
    Dim p00q As New Punto3d

    Dim p0n As New Punto3d
    Dim p00n As New Punto3d

    Dim p0t As New Punto3d
    Dim p00t As New Punto3d

    Dim p0qz As New Punto3d
    Dim p00qz As New Punto3d

    Dim p0my As New Punto3d
    Dim p00my As New Punto3d

    Dim Pni As New Punto3d
    Dim Pnf As New Punto3d, l As Float
    Dim d As New Punto3d, Pd As New Punto3d, tramo As Integer
    Dim px As Float, paso As Single
    Dim mmm As Single

    Dim PasoEsfAjustado As Integer
    Dim esfVal As Float

    For Each bar As ClsBarra In modestru.barra '  = 1 To modestru.datos.totalbarras

        If modestru.FiltroBarra(bar, IIf(modestru.graficos.FiltroSector > 0, modestru.graficos.FiltroSector, -1),, IIf(modestru.graficos.FiltroTipo > 0, modestru.graficos.FiltroTipo, -1)) And (bar.tipo <> modestru.tipo_losa) Then

            modUtils.DoEvents
            'If LocalInstance <> DrawingInstance Then Return
            'If WheelInstance <> fmain.mouWheel Then Break

            ' determino lo comun
            l = modestru.longitud(bar)
            Pni = modestru.nudo[bar.ni].xyz

            Pnf = modestru.nudo[bar.nF].xyz

            'optimizo
            PasoEsfAjustado = GetPixelsLenght(bar) / 10  ' dibujo cada 10 pixels

            If PasoEsfAjustado > modestru.setting.PasoEsf Then PasoEsfAjustado = modestru.setting.PasoEsf

            If PasoEsfAjustado < 3 Then PasoEsfAjustado = 3
            ' eso era antes
            paso = modestru.setting.PasoCalcularEsfuerzos / PasoEsfAjustado

            d.x = (Pnf.x - pni.x) / PasoEsfAjustado
            d.y = (Pnf.y - pni.y) / PasoEsfAjustado
            d.z = (Pnf.z - pni.z) / PasoEsfAjustado

            px = l / paso

            copy3d(p0, pni)

            copy3d(p0q, p0)

            copy3d(p0n, p0)

            copy3d(p0my, p0)
            copy3d(p0qz, p0)
            copy3d(p0t, p0)

            SetLocalMatrix(modestru.nudo[bar.ni].xyz, modestru.nudo[bar.nf].xyz)

            ' ajusto las escalas de Mz y My

            If modestru.graficos.Mz And modestru.graficos.mz Then modestru.graficos.ESCmy = modestru.graficos.ESCmz

            For tramo = 0 To PasoEsfAjustado

                mmm = tramo * paso
                If mmm > modestru.setting.PasoCalcularEsfuerzos Then mmm = modestru.setting.PasoCalcularEsfuerzos

                p0.x = pni.x + d.x * tramo
                p0.Y = pni.y + d.y * tramo 'el punto en la barra
                p0.z = pni.z + d.z * tramo

                If esf = Mz Then ' dibujo el momento flector mz
                    ' determino los maximos

                    esfVal = modCalculus.GetEsfP(bar, l * tramo / PasoEsfAjustado, Mz)

                    pd.x = 0
                    ' pongo en negativo, porque m+ se representa abajo

                    pd.y = -modestru.graficos.escala_esf * modestru.graficos.ESCmz * esfVal

                    pd.z = 0

                    Local3D(pd, p)

                    'If tramo > PasoEsfAjustado / 2 Then Stop
                    p.x += p0.x
                    p.Y += p0.y   ' el punto en el aire
                    p.z += p0.z

                    'On Error Resume Next

                    ScaleColorRGB(esfVal, modestru.graficos.maxMz)

                    linea(p0, p)
                    If tramo <> 0 Then

                        linea(p00, p)

                    End If

                    copy3d(p00, p)

                End If

                If esf = Qy Then  ' dibujo el corte
                    ' determino los maximos

                    pd.x = 0
                    pd.y = -modestru.graficos.escala_esf * modestru.graficos.ESCqy * modCalculus.GetEsfP(bar, l * tramo / PasoEsfAjustado, Qy)
                    pd.z = 0

                    If bar.Invertida Then pd.y = -pd.Y

                    Local3D(pd, p)

                    p.x += p0.x
                    p.Y += p0.y   ' el punto en el aire
                    p.z += p0.z

                    linea(p0, p, modestru.graficos.colores.Qy)
                    If tramo <> 0 Then
                        linea(p00q, p, modestru.graficos.colores.Qy)

                    End If
                    copy3d(p00q, p)

                End If

                If esf = N Then  ' dibujo el normal

                    pd.x = 0
                    pd.y = -modestru.graficos.escala_esf * modestru.graficos.ESCn * modCalculus.GetEsfP(bar, l * tramo / PasoEsfAjustado, n)
                    pd.z = 0

                    If bar.Invertida Then pd.y = -pd.Y

                    Local3D(pd, p)

                    p.x += p0.x
                    p.Y += p0.y   ' el punto en el aire
                    p.z += p0.z

                    'On Error Resume Next
                    linea(p0, p, modestru.graficos.colores.n)
                    If tramo <> 0 Then
                        linea(p00n, p, modestru.graficos.colores.n)

                    End If
                    copy3d(p00n, p)

                End If
                If esf = My Then ' dibujo el momento flector my
                    ' determino los maximos

                    pd.x = 0
                    pd.y = 0
                    pd.z = modestru.graficos.escala_esf * modestru.graficos.ESCmy * modCalculus.GetEsfP(bar, l * tramo / PasoEsfAjustado, My)

                    '
                    Local3D(pd, p)

                    p.x += p0.x
                    p.Y += p0.y   ' el punto en el aire
                    p.z += p0.z

                    linea(p0, p, modestru.graficos.colores.My)
                    If tramo <> 0 Then
                        linea(p00my, p, modestru.graficos.colores.My)
                        'p00 = p
                    End If

                    copy3d(p00my, p)
                    'On Error Goto 0
                End If

                If esf = Qz Then  ' dibujo el corte
                    ' determino los maximos

                    pd.x = 0
                    pd.y = 0
                    pd.z = -modestru.graficos.escala_esf * modestru.graficos.ESCqz * modCalculus.GetEsfP(bar, l * tramo / PasoEsfAjustado, Qz)

                    If bar.Invertida Then pd.z = -pd.z

                    ' ' pongo en negativo, porque m+ se representa abajo
                    '
                    Local3D(pd, p)

                    p.x += p0.x
                    p.Y += p0.y   ' el punto en el aire
                    p.z += p0.z

                    linea(p0, p, modestru.graficos.colores.qz)
                    If tramo <> 0 Then
                        linea(p00qz, p, modestru.graficos.colores.qz)

                    End If

                    copy3d(p00qz, p)
                    'On Error Goto 0
                End If

                If esf = T Then  ' dibujo el normal
                    ' determino los maximos
                    pd.x = 0
                    pd.y = 0
                    pd.z = -modestru.graficos.escala_esf * modestru.graficos.ESCt * modCalculus.GetEsfP(bar, l * tramo / PasoEsfAjustado, t)

                    If bar.Invertida Then pd.z = -pd.z

                    '
                    Local3D(pd, p)

                    p.x += p0.x
                    p.Y += p0.y   ' el punto en el aire
                    p.z += p0.z

                    linea(p0, p, modestru.graficos.colores.t)
                    If tramo <> 0 Then
                        linea(p00t, p, modestru.graficos.colores.t)

                    End If
                    copy3d(p00t, p)

                    'On Error Goto 0
                End If

            Next
            'Break
        End If ' filtro de barras
    Next

End Sub

Public Sub dibujar_esfuerzos_env_pos()

    ' veamos
    Dim p0 As New Punto3d, p As New Punto3d
    Dim p00 As New Punto3d

    Dim p0q As New Punto3d
    Dim p00q As New Punto3d

    Dim p0n As New Punto3d
    Dim p00n As New Punto3d

    Dim p0t As New Punto3d
    Dim p00t As New Punto3d

    Dim p0qz As New Punto3d
    Dim p00qz As New Punto3d

    Dim p0my As New Punto3d
    Dim p00my As New Punto3d

    Dim Pni As New Punto3d
    Dim Pnf As New Punto3d, l As Float
    Dim d As New Punto3d, Pd As New Punto3d, tramo As Integer
    Dim px As Float, paso As Single
    Dim b As Integer, mmm As Single
    Dim PasoEsfAjustado As Integer

    For Each bar As ClsBarra In modestru.barra
        modUtils.DoEvents

        ' determino lo comun
        l = modestru.longitud(b)
        Pni.x = modestru.nudo[bar.ni].x
        Pni.y = modestru.nudo[bar.ni].y
        Pni.z = modestru.nudo[bar.ni].z

        Pnf.x = modestru.nudo[bar.nF].x
        Pnf.y = modestru.nudo[bar.nF].y
        Pnf.z = modestru.nudo[bar.nF].z

        'optimizo
        PasoEsfAjustado = GetPixelsLenght(b) / 10  ' dibujo cada 10 pixels

        If PasoEsfAjustado > modestru.setting.PasoEsf Then PasoEsfAjustado = modestru.setting.PasoEsf

        If PasoEsfAjustado < 3 Then PasoEsfAjustado = 3
        ' eso era antes
        paso = modestru.setting.PasoCalcularEsfuerzos / PasoEsfAjustado

        d.x = (Pnf.x - pni.x) / PasoEsfAjustado
        d.y = (Pnf.y - pni.y) / PasoEsfAjustado
        d.z = (Pnf.z - pni.z) / PasoEsfAjustado

        px = l / paso

        copy3d(p0, pni)

        copy3d(p0q, p0)

        copy3d(p0n, p0)

        copy3d(p0my, p0)
        copy3d(p0qz, p0)
        copy3d(p0t, p0)

        SetLocalMatrix(pni, pnf)
        ' ajusto las escalas de Mz y My

        If modestru.graficos.Mz And modestru.graficos.mz Then modestru.graficos.ESCmy = modestru.graficos.ESCmz

        For tramo = 0 To PasoEsfAjustado
            If QuitDrawing Then
                Debug "Sali de esfuerzos"
                Return
            Endif

            mmm = tramo * paso

            If mmm > modestru.setting.PasoCalcularEsfuerzos Then mmm = modestru.setting.PasoCalcularEsfuerzos

            p0.x = pni.x + d.x * tramo
            p0.Y = pni.y + d.y * tramo 'el punto en la barra
            p0.z = pni.z + d.z * tramo

            If modestru.graficos.Mz Then ' dibujo el momento flector mz
                ' determino los maximos

                pd.x = 0
                ' pongo en negativo, porque m+ se representa abajo
                'pd.y = - modestru.graficos.escala_esf * modestru.graficos.ESCmz * modEstru.EsfSecPos(b, mmm, Mz)
                pd.y = -modestru.graficos.escala_esf * modestru.graficos.ESCmz * modCalculus.GetEsfPos(b, l * tramo / PasoEsfAjustado, Mz)

                pd.z = 0

                Local3D(pd, p)

                'If tramo > modestru.setting.PasoEsf / 2 Then Stop
                p.x += p0.x
                p.Y += p0.y   ' el punto en el aire
                p.z += p0.z

                linea(p0, p, modestru.graficos.colores.Mz)
                If tramo <> 0 Then

                    linea(p00, p, modestru.graficos.colores.Mz)

                End If

                copy3d(p00, p)

            End If

            If modestru.graficos.Qy Then  ' dibujo el corte
                ' determino los maximos

                pd.x = 0
                'pd.y = - modestru.graficos.escala_esf * modestru.graficos.ESCqy * modestru.EsfSecPos(b, mmm, Qy)
                pd.y = -modestru.graficos.escala_esf * modestru.graficos.ESCmz * modCalculus.GetEsfPos(b, l * tramo / PasoEsfAjustado, Qy)
                pd.z = 0

                If bar.Invertida Then pd.y = -pd.Y

                Local3D(pd, p)

                p.x += p0.x
                p.Y += p0.y   ' el punto en el aire
                p.z += p0.z

                linea(p0, p, modestru.graficos.colores.qy)
                If tramo <> 0 Then
                    linea(p00q, p, modestru.graficos.colores.qy)

                End If
                copy3d(p00q, p)

            End If

            If modestru.graficos.n Then  ' dibujo el normal

                pd.x = 0
                'pd.y = - modestru.graficos.escala_esf * modestru.graficos.ESCn * modestru.EsfSecPos(b, mmm, n)
                pd.y = -modestru.graficos.escala_esf * modestru.graficos.ESCmz * modCalculus.GetEsfPos(b, l * tramo / PasoEsfAjustado, N)
                pd.z = 0

                If bar.Invertida Then pd.y = -pd.Y

                Local3D(pd, p)

                p.x += p0.x
                p.Y += p0.y   ' el punto en el aire
                p.z += p0.z

                linea(p0, p, modestru.graficos.colores.n)
                If tramo <> 0 Then
                    linea(p00n, p, modestru.graficos.colores.n)

                End If
                copy3d(p00n, p)

            End If
            If modestru.graficos.My Then ' dibujo el momento flector my
                ' determino los maximos

                pd.x = 0
                pd.y = 0
                'pd.z = modestru.graficos.escala_esf * modestru.graficos.ESCmy * modestru.EsfSecPos(b, mmm, My)
                pd.z = modestru.graficos.escala_esf * modestru.graficos.ESCmz * modCalculus.GetEsfPos(b, l * tramo / PasoEsfAjustado, My)
                '
                Local3D(pd, p)

                p.x += p0.x
                p.Y += p0.y   ' el punto en el aire
                p.z += p0.z

                'On Error Resume Next
                linea(p0, p, modestru.graficos.colores.My)
                If tramo <> 0 Then
                    linea(p00my, p, modestru.graficos.colores.My)
                    'p00 = p
                End If

                copy3d(p00my, p)
                'On Error Goto 0
            End If

            If modestru.graficos.Qz Then  ' dibujo el corte
                ' determino los maximos

                pd.x = 0
                pd.y = 0
                'pd.z = - modestru.graficos.escala_esf * modestru.graficos.ESCqz * modestru.EsfSecPos(b, mmm, Qz)
                pd.z = -modestru.graficos.escala_esf * modestru.graficos.ESCmz * modCalculus.GetEsfPos(b, l * tramo / PasoEsfAjustado, Qz)
                ' ' pongo en negativo, porque m+ se representa abajo

                If bar.Invertida Then pd.z = -pd.z
                '
                Local3D(pd, p)

                p.x += p0.x
                p.Y += p0.y   ' el punto en el aire
                p.z += p0.z

                'On Error Resume Next
                linea(p0, p, modestru.graficos.colores.qz)
                If tramo <> 0 Then
                    linea(p00qz, p, modestru.graficos.colores.qz)

                End If

                copy3d(p00qz, p)
                'On Error Goto 0
            End If

            If modestru.graficos.t Then  ' dibujo el normal
                ' determino los maximos
                pd.x = 0
                pd.y = 0
                'pd.z = - modestru.graficos.escala_esf * modestru.graficos.ESCt * modestru.EsfSecPos(b, mmm, t)
                pd.z = -modestru.graficos.escala_esf * modestru.graficos.ESCmz * modCalculus.GetEsfPos(b, l * tramo / PasoEsfAjustado, T)

                If bar.Invertida Then pd.z = -pd.z
                '
                Local3D(pd, p)

                p.x += p0.x
                p.Y += p0.y   ' el punto en el aire
                p.z += p0.z

                linea(p0, p, modestru.graficos.colores.t)
                If tramo <> 0 Then
                    linea(p00t, p, modestru.graficos.colores.t)

                End If
                copy3d(p00t, p)

                'On Error Goto 0
            End If

        Next
        'Break
    Next

End Sub

Public Sub dibujar_esfuerzos_env_neg()
    ' veamos

    Dim p0 As New Punto3d, p As New Punto3d
    Dim p00 As New Punto3d

    Dim p0q As New Punto3d
    Dim p00q As New Punto3d

    Dim p0n As New Punto3d
    Dim p00n As New Punto3d

    Dim p0t As New Punto3d
    Dim p00t As New Punto3d

    Dim p0qz As New Punto3d
    Dim p00qz As New Punto3d

    Dim p0my As New Punto3d
    Dim p00my As New Punto3d

    Dim Pni As New Punto3d
    Dim Pnf As New Punto3d, l As Float
    Dim d As New Punto3d, Pd As New Punto3d, tramo As Integer
    Dim px As Float, paso As Single
    Dim b As Integer, mmm As Single
    Dim PasoEsfAjustado As Integer

    For Each bar As ClsBarra In modestru.barra
        modUtils.DoEvents
        ' determino lo comun
        l = modestru.longitud(bar)
        Pni.x = modestru.nudo[bar.ni].x
        Pni.y = modestru.nudo[bar.ni].y
        Pni.z = modestru.nudo[bar.ni].z

        Pnf.x = modestru.nudo[bar.nF].x
        Pnf.y = modestru.nudo[bar.nF].y
        Pnf.z = modestru.nudo[bar.nF].z

        'optimizo
        PasoEsfAjustado = GetPixelsLenght(bar) / 10  ' dibujo cada 10 pixels

        If PasoEsfAjustado > modestru.setting.PasoEsf Then PasoEsfAjustado = modestru.setting.PasoEsf

        If PasoEsfAjustado < 3 Then PasoEsfAjustado = 3
        ' eso era antes
        paso = modestru.setting.PasoCalcularEsfuerzos / PasoEsfAjustado

        d.x = (Pnf.x - pni.x) / PasoEsfAjustado
        d.y = (Pnf.y - pni.y) / PasoEsfAjustado
        d.z = (Pnf.z - pni.z) / PasoEsfAjustado

        px = l / paso

        copy3d(p0, pni)

        copy3d(p0q, p0)

        copy3d(p0n, p0)

        copy3d(p0my, p0)
        copy3d(p0qz, p0)
        copy3d(p0t, p0)

        SetLocalMatrix(pni, pnf)

        ' ajusto las escalas de Mz y My

        If modestru.graficos.Mz And modestru.graficos.mz Then modestru.graficos.ESCmy = modestru.graficos.ESCmz

        For tramo = 0 To PasoEsfAjustado
            If QuitDrawing Then
                Debug "Sali de esfuerzos"
                Return
            Endif

            mmm = tramo * paso
            If mmm > modestru.setting.PasoCalcularEsfuerzos Then mmm = modestru.setting.PasoCalcularEsfuerzos

            p0.x = pni.x + d.x * tramo
            p0.Y = pni.y + d.y * tramo 'el punto en la barra
            p0.z = pni.z + d.z * tramo

            If modestru.graficos.Mz Then ' dibujo el momento flector mz
                ' determino los maximos

                pd.x = 0
                ' pongo en negativo, porque m+ se representa abajo
                'pd.y = - modestru.graficos.escala_esf * modestru.graficos.ESCmz * modEstru.EsfSecNeg(b, mmm, Mz)
                pd.y = -modestru.graficos.escala_esf * modestru.graficos.ESCmz * modCalculus.GetEsfNeg(b, l * tramo / PasoEsfAjustado, Mz)
                pd.z = 0

                Local3D(pd, p)

                'If tramo > modestru.setting.PasoEsf / 2 Then Stop
                p.x += p0.x
                p.Y += p0.y   ' el punto en el aire
                p.z += p0.z

                linea(p0, p, modestru.graficos.colores.Mz)
                If tramo <> 0 Then

                    linea(p00, p, modestru.graficos.colores.Mz)

                End If

                copy3d(p00, p)

            End If

            If modestru.graficos.Qy Then  ' dibujo el corte
                ' determino los maximos

                pd.x = 0
                'pd.y = - modestru.graficos.escala_esf * modestru.graficos.ESCqy * modestru.EsfSecNeg(b, mmm, Qy)
                pd.y = -modestru.graficos.escala_esf * modestru.graficos.ESCmz * modCalculus.GetEsfNeg(b, l * tramo / PasoEsfAjustado, Qy)
                pd.z = 0

                If bar.Invertida Then pd.y = -pd.Y

                Local3D(pd, p)

                p.x += p0.x
                p.Y += p0.y   ' el punto en el aire
                p.z += p0.z

                linea(p0, p, modestru.graficos.colores.qy)
                If tramo <> 0 Then
                    linea(p00q, p, modestru.graficos.colores.qy)

                End If
                copy3d(p00q, p)

            End If

            If modestru.graficos.n Then  ' dibujo el normal

                pd.x = 0
                'pd.y = - modestru.graficos.escala_esf * modestru.graficos.ESCn * modestru.EsfSecNeg(b, mmm, n)
                pd.y = -modestru.graficos.escala_esf * modestru.graficos.ESCmz * modCalculus.GetEsfNeg(b, l * tramo / PasoEsfAjustado, N)
                pd.z = 0

                If bar.Invertida Then pd.y = -pd.Y

                Local3D(pd, p)

                p.x += p0.x
                p.Y += p0.y   ' el punto en el aire
                p.z += p0.z

                'On Error Resume Next
                linea(p0, p, modestru.graficos.colores.n)
                If tramo <> 0 Then
                    linea(p00n, p, modestru.graficos.colores.n)

                End If
                copy3d(p00n, p)

            End If
            If modestru.graficos.My Then ' dibujo el momento flector my
                ' determino los maximos

                pd.x = 0
                pd.y = 0
                'pd.z = modestru.graficos.escala_esf * modestru.graficos.ESCmy * modestru.EsfSecNeg(b, mmm, My)
                pd.z = modestru.graficos.escala_esf * modestru.graficos.ESCmz * modCalculus.GetEsfNeg(b, l * tramo / PasoEsfAjustado, My)

                '
                Local3D(pd, p)

                p.x += p0.x
                p.Y += p0.y   ' el punto en el aire
                p.z += p0.z

                'On Error Resume Next
                linea(p0, p, modestru.graficos.colores.my)
                If tramo <> 0 Then
                    linea(p00my, p, modestru.graficos.colores.My)
                    'p00 = p
                End If

                copy3d(p00my, p)
                'On Error Goto 0
            End If

            If modestru.graficos.Qz Then  ' dibujo el corte
                ' determino los maximos

                pd.x = 0
                pd.y = 0
                'pd.z = - modestru.graficos.escala_esf * modestru.graficos.ESCqz * modestru.EsfSecNeg(b, mmm, Qz)
                pd.z = -modestru.graficos.escala_esf * modestru.graficos.ESCmz * modCalculus.GetEsfNeg(b, l * tramo / PasoEsfAjustado, Qz)
                ' ' pongo en negativo, porque m+ se representa abajo

                If bar.Invertida Then pd.z = -pd.z
                '
                Local3D(pd, p)

                p.x += p0.x
                p.Y += p0.y   ' el punto en el aire
                p.z += p0.z

                'On Error Resume Next
                linea(p0, p, modestru.graficos.colores.qz)
                If tramo <> 0 Then
                    linea(p00qz, p, modestru.graficos.colores.qz)

                End If

                copy3d(p00qz, p)
                'On Error Goto 0
            End If

            If modestru.graficos.t Then  ' dibujo el normal
                ' determino los maximos
                pd.x = 0
                pd.y = 0
                'pd.z = - modestru.graficos.escala_esf * modestru.graficos.ESCt * modestru.EsfSecNeg(b, mmm, t)
                pd.z = -modestru.graficos.escala_esf * modestru.graficos.ESCmz * modCalculus.GetEsfNeg(b, l * tramo / PasoEsfAjustado, T)

                If bar.Invertida Then pd.z = -pd.z

                Local3D(pd, p)

                p.x += p0.x
                p.Y += p0.y   ' el punto en el aire
                p.z += p0.z

                linea(p0, p, modestru.graficos.colores.t)
                If tramo <> 0 Then
                    linea(p00t, p, modestru.graficos.colores.t)

                End If
                copy3d(p00t, p)

                'On Error Goto 0
            End If

        Next
        'Break
    Next

End Sub

Public Sub GetExtents()
    ' Obtengo los limites reales de la estructura,

    Dim a As Long

    extents.MinX = 0
    extents.MinY = 0
    extents.MinZ = 0

    extents.maxX = 0
    extents.MaxY = 0
    extents.MaxZ = 0

    If modestru.nudo.max = 0 Then Return
    ' veo deonde esa ubicada la estructura segun ejes globales
    For a = 1 To modestru.nudo.max
        ' maximos
        If modestru.nudo[a].x > extents.maxX Then extents.maxX = modestru.nudo[a].x
        If modestru.nudo[a].y > extents.MaxY Then extents.MaxY = modestru.nudo[a].y
        If modestru.nudo[a].z > extents.MaxZ Then extents.MaxZ = modestru.nudo[a].z

        ' minimos
        If modestru.nudo[a].x < extents.MinX Then extents.MinX = modestru.nudo[a].x
        If modestru.nudo[a].y < extents.MinY Then extents.MinY = modestru.nudo[a].y
        If modestru.nudo[a].z < extents.MinZ Then extents.MinZ = modestru.nudo[a].z
    Next

    ' es para el preview

End Sub

Public Sub DibujarNudo(a As Integer, colo As Long)

    Dim q As String, paux As New Punto3d

    q = Format$(a, "0")

    paux.x = modestru.nudo[a].x
    paux.Y = modestru.nudo[a].y
    paux.z = modestru.nudo[a].z

    txtRendering2D(q, paux,, Colo, Color.LightGray, 2, 2)

End Sub

Public Function GetRectangulo(x0 As Single, y0 As Single, x1 As Single, y1 As Single, Optional modo As Integer) As Boolean
    ' modo:
    '   0 (default)=lleno
    '   1   =   rayado
    '   2   =   idem CAD (punteado a la izq y lleno a la der)

    'x0<x1 , y0<y1 , true si completo, false si cancelo

    Dim a As Single

    If modestru.rectangulo.Activo = True Then ' no puede haber 2
        Stop
        Return 0
    End If

    modestru.rectangulo.FirstPoint = False
    modestru.rectangulo.SecondPoint = False
    modestru.rectangulo.Activo = True
    modestru.rectangulo.Completado = False

    If modo <> Null Then
        modestru.rectangulo.modo = 0
    Else If modo >= 0 And modo <= 7 Then
        modestru.rectangulo.modo = modo
    Else
        modestru.rectangulo.modo = 0
    End If

    Do  ' espero hasta el segundo punto o que se cancele

        modUtils.DoEvents
    Loop Until Not modestru.rectangulo.Activo

    If Not modestru.rectangulo.Completado Then Return 0  ' devuelvo false, rectangulo no finalizado

    'primero corrijo los valores
    If (modestru.rectangulo.x0 > modestru.rectangulo.x1) Then

        a = modestru.rectangulo.x1
        modestru.rectangulo.x1 = modestru.rectangulo.x0
        modestru.rectangulo.x0 = a
    End If
    If (modestru.rectangulo.y0 > modestru.rectangulo.y1) Then
        a = modestru.rectangulo.y1
        modestru.rectangulo.y1 = modestru.rectangulo.y0
        modestru.rectangulo.y0 = a

    End If
    x0 = modestru.rectangulo.x0
    x1 = modestru.rectangulo.x1
    y0 = modestru.rectangulo.y0
    y1 = modestru.rectangulo.y1

    Return True

End Function

Public Sub linea(p0 As Punto3d, p1 As Punto3d, Optional _color As Integer = -10001, Optional ancho As Single = 1)

    ' Esta es una rutina 3D, tanto para Draw, Paint y OpenGL

    ' 2020 tambien para VR

    ' TODO arreglar esto del -10001

    If _color <> -10001 Then glColorRGB(_color)

    gl.LineWidth(ancho) ' obsoleto en WebGL

    gl.Begin(gl.lines)

    gl.Vertex3f(p0.x, p0.y, p0.z)
    gl.Vertex3f(p1.x, p1.y, p1.z)

    gl.End

    If doVR Then
        ' intento escribir
        ' Dibujo lineas

        ' Create a blue LineBasicMaterial
        ' After material we will need a geometry With some vertices:
        Print #fileLines, "," & Format$(p0.x, "0.00") & "," & Format$(p0.y, "0.00") & "," & Format$(p0.z, "0.00") & "," & Format$(p1.x, "0.00") & "," & Format$(p1.y, "0.00") & "," & Format$(p1.z, "0.00")
        'Print #fileVR, "points.push( new THREE.Vector3( " & Format$(p1.x, "0.00") & "," & Format$(p1.y, "0.00") & "," & Format$(p1.z, "0.00") & " ) );"

        Dim r As Float, g As Float, b As Float

        'If gbcolor > 0 Then Stop
        r = (Shr(_Color, 16) And 255) / 256
        g = (Shr(_Color, 8) And 255) / 256
        b = (_Color And 255) / 256
        Print #fileColors, "," & Format$(r, "0") & "," & Format$(g, "0.00") & "," & Format$(b, "0.00") & "," & Format$(r, "0") & "," & Format$(g, "0.00") & "," & Format$(b, "0.00")

    Endif

End

Public Sub circulo(centro As Punto3d, eje As Punto3d, radio As Float, Optional _color As Single = -1, Optional lleno As Boolean = -1)

    ' Esta es una rutina 3D, tanto para Draw, Paint y OpenGL
    Dim r As Float, g As Integer, b As Integer
    Dim p As New Punto3d
    Dim paso As Integer = 9
    Dim p2 As New Punto3d, p1 As New Punto3d
    Dim py As Float

    'radio3.x = centro.x + centro.x - radio1.x
    'radio3.y = centro.y + centro.y - radio1.y
    'radio3.z = centro.z + centro.z - radio1.z

    SetLocalMatrix(centro, eje)
    If _color > 0 Then glcolorRGB(_color)

    ' la idea es diibujar un circulo en el espacio
    p2.x = 0 'centro.x
    p2.y = 0 'radio
    p2.z = radio

    Local3D(p2, p1)

    p1.x += centro.x
    p1.y += centro.Y
    p1.z += centro.z

    For r = paso / 360 * 6.28 To 6.28 Step paso / 360 * 6.28
        p2.x = 0 ' centro.x
        p2.y = radio * Sin(r)
        p2.z = radio * Cos(r)

        Local3D(p2, p)

        p.x += centro.x
        p.y += centro.Y
        p.z += centro.z

        'Vertex3D(p) ' modMotor3D.xyzX3D(p), modMotor3D.xyzY3D(p))
        linea(p, p1)
        copy3d(p1, p)

    Next

End

' Public Sub SetColor(rojo_o_colorRGB As Integer, Optional G As Single = -1, Optional B As Single = -1, Optional transparencia As Integer = 0)
'
'     Dim R As Single
'     ' determino el color que voy a utilizar para los proximos dibujos
'     '
'     ' acepta el color de gambas, ej:  color.red
'     ' y tambien el formato red, green, blue
'     ' ademas se puede indicar la trasparencia
'     If g = -1 Then '
'
'         ' no tengo los otros colores
'         r = (Shr(rojo_o_colorRGB, 16) And 255) / 256
'         g = (Shr(rojo_o_colorRGB, 8) And 255) / 256
'         b = (rojo_o_colorRGB And 255) / 256
'
'     End If
'
'
'
'    glcolorRGB Color.SetAlpha(rojo_o_colorRGB, transparencia)
'
'
'
' End

' Public Function RBG(red As Single, green As Single, blue As Single) As Long
'
'     'convierte los colores
'     ' van de 0.0 a 1.0
'
'     Dim l As Long
'
'     l = 0
'     Try l = blue * 256 + green * 256 * 256 + red * 256 * 256 * 256
'     Return l
'
' End

Public Sub Copy3D(Destino As Punto3d, Origen As Punto3d)
    ' copia el punto 3D

    Destino.x = Origen.x
    Destino.y = Origen.y
    Destino.z = Origen.z

End

Public Sub Add3D(Destino As Punto3d, Origen As Punto3d)
    ' suma las coordenadas de destino a origen

    Destino.x += Origen.x
    Destino.y += Origen.y
    Destino.z += Origen.z

End

Public Sub GetCG()

    'determina el centro de gravedad de una coleccion de puntos 3d
    ' copia el punto 3D
    Dim p As Integer '´ Modestru.Nudotype4

    If modestru.nudo.Count = 0 Then Return
    mundocg.x = 0
    mundocg.y = 0
    mundocg.z = 0

    For Each n As ClsNudo In modestru.nudo
        mundocg.x += n.x
        mundocg.y += n.y
        mundocg.z += n.z

    Next
    '
    mundoCG.x /= modestru.nudo.Count
    mundoCG.y /= modestru.nudo.Count
    mundocg.z /= modestru.nudo.Count

    cgX = mundocg.x
    cgY = mundocg.Y
    cgZ = mundocg.z

    'ademas envio a C

    'modLibMatrix8.setCG(cgx, cgy, cgz)

End

Sub DibujarRenderLosas()

    Dim a As Integer, bru As PaintBrush, pr2 As New Punto3d, pr1 As New Punto3d

    With modestru

        For a = 0 To .losas.Max
            ' Debug .losas[a].sector
            If ((.graficos.FiltroSector <= 0) Or (.graficos.FiltroSector = .losas[a].sector)) Then

                prisma1(.nudo[.losas[a].Nudo1], .nudo[.losas[a].Nudo2], .nudo[.losas[a].Nudo4], .nudo[.losas[a].Nudo3], .losas[a].d,, True)
            End If
        Next

    End With

End

Sub DibujarLosas()

    Dim a As Integer, bru As PaintBrush, pr2 As New Punto3d, pr1 As New Punto3d, pr3 As New Punto3d, pr4 As New Punto3d

    With modestru

        gl.NewList(glListaLosas, gl.COMPILE)

        glcolorRGB(Color.LightGray, 0.55)
        '

        For a = 0 To .losas.Max

            If (.graficos.FiltroSector <= 0) Or (.losas[a].sector = .graficos.FiltroSector) Then

                GLQuadColor4f(.nudo[.losas[a].Nudo1], .nudo[.losas[a].Nudo2], .nudo[.losas[a].Nudo4], .nudo[.losas[a].Nudo3])

            End If

        Next

        For a = 0 To .Tabiques.Max

            If .graficos.FiltroSector > 0 And .Tabiques[a].sector = .graficos.FiltroSector Then

                GLQuadColor4f(.nudo[.tabiques[a].Nudo1], .nudo[.tabiques[a].Nudo2], .nudo[.tabiques[a].Nudo4], .nudo[.tabiques[a].Nudo3])

            End If
        Next
        gl.EndList

    End With

End

Sub dibujar_numero_losas()

    Dim a As Integer, bru As PaintBrush, eje As New Punto3d
    Dim centro As New Punto3d
    Dim p1 As New Punto3d
    Dim p2 As New Punto3d
    Dim p3 As New Punto3d
    Dim p4 As New Punto3d

    Dim radio As Float

    For a = 0 To modestru.losas.Max
        If ((modestru.graficos.FiltroSector <= 0) Or (modestru.graficos.FiltroSector = modestru.losas[a].sector)) Then

            p1.x = modestru.nudo[modestru.losas[a].Nudo1].x
            p1.y = modestru.nudo[modestru.losas[a].Nudo1].y
            p1.z = modestru.nudo[modestru.losas[a].Nudo1].z

            p2.x = modestru.nudo[modestru.losas[a].Nudo2].x
            p2.y = modestru.nudo[modestru.losas[a].Nudo2].y
            p2.z = modestru.nudo[modestru.losas[a].Nudo2].z

            p3.x = modestru.nudo[modestru.losas[a].Nudo3].x
            p3.y = modestru.nudo[modestru.losas[a].Nudo3].y
            p3.z = modestru.nudo[modestru.losas[a].Nudo3].z

            p4.x = modestru.nudo[modestru.losas[a].Nudo4].x
            p4.y = modestru.nudo[modestru.losas[a].Nudo4].y
            p4.z = modestru.nudo[modestru.losas[a].Nudo4].z

            centro.x = (p4.x + p1.x) / 2
            centro.y = (p4.y + p1.y) / 2
            centro.z = (p4.z + p1.z) / 2

            radio = modAlgebra.Distancia(p1, centro) / 8

            ' necesito el eje del circulo
            ' para ello obtengo el producto Cross

            p1.x = centro.x - p1.x
            p1.y = centro.y - p1.y
            p1.z = centro.z - p1.z

            p3.x = centro.x - modestru.nudo[modestru.losas[a].Nudo3].x
            p3.y = centro.y - modestru.nudo[modestru.losas[a].Nudo3].y
            p3.z = centro.z - modestru.nudo[modestru.losas[a].Nudo3].z

            modAlgebra.Cross(p1, p3, eje)

            eje.x += centro.x
            eje.y += centro.Y
            eje.z += centro.z

            circulo(centro, eje, radio, Color.Black, False)

            txtRendering3D(Format$(modestru.losas[a].numero, "0") & "-" & Format$(modestru.losas[a].sector, "0"), centro, 12, Color.DarkBlue,, 2, 2)

        End If
    Next

End

Private Sub DibujarBarras()

    Dim p1 As New Punto3d, p2 As New Punto3d, p3 As New Punto3d
    Dim ni As Integer, nF As Integer, a As Integer, q As String
    Dim colore As Long

    gl.NewList(glListaEstructura, gl.COMPILE)

    For Each b As ClsBarra In modestru.barra
        p1 = modestru.nudo[b.ni].XYZ
        p2 = modestru.nudo[b.nF].xyz

        ' SetClipElement a, (x0 + x1) / 2, (y0 + y1) / 2, 2
        ' la dibujo?
        If b.tipo = 0 Then colore = Color.Black

        If (b.tipo = modestru.tipo_viga) Or (b.tipo = modestru.tipo_columna) Then colore = Color.DarkGray

        If (b.tipo = modestru.tipo_losa) Or (b.tipo = modestru.tipo_tabique) Then colore = Color.White

        If modestru.FiltroBarra(b, IIf(modestru.graficos.FiltroSector > 0, modestru.graficos.FiltroSector, -1),, IIf(modestru.graficos.FiltroTipo > 0, modestru.graficos.FiltroTipo, -1)) Then

            linea(p1, p2, Colore, 1)
        Endif

    Next
    gl.EndList

End Sub

Sub DibujarSubBarras()

    Dim p1 As New Punto3d, p2 As New Punto3d, p3 As New Punto3d
    Dim ni As Integer, nF As Integer, a As Integer, q As String

    gl.NewList(glListaSubBarras, gl.COMPILE)

    For Each b As ClsBarra In modestru.barra ' a = 1 To modestru.datos.totalbarras

        If modestru.FiltroBarra(b, IIf(modestru.graficos.FiltroSector > 0, modestru.graficos.FiltroSector, -1),, IIf(modestru.graficos.FiltroTipo > 0, modestru.graficos.FiltroTipo, -1)) Then

            If b.tipo = modestru.tipo_losa Then linea(modestru.nudo[b.ni].xyz, modestru.nudo[b.nF].xyz, Color.black, 1)
        End If
    Next
    gl.EndList

End Sub

Public Function GetPixelsLenght(b As ClsBarra) As Float

    'devuelve el largo de la barra en pixels, despues de escalar y rotar
    Dim p1 As New Punto3d, p2 As New Punto3d
    Dim n1 As Integer, n2 As Integer, l As Float

    '
    ' n1 = b.ni
    ' n2 = b.nF
    '
    ' p1.x = .nudo[n1].x
    ' p1.Y = .nudo[n1].Y
    ' p1.z = .nudo[n1].z
    ' p2.x = .nudo[n2].x
    ' p2.Y = .nudo[n2].Y
    ' p2.z = .nudo[n2].z

    l = modestru.longitud(b)

    Return l * escala * fmain.gestru.W

End

Public Sub Test()

    Dim a As Integer, ti As Date

    Dim p1 As New Punto3d, p2 As New Punto3d

    If modestru.nudo.max = 0 Then Return
    ti = Timer
    SetLocalMatrix(modestru.nudo[1], modestru.nudo[2])   ' this prepares the matrix
    p1.x = 1
    p1.y = 542
    p1.x = 465
    For a = 1 To 10000000

        Local3D(p1, p2)
    Next
    Debug Format$(Timer - ti, "0.0000")

End

Public Sub dibujar_barra_renderizada(b As ClsBarra, Optional textura As Integer = 0)

    Dim a1 As Float, a2 As Float, bru As PaintBrush, Paux As New Punto3d, Paux2 As New Punto3d
    Dim rellenar As Boolean, wire As Boolean
    Dim lon As Float
    Dim ni As String 'Integer 'el nudo inicial
    Dim nf As String 'Integer
    Dim p1i As New Punto3d
    Dim p2i As New Punto3d
    Dim p3i As New Punto3d
    Dim p4i As New Punto3d
    Dim p1f As New Punto3d
    Dim p2f As New Punto3d
    Dim p3f As New Punto3d
    Dim p4f As New Punto3d

    Dim fNormal As Float
    Dim fColor As Integer
    Dim bColor As Integer

    Dim imgTextura As Image

    rellenar = modestru.graficos.render
    wire = modestru.graficos.wireframe

    With modEstru

        If b.seleccionado Then bColor = .graficos.colores.seleccion Else bcolor = .graficos.colores.barras

        Gl.ShadeModel(Gl.SMOOTH)

        'intento cargar la textura en base al material de la barra
        If textura = 0 Then
            glMaterialHierro()
        Else If textura = 1 Then 'concreto
            'imgTextura = image.Load("concreto.jpg")
            glMaterialConcreto
        Else If textura = 2 Then 'concreto
            'imgTextura = image.Load("concreto.jpg")
            glMaterialMadera

        Endif

        ni = b.ni
        nf = b.nF

        lon = .longitud(b)

        a1 = .secciones[b.seccion].b
        a2 = .secciones[b.seccion].a

        SetLocalMatrix(.nudo[b.ni].xyz, .nudo[b.nf].xyz)

        Select Case .secciones[b.seccion].tipo
            Case "G-Rectangular", "G-Cuadrada", "G-Tubo rectangular"

                If a1 = 0 Then a1 = a2 'seccion cuadrada

                Paux.y = a1 / 2
                'Paux.y = 0
                Paux.z = -a2 / 2

                Local3D(Paux, p1i)
                Copy3D(p1f, p1i)
                Add3D(p1i, .nudo[ni].xyz)
                Add3D(p1f, .nudo[nf].xyz)

                Paux.y = a1 / 2
                'Paux.y = 0
                Paux.z = a2 / 2

                Local3D(Paux, p2i)
                Copy3D(p2f, p2i)
                Add3D(p2i, .nudo[ni].xyz)
                Add3D(p2f, .nudo[nf].xyz)

                Paux.y = -a1 / 2
                'Paux.y = 0
                Paux.z = a2 / 2

                Local3D(Paux, p3i)
                Copy3D(p3f, p3i)
                Add3D(p3i, .nudo[ni].xyz)
                Add3D(p3f, .nudo[nf].xyz)

                Paux.y = -a1 / 2
                'Paux.y = 0
                Paux.z = -a2 / 2

                Local3D(Paux, p4i)
                Copy3D(p4f, p4i)
                Add3D(p4i, .nudo[ni].xyz)
                Add3D(p4f, .nudo[nf].xyz)

                'cara 1
                ' determino el color del relleno en base a la direccion del normal a la cara
                ' cuanto mas apunta al user, mas clara
                ' si es negativo , apunta hacia la pantalla, sino, ni siquiera la muestro
                Paux.x = 0
                Paux.y = 1
                Paux.z = 0

                Local3D(Paux, Paux2)

                gl.Normal3f(paux2.x, paux2.y, paux2.z)

                GLQuadColor4f(p1i, p2i, p2f, p1f)

                '
                Paux.x = 0
                Paux.y = 0
                Paux.z = 1
                Local3D(Paux, Paux2)
                gl.Normal3f(paux2.x, paux2.y, paux2.z)

                GLQuadColor4f(p2i, p3i, p3f, p2f)

                '
                Paux.x = 0
                Paux.y = -1
                Paux.z = 0
                Local3D(Paux, Paux2)
                gl.Normal3f(paux2.x, paux2.y, paux2.z)

                GLQuadColor4f(p3i, p4i, p4f, p3f)

                Paux.x = 0
                Paux.y = 0
                Paux.z = -1
                Local3D(Paux, Paux2)
                gl.Normal3f(paux2.x, paux2.y, paux2.z)

                GLQuadColor4f(p4i, p1i, p1f, p4f)

                If b.tipo <> .tipo_viga Then

                    ' tapa inicial
                    Paux.x = -1
                    Paux.y = 0
                    Paux.z = 0
                    Local3D(Paux, Paux2)
                    gl.Normal3f(paux2.x, paux2.y, paux2.z)

                    GLQuadColor4f(p1i, p2i, p3i, p4i)

                    ' tapa final
                    Paux.x = 1
                    Paux.y = 0
                    Paux.z = 0
                    Local3D(Paux, Paux2)
                    gl.Normal3f(paux2.x, paux2.y, paux2.z)

                    GLQuadColor4f(p1f, p2f, p3f, p4f)

                End If

            Case "G-Circular", "G-Anular"

                cilindro(.nudo[ni], .nudo[nf], a2, 18, Color.Blue)

            Case "P-Perfil IPE", "P-Perfil IPB", "P-Perfil IPN"

                perfilTT(.nudo[ni], .nudo[nf], a2, a1, Color.blue)

            Case "P-Perfil L", "P-Perfil LD"

                perfilL(.nudo[ni], .nudo[nf], a2, a1, Color.blue)

        End Select
    End With

End Sub

Public Sub prisma2(c10 As Punto3d, c20 As Punto3d, b As Float, h As Float, Optional textura As Integer = 0, Optional bajar_nivel As Boolean = False)

    Dim a1 As Float, a2 As Float, bru As PaintBrush, Paux As New Punto3d, Paux2 As New Punto3d
    Dim rellenar As Boolean, wire As Boolean
    Dim lon As Float, mate As Integer
    Dim ni As Integer 'el nudo inicial
    Dim nf As Integer
    Dim p1i As New Punto3d
    Dim p2i As New Punto3d
    Dim p3i As New Punto3d
    Dim p4i As New Punto3d
    Dim p1f As New Punto3d
    Dim p2f As New Punto3d
    Dim p3f As New Punto3d
    Dim p4f As New Punto3d

    Dim fNormal As Float
    Dim fColor As Integer
    Dim bColor As Integer

    Dim c1 As New Punto3d

    Dim c2 As New Punto3d

    Dim imgTextura As New Image

    rellenar = modestru.graficos.render
    wire = modestru.graficos.wireframe

    With modEstru

        Gl.ShadeModel(Gl.SMOOTH)

        'intento cargar la textura en base al material de la barra
        If textura = 0 Then
            glMaterialHierro()
        Else If textura = 1 Then 'concreto
            'imgTextura = image.Load("concreto.jpg")
            glMaterialConcreto
        Else If textura = 2 Then 'concreto
            'imgTextura = image.Load("concreto.jpg")
            glMaterialMadera

        Endif

        copy3d(c1, c10)
        copy3d(c2, c20)

        a2 = b
        a1 = h
        If a1 = 0 Then a1 = a2 'seccion cuadrada

        If bajar_nivel Then

            c1.Y -= h / 2
            c2.Y -= h / 2
        Endif

        'lon = .longitud(b)

        SetLocalMatrix(c1, c2)

        Paux.y = a1 / 2
        'Paux.y = 0
        Paux.z = -a2 / 2

        Local3D(Paux, p1i)
        Copy3D(p1f, p1i)
        Add3D(p1i, c1)
        Add3D(p1f, c2)

        Paux.y = a1 / 2
        'Paux.y = 0
        Paux.z = a2 / 2

        Local3D(Paux, p2i)
        Copy3D(p2f, p2i)
        Add3D(p2i, c1)
        Add3D(p2f, c2)

        Paux.y = -a1 / 2
        'Paux.y = 0
        Paux.z = a2 / 2

        Local3D(Paux, p3i)
        Copy3D(p3f, p3i)
        Add3D(p3i, c1)
        Add3D(p3f, c2)

        Paux.y = -a1 / 2
        'Paux.y = 0
        Paux.z = -a2 / 2

        Local3D(Paux, p4i)
        Copy3D(p4f, p4i)
        Add3D(p4i, c1)
        Add3D(p4f, c2)

        'cara 1
        ' determino el color del relleno en base a la direccion del normal a la cara
        ' cuanto mas apunta al user, mas clara
        ' si es negativo , apunta hacia la pantalla, sino, ni siquiera la muestro
        Paux.x = 0
        Paux.y = 1
        Paux.z = 0

        Local3D(Paux, Paux2)

        Normal3D(paux2)

        GLQuadColor4f(p1i, p2i, p2f, p1f)

        'cara 2
        Paux.x = 0
        Paux.y = 0
        Paux.z = 1
        Local3D(Paux, Paux2)

        Normal3D(paux2)

        GLQuadColor4f(p2i, p3i, p3f, p2f)

        'cara 3
        Paux.x = 0
        Paux.y = -1
        Paux.z = 0
        Local3D(Paux, Paux2)

        Normal3D(paux2)

        GLQuadColor4f(p3i, p4i, p4f, p3f)

        'cara 4
        Paux.x = 0
        Paux.y = 0
        Paux.z = -1
        Local3D(Paux, Paux2)

        Normal3D(paux2)

        GLQuadColor4f(p4i, p1i, p1f, p4f)

        If .barra[b].tipo <> .tipo_viga Then

            ' tapa inicial

            Paux.x = -1
            Paux.y = 0
            Paux.z = 0
            Local3D(Paux, Paux2)

            Normal3D(paux2)
            GLQuadColor4f(p1i, p2i, p3i, p4i)

            ' tapa final
            Paux.x = 1
            Paux.y = 0
            Paux.z = 0
            Local3D(Paux, Paux2)

            Normal3D(paux2)

            GLQuadColor4f(p1f, p2f, p3f, p4f)

        End If

    End With

End Sub

Public Sub prisma1(c10 As Punto3d, c20 As Punto3d, c30 As Punto3d, c40 As Punto3d, d As Float, Optional _color As Integer, Optional bajar_nivel As Boolean = False)

    'dibuja un prima basado en una seccion en el medio, definida por los puntos c1 - c4, y altura d

    Dim a1 As Float, a2 As Float, bru As PaintBrush, Paux As New Punto3d, Paux2 As New Punto3d, Paux3 As New Punto3d
    Dim rellenar As Boolean, wire As Boolean
    Dim lon As Float
    Dim ni As Integer 'el nudo inicial
    Dim nf As Integer
    Dim p1i As New Punto3d
    Dim p2i As New Punto3d
    Dim p3i As New Punto3d
    Dim p4i As New Punto3d
    Dim p1f As New Punto3d
    Dim p2f As New Punto3d
    Dim p3f As New Punto3d
    Dim p4f As New Punto3d

    Dim c1 As New Punto3d
    Dim c2 As New Punto3d
    Dim c3 As New Punto3d
    Dim c4 As New Punto3d

    Dim fNormal As Float
    Dim fColor As Integer

    rellenar = modestru.graficos.render
    wire = modestru.graficos.wireframe

    copy3d(c1, c10)
    copy3d(c2, c20)
    copy3d(c3, c30)
    copy3d(c4, c40)

    If bajar_nivel Then

        c1.y -= d / 2
        c2.y -= d / 2
        c3.y -= d / 2
        c4.y -= d / 2

    Endif

    With modEstru

        Paux.x = c1.x - c2.x
        Paux.y = c1.y - c2.y
        Paux.z = c1.z - c2.z

        Paux2.x = c3.x - c2.x
        Paux2.y = c3.y - c2.y
        Paux2.z = c3.z - c2.z

        'obtengo el vector perpendicular al plano
        modAlgebra.Cross(paux, paux2, paux3)

        'y de largo 1
        modAlgebra.Normalizar2(paux3, paux)

        paux.x *= -d / 2
        paux.y *= -d / 2
        paux.z *= -d / 2

        paux2.x = -paux.x
        paux2.y = -paux.y
        paux2.z = -paux.z

        Add3D(p1i, c1)
        Add3D(p1f, c1)
        Add3D(p2i, c2)
        Add3D(p2f, c2)
        Add3D(p3i, c3)
        Add3D(p3f, c3)
        Add3D(p4i, c4)
        Add3D(p4f, c4)

        Add3D(p1i, paux)
        Add3D(p1f, paux2)
        Add3D(p2i, paux)
        Add3D(p2f, paux2)
        Add3D(p3i, paux)
        Add3D(p3f, paux2)
        Add3D(p4i, paux)
        Add3D(p4f, paux2)

        '
        'cara 1
        GLQuadColor4f(p1i, p2i, p2f, p1f)

        modAlgebra.vNormal2Plane(p2i, p1i, p2f, paux)

        Normal3D(paux)

        GLQuadColor4f(p2i, p3i, p3f, p2f)

        modAlgebra.vNormal2Plane(p3i, p2i, p3f, paux)

        Normal3D(paux)

        GLQuadColor4f(p3i, p4i, p4f, p3f)

        modAlgebra.vNormal2Plane(p4i, p3i, p4f, paux)

        Normal3D(paux)

        GLQuadColor4f(p4i, p1i, p1f, p4f)

        modAlgebra.vNormal2Plane(p1i, p4i, p1f, paux)

        Normal3D(paux)

        ' tapa inicial
        GLQuadColor4f(p1i, p2i, p3i, p4i)

        modAlgebra.vNormal2Plane(p2i, p3i, p1i, paux)

        Normal3D(paux)

        ' tapa final
        GLQuadColor4f(p1f, p2f, p3f, p4f)

        modAlgebra.vNormal2Plane(p2f, p1f, p3f, paux)

        Normal3D(paux)

    End With

End Sub

Public Sub DibujarRender()

    Dim a As Integer
    Dim m As Integer

    gl.NewList(glListaRender, gl.COMPILE)
    With modestru
        For Each b As ClsBarra In modestru.barra
            If modestru.FiltroBarra(b, IIf(modestru.graficos.FiltroSector > 0, modestru.graficos.FiltroSector, -1),, IIf(modestru.graficos.FiltroTipo > 0, modestru.graficos.FiltroTipo, -1)) Then

                If InStr(LCase$(.material[b.material].nombre), ("acero")) > 0 Then m = 0
                If InStr(LCase$(.material[b.material].nombre), ("hormigon")) > 0 Then m = 1
                If InStr(LCase$(.material[b.material].nombre), ("madera")) > 0 Then m = 2

                If b.tipo = 0 Then dibujar_barra_renderizada(b, m)

                If b.tipo = 1 Then dibujar_barra_renderizada(b, m)

            End If
        Next
        dibujar_vigas
    End With

    DibujarRenderLosas
    gl.EndList

End

Public Sub DrawWireframe()

    Dim a As Integer

    With modestru
        For a = 1 To modestru.barra.Max

            If .barra[a].tipo = 0 Then dibujar_barra_renderizada(a)

            If .barra[a].tipo = 1 Then dibujar_barra_renderizada(a)

        Next
        dibujar_vigas
    End With

End

Public Sub cilindro(centro1 As Punto3d, centro2 As Punto3d, radio As Float, caras As Integer, Optional _color As Single = -1, Optional lleno As Boolean = -1)

    ' Esta es una rutina 3D, tanto para Draw, Paint y OpenGL
    Dim r As Single, g As Integer, b As Integer
    Dim p As New Punto3d
    Dim paso As Integer = 9
    Dim p2 As New Punto3d, p1 As New Punto3d
    Dim py As Float
    Dim angulo As Single
    Dim pIniciales As New Punto3d[]
    Dim pFinales As New Punto3d[]
    Dim pMedio As New Punto3d
    Dim fColor As Integer
    Dim fnormal As Single

    SetLocalMatrix(centro1, centro2)
    If _color > 0 Then glcolorRGB(_color)

    ' creo los puntos
    For r = 0 To caras

        angulo = r * Pi(2) / caras

        If r = caras Then angulo = 0 ' hago un set de puntos extra iniciales

        p2.x = 0 ' centro.x
        p2.y = radio * Sin(angulo)
        p2.z = radio * Cos(angulo)

        Local3D(p2, p)

        Copy3D(p2, p)
        Add3D(p, centro1)
        Add3D(p2, centro2)

        pIniciales.Add(p)
        pFinales.Add(p2)

        p = New Punto3d
        p2 = New Punto3d

    Next

    ' dibujo las caras

    For r = 0 To caras - 1
        ' pMedio.x = (pIniciales[r].x + pIniciales[r + 1].x) / 2
        ' pMedio.y = (pIniciales[r].y + pIniciales[r + 1].y) / 2
        ' pMedio.z = (pIniciales[r].z + pIniciales[r + 1].z) / 2
        '
        GLQuadColor4f(pIniciales[r], pFinales[r], pFinales[r + 1], pIniciales[r + 1])

        ' si es negativo , apunta hacia la pantalla, sino, ni siquiera la muestro
        angulo = (r + 0.5) * Pi(2) / caras

        p2.x = 0 ' centro.x
        p2.y = 1 * Sin(angulo)
        p2.z = 1 * Cos(angulo)

        Local3D(p2, p)

        fNormal = p2.z  ' esto esta entre -1 y 1

        ' el color sera

        fColor = fnormal * 255

        If fNormal >= 0 Then
            'If rellenar Then glcolorRGB  (Color.RGB(0, 0, fColor, 3))
            If modestru.graficos.render Then
                glcolorRGB(Color.HSV(180, 128, fColor, 3))

                gl.end 'paint3D.fill(True)
            End If
        End If

        If modestru.graficos.wireframe Then
            glcolorRGB(Color.SetAlpha(Color.black, 3))

            gl.end
        End If

    Next

End

Public Sub perfilTT(centro1 As Punto3d, centro2 As Punto3d, h As Float, b As Float, Optional _color As Single = -1, Optional lleno As Boolean = -1)

    ' Esta es una rutina 3D, tanto para Draw, Paint y OpenGL
    Dim r As Single, g As Integer
    Dim p As New Punto3d
    Dim paso As Integer = 9
    Dim p2 As New Punto3d, p1 As New Punto3d
    Dim py As Float
    Dim angulo As Single

    Dim pIniciales As New Punto3d[]
    Dim pFinales As New Punto3d[]
    Dim pNormales As New Punto3d[]

    Dim pMedio As New Punto3d
    Dim fColor As Integer
    Dim fnormal As Single
    Dim e As Float  ' espesor = b/10

    e = b / 10

    SetLocalMatrix(centro1, centro2)
    If _color > 0 Then glcolorRGB(_color)

    ' punto en coordenadas de barra
    '1
    p2.x = 0
    p2.y = h / 2
    p2.z = -b / 2

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '2
    p2.x = 0
    p2.y = h / 2
    p2.z = b / 2

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '3
    p2.x = 0
    p2.y = h / 2 - e
    p2.z = b / 2 - e / 2

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '4
    p2.x = 0
    p2.y = h / 2 - e
    p2.z = e / 2

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '5
    p2.x = 0
    p2.y = -(h / 2 - e)
    p2.z = e / 2

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '6
    p2.x = 0
    p2.y = -(h / 2 - e)
    p2.z = b / 2 - e / 2

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '7
    p2.x = 0
    p2.y = -h / 2
    p2.z = b / 2

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '8
    p2.x = 0
    p2.y = -h / 2
    p2.z = -b / 2

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)
    '9
    p = New Punto3d
    p2 = New Punto3d
    p2.x = 0
    p2.y = -(h / 2 - e)
    p2.z = -(b / 2 - e / 2)

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '10
    p2.x = 0
    p2.y = -(h / 2 - e)
    p2.z = -e / 2

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '11
    p2.x = 0
    p2.y = h / 2 - e
    p2.z = -e / 2

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '12
    p2.x = 0
    p2.y = h / 2 - e
    p2.z = -(b / 2 - e / 2)

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '1 bis
    p2.x = 0
    p2.y = h / 2
    p2.z = -b / 2

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d

    ' creo las normales
    ' cara 1
    p2.x = 0
    p2.y = 1
    p2.z = 0

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d

    'cara 2
    p2.x = 0
    p2.y = 0
    p2.z = 1

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d
    'cara 3
    p2.x = 0
    p2.y = -1
    p2.z = 0

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d
    'cara 4
    p2.x = 0
    p2.y = 0
    p2.z = 1

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d
    'cara 5
    p2.x = 0
    p2.y = 1
    p2.z = 0

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d

    ' cara 6
    p2.x = 0
    p2.y = 0
    p2.z = 1

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d

    'cara 7
    p2.x = 0
    p2.y = -1
    p2.z = 0

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d
    'cara 8
    p2.x = 0
    p2.y = 0
    p2.z = -1

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d
    'cara 9
    p2.x = 0
    p2.y = 1
    p2.z = 0

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d
    ' cara 10
    p2.x = 0
    p2.y = 0
    p2.z = -1

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d

    'cara 11
    p2.x = 0
    p2.y = -1
    p2.z = 0

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d
    '12
    p2.x = 0
    p2.y = 0
    p2.z = -1
    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d

    ' dibujo las caras

    For r = 0 To pIniciales.Max - 1
        '
        GLQuadColor4f(pIniciales[r], pFinales[r], pFinales[r + 1], pIniciales[r + 1])

        Normal3D(pNormales[r])

    Next

End

Public Sub perfilL(centro1 As Punto3d, centro2 As Punto3d, h As Float, b As Float, Optional _color As Single = -1, Optional lleno As Boolean = -1)

    ' Esta es una rutina 3D, tanto para Draw, Paint y OpenGL
    Dim r As Single, g As Integer
    Dim p As New Punto3d
    Dim paso As Integer = 9
    Dim p2 As New Punto3d, p1 As New Punto3d
    Dim py As Float
    Dim angulo As Single

    Dim pIniciales As New Punto3d[]
    Dim pFinales As New Punto3d[]
    Dim pNormales As New Punto3d[]

    Dim pMedio As New Punto3d
    Dim fColor As Integer
    Dim fnormal As Single
    Dim e As Float  ' espesor = b/10

    e = b / 10

    SetLocalMatrix(centro1, centro2)
    If _color > 0 Then glcolorRGB(_color)

    ' punto en coordenadas de barra
    '1
    p2.x = 0
    p2.y = h * 2 / 3
    p2.z = -b / 3

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '2
    p2.x = 0
    p2.y = h * 2 / 3 - e / 2
    p2.z = -(b / 3 - e)

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '3
    p2.x = 0
    p2.y = -(h / 3 - e)
    p2.z = -(b / 3 - e)

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '4
    p2.x = 0
    p2.y = -(h / 3 - e)
    p2.z = b * 2 / 3 - e / 2

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '5
    p2.x = 0
    p2.y = -h / 3
    p2.z = b * 2 / 3

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '6
    p2.x = 0
    p2.y = -h / 3
    p2.z = -b / 3

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d
    '1 bis
    p2.x = 0
    p2.y = h * 2 / 3
    p2.z = -b / 3

    Local3D(p2, p)
    Copy3D(p2, p)
    Add3D(p, centro1)
    Add3D(p2, centro2)

    pIniciales.Add(p)
    pFinales.Add(p2)

    p = New Punto3d
    p2 = New Punto3d

    ' creo las normales
    ' cara 1
    p2.x = 0
    p2.y = 1
    p2.z = 0

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d

    'cara 2
    p2.x = 0
    p2.y = 0
    p2.z = 1

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d
    'cara 3
    p2.x = 0
    p2.y = 1
    p2.z = 0

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d

    'cara 4
    p2.x = 0
    p2.y = 0
    p2.z = 1

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d
    'cara 5
    p2.x = 0
    p2.y = -1
    p2.z = 0

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d

    ' cara 6
    p2.x = 0
    p2.y = 0
    p2.z = -1

    Local3D(p2, p)

    pNormales.Add(p)

    p = New Punto3d
    p2 = New Punto3d

    ' dibujo las caras

    For r = 0 To pIniciales.Max - 1
        '
        GLQuadColor4f(pIniciales[r], pFinales[r], pFinales[r + 1], pIniciales[r + 1])

        Normal3D(pNormales[r])

        ' fNormal = p2.z  ' esto esta entre -1 y 1
        '
        '       ' el color sera
        '
        ' fColor = fnormal * 255
        '
        '
        '       If fNormal >= 0 Then
        '         'If rellenar Then glcolorRGB  (Color.RGB(0, 0, fColor, 128))
        '         If modestru.graficos.render Then
        '             glcolorRGB(Color.HSV(180, 128, fColor, 3))
        '
        '             gl.end
        '         End If
        '       End If
        '
        '       If modestru.graficos.wireframe Then
        '         glcolorRGB(Color.SetAlpha(Color.black, 3))
        '
        '         gl.end
        '       End If
        '

    Next

End

Public Sub ScaleColorRGB(valor As Float, escala As Float, Optional Alpha As Float = 1, Optional mode As Integer = 0, Optional C4F As GLColorSt)
    ' busca en la escala el color adecuado
    ' a escala esta armada para 0 a 1000, o sea 0 = 500
    ' y la devuelve

    Dim r As Float, g As Float, b As Float, pos As Integer

    If escala = 0 Then escala = 1

    ' esto es lineal
    If mode = 0 Then
        pos = 500 + 500 * valor / escala
    Else
        ' escaa logaritmica
        pos = 500 + 500 * Sgn(valor) * Log(1 + mode * Abs(valor) / escala) / Log(mode + 1)
    Endif

    'If gbcolor > 0 Then Stop
    r = ColorScale[0, pos]
    g = ColorScale[1, pos]
    b = ColorScale[2, pos]

    If c4f Then
        C4f.r = r
        C4f.g = g
        c4f.b = b
        c4f.Alpha = Alpha
    Else
        glColor4f(r, g, b, Alpha)
    End If
    '

End

Public Sub glColorRGB(gbColor As Integer, Optional Alpha As Float = 1)
    ' set the color to GL

    Dim r As Float, g As Float, b As Float

    r = (Shr(gbColor, 16) And 255) / 256
    g = (Shr(gbColor, 8) And 255) / 256
    b = (gbColor And 255) / 256
    glColor4f(r, g, b, Alpha)
    '     Debug r, g, b

End

Public Sub glMaterial(gbColor As Integer, Optional Alpha As Float = 0)
    ' set the color to GL

    Dim r As Float, g As Float, b As Float
    Dim MyColor As New Float[]

    'If gbcolor > 0 Then Stop
    r = (Shr(gbColor, 16) And 255) / 256
    g = (Shr(gbColor, 8) And 255) / 256
    b = (gbColor And 255) / 256
    MyColor = [r, g, b, Alpha]

    gl.Materialfv(gl.FRONT_AND_BACK, gl.AMBIENT_AND_DIFFUSE, MyColor)
    gl.Materialf(gl.FRONT_AND_BACK, gl.SHININESS, 45)

End

Public Sub glMaterialHierro(Optional Alpha As Float = 0)
    ' set the color to GL

    Dim r As Float, g As Float, b As Float
    Dim MyColor As New Float[]

    MyColor = [0.05375, 0.05, 0.06625, 1.0]

    gl.Materialfv(gl.FRONT_AND_BACK, gl.AMBIENT, MyColor)

    MyColor = [0.18275, 0.17, 0.22525]

    gl.Materialfv(gl.FRONT_AND_BACK, gl.DIFFUSE, MyColor)

    MyColor = [0.332741, 0.328634, 0.346435]

    gl.Materialfv(gl.FRONT_AND_BACK, gl.SPECULAR, MyColor)

    gl.Materialf(gl.FRONT_AND_BACK, gl.SHININESS, 0.3 * 128)

End

Public Sub glMaterialMadera(Optional Alpha As Float = 0)
    ' set the color to GL

    Dim r As Float, g As Float, b As Float
    Dim MyColor As New Float[]

    MyColor = [0.05, 0.05, 0.0, 1.0]

    gl.Materialfv(gl.FRONT_AND_BACK, gl.AMBIENT, MyColor)

    MyColor = [0.5, 0.5, 0.4]

    gl.Materialfv(gl.FRONT_AND_BACK, gl.DIFFUSE, MyColor)

    MyColor = [0.7, 0.7, 0.04]

    gl.Materialfv(gl.FRONT_AND_BACK, gl.SPECULAR, MyColor)

    gl.Materialf(gl.FRONT_AND_BACK, gl.SHININESS, 0.07815 * 128)

End

Public Sub glMaterialConcreto(Optional Alpha As Float = 0)
    ' set the color to GL

    Dim r As Float, g As Float, b As Float
    Dim MyColor As New Float[]

    MyColor = [0.2, 0.2, 0.2, 1.0]

    gl.Materialfv(gl.FRONT_AND_BACK, gl.AMBIENT, MyColor)

    MyColor = [0.4, 0.4, 0.4]

    gl.Materialfv(gl.FRONT_AND_BACK, gl.DIFFUSE, MyColor)

    MyColor = [0.6, 0.6, 0.6]

    gl.Materialfv(gl.FRONT_AND_BACK, gl.SPECULAR, MyColor)

    gl.Materialf(gl.FRONT_AND_BACK, gl.SHININESS, 0.25 * 128)

End

Sub Vertex3D(p As Punto3d, Optional _Color4F As GLColorSt)

    '2020 el color va primero

    If _Color4F Then
        gl.Color4f(_Color4F.r, _Color4F.g, _Color4F.b, _Color4F.Alpha)

    Endif
    gl.Vertex3f(p.x, p.y, p.z)

End

Sub Normal3D(p As Punto3d)

    gl.Normal3f(p.x, p.y, p.z)

End

Public Sub txtRendering2D(texto As String, x As Float, y As Float, Optional Altura As Single = 12, Optional _color As Long = Color.Blue, Optional _BackColor As Long = -1, Optional centradoH As Integer = 0, Optional centradoV As Integer = 0)

    ' this works in a Orthogonal projection

    Dim rectangulo As RectF

    Dim imagen As New Image, p As New Punto3d

    imagen.Resize(200, 200) 'so Paint.Begin gives no error

    Paint.Begin(imagen)

    Paint.Font.Size = Altura

    Paint.Brush = Paint.Color(_color)

    rectangulo = Paint.TextSize(texto)

    Paint.End

    rectangulo.Height /= 1.25  ' correct the innecesary extra height

    'this can't go into the Paint loop

    imagen.resize(rectangulo.Width, rectangulo.Height)

    If _backcolor > 0 Then

        imagen.Fill(_BackColor)

    Else

        ' until I know how to make it transparente, it goes like this

        imagen.Fill(Color.White)

    End If

    EscalaGL = 1

    Paint.Begin(imagen)

    Paint.Font.Size = Altura

    Paint.Brush = Paint.Color(_color)

    Paint.Text(texto, 0, rectangulo.Height * 0.85) 'locate the text at the bottom + 15% so it's vertically centered in the box

    Paint.Fill

    Paint.End

    'imagen.Save("imagen.png")  ' this is to check the Paint worked (and works!) (re checckeado 02/06/16)

    ' allignment to the 3D point p

    If centradoH = 1 Then x -= rectangulo.Width * EscalaGL

    If centradoH = 2 Then x -= rectangulo.Width / 2 * EscalaGL

    If centradoV = 1 Then y -= rectangulo.Height * EscalaGL

    If centradoV = 2 Then y -= rectangulo.Height / 2 * EscalaGL

    gl.MatrixMode(gl.PROJECTION)
    gl.PushMatrix

    gl.LoadIdentity()

    Gl.Ortho(0, fmain.gestru.w, 0, fmain.gestru.h, 0, 1)

    gl.MatrixMode(gl.MODELVIEW)
    gl.PushMatrix
    gl.LoadIdentity()

    Gl.TexImage2D(imagen)

    Gl.TexParameteri(Gl.TEXTURE_2D, Gl.TEXTURE_MIN_FILTER, Gl.NEAREST)

    Gl.TexParameteri(Gl.TEXTURE_2D, Gl.TEXTURE_MAG_FILTER, Gl.NEAREST)

    gl.BindTexture(gl.TEXTURE_2D, hText[0])

    Gl.Begin(Gl.QUADS)

    gl.color3f(1, 1, 1)

    Gl.TexCoordf(0.0, 1.0) ' Bottom Left OF The Texture AND Quad

    Gl.Vertex2f(x, y)

    Gl.TexCoordf(1.0, 1.0) ' Bottom Right OF The Texture AND Quad

    Gl.Vertex2f(x + rectangulo.Width * EscalaGL, y)

    Gl.TexCoordf(1.0, 0.0) ' Top Right OF The Texture AND Quad

    Gl.Vertex2f(x + rectangulo.Width * EscalaGL, y + rectangulo.Height * EscalaGL)

    Gl.TexCoordf(0.0, 0.0) ' Top Left OF The Texture AND Quad

    Gl.Vertex2f(x, y + rectangulo.Height * EscalaGL)

    Gl.End()

    gl.PopMatrix
    gl.MatrixMode(gl.PROJECTION)
    gl.PopMatrix

End

Public Sub txtRendering3D(texto As String, pr As Punto3d, Optional Altura As Single = 12, Optional _color As Long = Color.Blue, Optional _BackColor As Long = -1, Optional centradoH As Integer = 0, Optional centradoV As Integer = 0)

    Dim x As Float, y As Float, z As Float

    GLCam.Get2DpointFrom3Dworld(pr, ByRef x, ByRef y, ByRef z)

    If z <= 1 Then txtRendering2D(texto, x, y, altura, _color, _backcolor, centradoH, centradoV)

End

Public Sub GenerarImgNroBarras(Optional Altura As Single = 12, Optional _color As Long = Color.Blue, Optional _BackColor As Long = -1)

    'genera las imagenes2D para los numeros de barras
    'esto ahorra mucho tiempo, al no tener que generarlas en cada frame

    ' FIXME: usar GLPlus
    Return

    Dim x0 As Float, y0 As Float
    Dim x1 As Float, y1 As Float, p1 As New Punto3d, p2 As New Punto3d, p3 As New Punto3d
    Dim ni As Integer, nF As Integer, a As Integer, q As String

    Dim imgUnit As New Image
    Dim rectangulo As RectF

    'gl.NewList(glListaNumeroBarras, gl.COMPILE)

    CoordNroBarras.Resize(modestru.datos.totalbarras * 2)

    For a = 1 To modestru.datos.totalbarras

        If modestru.FiltroBarra(a, IIf(modestru.graficos.FiltroSector > 0, modestru.graficos.FiltroSector, -1),, IIf(modestru.graficos.FiltroTipo > 0, modestru.graficos.FiltroTipo, -1)) Then

            q = Format$(a, "0")

            imgUnit = New Image

            imgNroBarras.Add(imgUnit)

            imgNroBarras[a - 1].Resize(200, 200) 'so Paint.Begin gives no error

            Paint.Begin(imgNroBarras[a - 1])

            Paint.Font.Size = Altura

            Paint.Brush = Paint.Color(_color)

            rectangulo = Paint.TextSize(q)

            Paint.End

            rectangulo.Height /= 1.25  ' correct the innecesary extra height

            'this can't go into the Paint loop

            imgNroBarras[a - 1].resize(rectangulo.Width, rectangulo.Height)

            If _backcolor > 0 Then

                imgNroBarras[a - 1].Fill(_BackColor)

            Else

                ' until I know how to make it transparente, it goes like this

                imgNroBarras[a - 1].Fill(Color.White)

            End If

            Paint.Begin(imgNroBarras[a - 1])

            Paint.Font.Size = Altura

            Paint.Brush = Paint.Color(_color)

            Paint.Text(q, 0, rectangulo.Height * 0.85) 'locate the text at the bottom + 15% so it's vertically centered in the box

            Paint.Fill

            Paint.End

        End If

    Next

End

Public Sub GenerarImgNroNudos(Optional Altura As Single = 12, Optional _color As Long = Color.Blue, Optional _BackColor As Long = -1)

    'genera las imagenes2D para los numeros de barras
    'esto ahorra mucho tiempo, al no tener que generarlas en cada frame

    ' FIXME: usar glpuls
    Return

    Dim x0 As Float, y0 As Float
    Dim x1 As Float, y1 As Float, p1 As New Punto3d, p2 As New Punto3d, p3 As New Punto3d
    Dim ni As Integer, nF As Integer, a As Integer, q As String

    Dim imgUnit As New Image
    Dim rectangulo As RectF

    'gl.NewList(glListaNumeroBarras, gl.COMPILE)

    CoordNroNudos.Resize(modestru.nudo.max * 2)
    DibujadoNroNudos.Resize(modestru.nudo.Count)

    For a = 1 To modestru.nudo.max
        'If bar.grupo = 0 Or (modestru.graficos.SeDibujanSubElementos And bar.tipo <> modestru.tipo_losa) Then
        q = Format$(a, "0")

        imgUnit = New Image

        imgNroNudos.Add(imgUnit)

        imgNroNudos[a - 1].Resize(200, 200) 'so Paint.Begin gives no error

        Paint.Begin(imgNroNudos[a - 1])

        Paint.Font.Size = Altura

        Paint.Brush = Paint.Color(_color)

        rectangulo = Paint.TextSize(q)

        Paint.End

        rectangulo.Height /= 1.25  ' correct the innecesary extra height

        'this can't go into the Paint loop

        imgNroNudos[a - 1].resize(rectangulo.Width, rectangulo.Height)

        If _backcolor > 0 Then

            imgNroNudos[a - 1].Fill(_BackColor)

        Else

            ' until I know how to make it transparente, it goes like this

            imgNroNudos[a - 1].Fill(Color.White)

        End If

        Paint.Begin(imgNroNudos[a - 1])

        Paint.Font.Size = Altura

        Paint.Brush = Paint.Color(_color)

        Paint.Text(q, 0, rectangulo.Height * 0.85) 'locate the text at the bottom + 15% so it's vertically centered in the box

        Paint.Fill

        Paint.End

        'End If

    Next

End

Public Sub DibujarNroNudos(Optional centradoH As Integer = 0, Optional centradoV As Integer = 0)

    Dim x0 As Float, y0 As Float
    Dim x As Float, y As Float, z As Float
    Dim x1 As Float, y1 As Float, p1 As New Punto3d, p2 As New Punto3d, p3 As New Punto3d
    Dim ni As Integer, nF As Integer, a As Integer, q As String

    '
    For a = 1 To modestru.nudo.max

        p1.x = modestru.nudo[a].x
        p1.Y = modestru.nudo[a].Y
        p1.z = modestru.nudo[a].z
        DibujadoNroNudos[a] = False

        GLCam.Get2DpointFrom3Dworld(p1, ByRef x, ByRef y, ByRef z)
        If z > 1 Then
            x = -100
            y = -100
        End If
        CoordNroNudos[(a - 1) * 2] = x
        CoordNroNudos[(a - 1) * 2 + 1] = y

    Next

    gl.MatrixMode(gl.PROJECTION)
    gl.PushMatrix

    gl.LoadIdentity()

    Gl.Ortho(0, fmain.gestru.w, 0, fmain.gestru.h, 0, 1)

    gl.MatrixMode(gl.MODELVIEW)
    gl.PushMatrix
    gl.LoadIdentity()

    For a = 1 To modestru.nudo.Max

        ' allignment to the 3D point p
        x = CoordNroNudos[(a - 1) * 2]
        y = CoordNroNudos[(a - 1) * 2 + 1]

        If centradoH = 1 Then x -= imgNroNudos[a - 1].Width

        If centradoH = 2 Then x -= imgNroNudos[a - 1].Width / 2

        If centradoV = 1 Then y -= imgNroNudos[a - 1].Height

        If centradoV = 2 Then y -= imgNroNudos[a - 1].Height / 2

        Gl.TexImage2D(imgNroNudos[a - 1])

        Gl.TexParameteri(Gl.TEXTURE_2D, Gl.TEXTURE_MIN_FILTER, Gl.NEAREST)

        Gl.TexParameteri(Gl.TEXTURE_2D, Gl.TEXTURE_MAG_FILTER, Gl.NEAREST)

        gl.BindTexture(gl.TEXTURE_2D, hText[0])

        Gl.Begin(Gl.QUADS)

        gl.color3f(1, 1, 1)

        Gl.TexCoordf(0.0, 1.0) ' Bottom Left OF The Texture AND Quad

        Gl.Vertex2f(x, y)

        Gl.TexCoordf(1.0, 1.0) ' Bottom Right OF The Texture AND Quad

        Gl.Vertex2f(x + imgNroNudos[a - 1].Width, y)

        Gl.TexCoordf(1.0, 0.0) ' Top Right OF The Texture AND Quad

        Gl.Vertex2f(x + imgNroNudos[a - 1].Width, y + imgNroNudos[a - 1].Height)

        Gl.TexCoordf(0.0, 0.0) ' Top Left OF The Texture AND Quad

        Gl.Vertex2f(x, y + imgNroNudos[a - 1].Height)

        Gl.End()

        'End If
    Next

    gl.PopMatrix
    gl.MatrixMode(gl.PROJECTION)
    gl.PopMatrix

End

Public Sub DibujarNroBarras(Optional centradoH As Integer = 0, Optional centradoV As Integer = 0)

    Dim x0 As Float, y0 As Float
    Dim x As Float, y As Float, z As Float
    Dim x1 As Float, y1 As Float, p1 As New Punto3d, p2 As New Punto3d, p3 As New Punto3d
    Dim ni As Integer, nF As Integer, a As Integer, q As String
    Dim n1 As Short

    ' FIXME: usar glplus

    Return

    '
    For Each bar As ClsBarra In modestru.barra ' a = 1 To modestru.datos.totalbarras
        'If bar.grupo = 0 Or (modestru.graficos.SeDibujanSubElementos And bar.tipo <> modestru.tipo_losa) Then
        If (bar.grupo = 0) Or modestru.graficos.SeDibujanSubElementos Then

            ni = bar.ni
            nF = bar.nF

            p1.x = modestru.nudo[ni].x
            p1.Y = modestru.nudo[ni].Y
            p1.z = modestru.nudo[ni].z

            p2.x = modestru.nudo[nF].x
            p2.Y = modestru.nudo[nF].Y
            p2.z = modestru.nudo[nF].z

            p3.x = p1.x + (p2.x - p1.x) / 2
            p3.y = p1.y + (p2.y - p1.y) / 2
            p3.z = p1.z + (p2.z - p1.z) / 2

            GLCam.Get2DpointFrom3Dworld(p3, ByRef x, ByRef y, ByRef z)
            If z > 1 Then
                x = -100
                y = -100
            End If

            CoordNroBarras[(a - 1) * 2] = x
            CoordNroBarras[(a - 1) * 2 + 1] = y

        End If
    Next

    For a = 1 To modestru.nudo.max

        p1.x = modestru.nudo[a].x
        p1.Y = modestru.nudo[a].Y
        p1.z = modestru.nudo[a].z
        DibujadoNroNudos[a] = False

        GLCam.Get2DpointFrom3Dworld(p1, ByRef x, ByRef y, ByRef z)
        If z > 1 Then
            x = -100
            y = -100
        End If
        CoordNroNudos[(a - 1) * 2] = x
        CoordNroNudos[(a - 1) * 2 + 1] = y

    Next

    gl.MatrixMode(gl.PROJECTION)
    gl.PushMatrix

    gl.LoadIdentity()

    Gl.Ortho(0, fmain.gestru.w, 0, fmain.gestru.h, 0, 1)

    gl.MatrixMode(gl.MODELVIEW)
    gl.PushMatrix
    gl.LoadIdentity()

    For a = 1 To modestru.datos.totalbarras
        If modestru.FiltroBarra(a, IIf(modestru.graficos.FiltroSector > 0, modestru.graficos.FiltroSector, -1),, IIf(modestru.graficos.FiltroTipo > 0, modestru.graficos.FiltroTipo, -1)) Then

            ' If bar.grupo = 0 Or (modestru.graficos.SeDibujanSubElementos And bar.tipo <> modestru.tipo_losa) Then
            If (bar.grupo = 0) Or modestru.graficos.SeDibujanSubElementos Then

                ' allignment to the 3D point p
                x = CoordNroBarras[(a - 1) * 2]
                y = CoordNroBarras[(a - 1) * 2 + 1]

                If centradoH = 1 Then x -= imgNroBarras[a - 1].Width

                If centradoH = 2 Then x -= imgNroBarras[a - 1].Width / 2

                If centradoV = 1 Then y -= imgNroBarras[a - 1].Height

                If centradoV = 2 Then y -= imgNroBarras[a - 1].Height / 2

                Gl.TexImage2D(imgNroBarras[a - 1])

                Gl.TexParameteri(Gl.TEXTURE_2D, Gl.TEXTURE_MIN_FILTER, Gl.NEAREST)

                Gl.TexParameteri(Gl.TEXTURE_2D, Gl.TEXTURE_MAG_FILTER, Gl.NEAREST)

                gl.BindTexture(gl.TEXTURE_2D, hText[0])

                Gl.Begin(Gl.QUADS)

                gl.color3f(1, 1, 1)

                Gl.TexCoordf(0.0, 1.0) ' Bottom Left OF The Texture AND Quad

                Gl.Vertex2f(x, y)

                Gl.TexCoordf(1.0, 1.0) ' Bottom Right OF The Texture AND Quad

                Gl.Vertex2f(x + imgNroBarras[a - 1].Width, y)

                Gl.TexCoordf(1.0, 0.0) ' Top Right OF The Texture AND Quad

                Gl.Vertex2f(x + imgNroBarras[a - 1].Width, y + imgNroBarras[a - 1].Height)

                Gl.TexCoordf(0.0, 0.0) ' Top Left OF The Texture AND Quad

                Gl.Vertex2f(x, y + imgNroBarras[a - 1].Height)

                Gl.End()

                '==================================================================new 2017==============================================================
                ' ahora dibujo sus nudos
                If modestru.graficos.SeDibujanNudos Then
                    ni = bar.ni
                    nF = bar.nF

                    If Not DibujadoNroNudos[ni] Then
                        DibujadoNroNudos[ni] = True

                        x = CoordNroNudos[(ni - 1) * 2]
                        y = CoordNroNudos[(ni - 1) * 2 + 1]

                        If centradoH = 1 Then x -= imgNroNudos[ni - 1].Width

                        If centradoH = 2 Then x -= imgNroNudos[ni - 1].Width / 2

                        If centradoV = 1 Then y -= imgNroNudos[ni - 1].Height

                        If centradoV = 2 Then y -= imgNroNudos[ni - 1].Height / 2

                        Gl.TexImage2D(imgNroNudos[ni - 1])

                        Gl.TexParameteri(Gl.TEXTURE_2D, Gl.TEXTURE_MIN_FILTER, Gl.NEAREST)

                        Gl.TexParameteri(Gl.TEXTURE_2D, Gl.TEXTURE_MAG_FILTER, Gl.NEAREST)

                        gl.BindTexture(gl.TEXTURE_2D, hText[0])

                        Gl.Begin(Gl.QUADS)

                        gl.color3f(1, 1, 1)

                        Gl.TexCoordf(0.0, 1.0) ' Bottom Left OF The Texture AND Quad

                        Gl.Vertex2f(x, y)

                        Gl.TexCoordf(1.0, 1.0) ' Bottom Right OF The Texture AND Quad

                        Gl.Vertex2f(x + imgNroNudos[ni - 1].Width, y)

                        Gl.TexCoordf(1.0, 0.0) ' Top Right OF The Texture AND Quad

                        Gl.Vertex2f(x + imgNroNudos[ni - 1].Width, y + imgNroNudos[ni - 1].Height)

                        Gl.TexCoordf(0.0, 0.0) ' Top Left OF The Texture AND Quad

                        Gl.Vertex2f(x, y + imgNroNudos[ni - 1].Height)

                        Gl.End()

                    End If
                    If Not DibujadoNroNudos[nf] Then
                        DibujadoNroNudos[nf] = True

                        x = CoordNroNudos[(nf - 1) * 2]
                        y = CoordNroNudos[(nf - 1) * 2 + 1]

                        If centradoH = 1 Then x -= imgNroNudos[nf - 1].Width

                        If centradoH = 2 Then x -= imgNroNudos[nf - 1].Width / 2

                        If centradoV = 1 Then y -= imgNroNudos[nf - 1].Height

                        If centradoV = 2 Then y -= imgNroNudos[nf - 1].Height / 2

                        Gl.TexImage2D(imgNroNudos[nf - 1])

                        Gl.TexParameteri(Gl.TEXTURE_2D, Gl.TEXTURE_MIN_FILTER, Gl.NEAREST)

                        Gl.TexParameteri(Gl.TEXTURE_2D, Gl.TEXTURE_MAG_FILTER, Gl.NEAREST)

                        gl.BindTexture(gl.TEXTURE_2D, hText[0])

                        Gl.Begin(Gl.QUADS)

                        gl.color3f(1, 1, 1)

                        Gl.TexCoordf(0.0, 1.0) ' Bottom Left OF The Texture AND Quad

                        Gl.Vertex2f(x, y)

                        Gl.TexCoordf(1.0, 1.0) ' Bottom Right OF The Texture AND Quad

                        Gl.Vertex2f(x + imgNroNudos[nf - 1].Width, y)

                        Gl.TexCoordf(1.0, 0.0) ' Top Right OF The Texture AND Quad

                        Gl.Vertex2f(x + imgNroNudos[nf - 1].Width, y + imgNroNudos[nf - 1].Height)

                        Gl.TexCoordf(0.0, 0.0) ' Top Left OF The Texture AND Quad

                        Gl.Vertex2f(x, y + imgNroNudos[nf - 1].Height)

                        Gl.End()

                    End If
                End If

            End If
        End If
    Next

    gl.PopMatrix
    gl.MatrixMode(gl.PROJECTION)
    gl.PopMatrix

End

Sub LucesOn()

    Gl.Lightfv(Gl.LIGHT0, Gl.AMBIENT_AND_DIFFUSE, [1.0, 1.0, 1.0, 0.5])

    Gl.Lightfv(Gl.LIGHT0, Gl.POSITION, [GLCam.Position.x, GLCam.Position.y, GLCam.Position.z, 1])

    Gl.Enable(Gl.LIGHTING)
    Gl.Enable(Gl.LIGHT0)

    Gl.Enable(Gl.NORMALIZE) ' esto sirve para normalizar los vectores normales , o sea que sean de largo = 1

End

Sub LucesOff()

    Gl.Disable(Gl.LIGHTING)
    Gl.disable(Gl.LIGHT0)

    Gl.disable(Gl.NORMALIZE) ' esto sirve para normalizar los vectores normales , o sea que sean de largo = 1

End Sub

Sub testRender()

    Dim imgTextura As Image

    imgTextura = image.Load("madera.png")

    Debug imgTextura.Format

    If imgTextura.Width = 0 Then Stop

    imgTextura.Save("testsa.jpg")

    Gl.TexImage2D(imgTextura)

    Gl.TexParameteri(Gl.TEXTURE_2D, Gl.TEXTURE_MIN_FILTER, Gl.NEAREST)

    Gl.TexParameteri(Gl.TEXTURE_2D, Gl.TEXTURE_MAG_FILTER, Gl.NEAREST)

    gl.BindTexture(gl.TEXTURE_2D, hText[0])

    gl.color3f(1, 1, 1)
    'cara 1
    gl.begin(gl.QUADS)

    Gl.TexCoordf(0.0, 1.0)
    gl.Vertex3f(0, 0, 0)

    Gl.TexCoordf(1.0, 1.0)
    gl.Vertex3f(1, 0, 0)

    Gl.TexCoordf(1.0, 0.0)
    gl.Vertex3f(1, 1, 0)

    Gl.TexCoordf(0.0, 0.0)
    gl.Vertex3f(0, 1, 0)

    gl.end

End

Sub DibujarEscalaColor()

    Dim a As Integer, g As Integer

    'genero la escala

    For a = 0 To 250
        ColorScale[0, a] = 1
        ColorScale[1, a] = a / 250
    Next

    For a = 0 To 250
        ColorScale[0, a + 250] = 1 - a / 250
        ColorScale[1, a + 250] = 1

    Next
    For a = 0 To 250
        ColorScale[2, a + 500] = a / 250
        ColorScale[1, a + 500] = 1

    Next
    For a = 0 To 250
        ColorScale[2, a + 750] = 1
        ColorScale[1, a + 750] = 1 - a / 250
    Next

    gl.MatrixMode(gl.PROJECTION)
    gl.PushMatrix

    gl.LoadIdentity()

    Gl.Ortho(0, fmain.gestru.w, 0, fmain.gestru.h, 0, 1)

    gl.MatrixMode(gl.MODELVIEW)
    gl.PushMatrix
    gl.LoadIdentity()

    gl.Begin(gl.lines)
    For a = 0 To 300

        gl.Color3f(ColorScale[0, a * 1000 / 300], ColorScale[1, a * 1000 / 300], ColorScale[2, a * 1000 / 300])
        gl.Vertex2i(20, 100 + a)
        gl.Vertex2i(30, 100 + a)
    Next

    gl.End
    gl.PopMatrix
    gl.MatrixMode(gl.PROJECTION)
    gl.PopMatrix

End

Sub GenerarGridLosa(losa As Integer, esfuerzo As Integer, Optional interpolado As Integer = 2)

    Dim GridCoord As New Float[]  'las coordenadas XYZ de los puntos de la grilla
    Dim GridEsf As New Float[]  'el esfuerzo a representar
    Dim P00 As New Punto3d, Pff As New Punto3d  'los limites XYZ de la grilla
    Dim dX As Float, dY As Float, dZ As Float  'las distancias entre puntos de la grilla
    Dim sX As Integer, sZ As Integer  ' los pasos en la grilla
    Dim x As Integer, z As Integer ' variables auxiliares para los for-next

    Dim n1 As Integer, n2 As Integer, n3 As Integer, n4 As Integer 'nudos limite

    Dim p As Integer  'la posicion en el array

    GridCoord.Resize((modestru.losas[losa].nxGrid + 1) * (modestru.losas[losa].nxGrid + 1) * 3)

    GridEsf.Resize((modestru.losas[losa].nxGrid + 1) * (modestru.losas[losa].nxGrid + 1))

    'genero la grid de puntos XYZ
    n1 = modestru.losas[losa].Nudo1
    n2 = modestru.losas[losa].Nudo2
    n3 = modestru.losas[losa].Nudo3
    n4 = modestru.losas[losa].Nudo4

    dx = modestru.nudo[n2].x - modestru.nudo[n1].x

    dy = modestru.nudo[n4].x - modestru.nudo[n1].x

    dz = modestru.nudo[n4].x - modestru.nudo[n3].x

    For z = 0 To modestru.losas[losa].nzGrid
        For x = 0 To modestru.losas[losa].nxGrid
            p = (z * modestru.losas[losa].nXGrid + x) * 3

            GridCoord[p] = modestru.nudo[n1].x + dx * x
            GridCoord[p + 1] = modestru.nudo[n1].y + dy * x
            GridCoord[p + 1] = modestru.nudo[n1].z + dz * z

        Next
    Next

    'genero la grid de esfuerzos

    For z = 1 To modestru.losas[losa].nzGrid
        For x = 1 To modestru.losas[losa].nxGrid

            'ahora tengo que buscar la barra que necesito para ver el esf

            p = z * modestru.losas[losa].nXGrid + x

            GridEsf[p] = Rnd(0, 1000)

        Next
    Next

    'la dibujo por triangulos

    'gl.NewList(ListaLosas, gl.COMPILE)

    For z = 0 To modestru.losas[losa].nzGrid
        For x = 0 To modestru.losas[losa].nxGrid

            'ahora tengo que buscar la barra que necesito para ver el esf

            p = z * modestru.losas[losa].nXGrid + x

            GridEsf[p] = Rnd(0, 1000)

        Next
    Next

End

Sub DibujarEsfuerzosLosas(direccion As Integer, Esfuerzo As Integer)

    'direccion 1 = X, 2 = Z, 3 = X+Z (vectorial)

    Dim a As Integer, bru As PaintBrush, eje As New Punto3d, l As Integer, b As Integer, d As Integer, c As Integer
    Dim centro As New Punto3d
    Dim p1 As New Punto3d, p2 As New Punto3d, p3 As New Punto3d, p4 As New Punto3d

    Dim c1 As New GLColorSt, c2 As New GLColorSt, c3 As New GLColorSt, c4 As New GLColorSt

    Dim radio As Float

    ' nuevos
    Dim dX12 As Float, dX34 As Float, dZ13 As Float, dZ24 As Float, dY12 As Float, dY13 As Float

    Dim pX As Integer, pZ As Integer

    Dim c1s As String, c2s As String, c3s As String, c4s As String
    Dim x0 As Float, z0 As Float, x As Float, z As Float, y0 As Float, y1 As Float, y As Float

    Dim maxEscala As Float
    Dim vEsf As Float

    If Not ((modestru.graficos.FiltroTipo = modestru.tipo_indef) Or (modestru.graficos.FiltroTipo = modestru.tipo_losa)) Then Return

    For l = 0 To modestru.losas.Max
        If ((modestru.graficos.FiltroSector <= 0) Or (modestru.graficos.FiltroSector = modestru.losas[l].sector)) Then

            If esfuerzo = 1 Then maxEscala = modestru.graficos.maxNLosas
            If esfuerzo = 2 Then maxEscala = modestru.graficos.maxQyLosas
            If esfuerzo = 3 Then maxEscala = modestru.graficos.maxQzLosas
            If esfuerzo = 4 Then maxEscala = modestru.graficos.maxTLosas
            If esfuerzo = 5 Then maxEscala = modestru.graficos.maxMyLosas
            If esfuerzo = 6 Then maxEscala = modestru.graficos.maxMzLosas

            ' creo la grilla

            For a = 1 To modestru.losas[l].nzGrid  ' cuadrados en direccion Z

                For b = 1 To modestru.losas[l].nxGrid 'c  ' cuadrados en la direccion X

                    '1

                    modestru.GridLosas3D(l, b - 1, a - 1, p1)

                    vEsf = modestru.EsfSecLosas(l, b - 1, a - 1, direccion, esfuerzo)
                    '
                    ScaleColorRGB(vEsf, maxEscala,, 10, c1)

                    '2

                    modestru.GridLosas3D(l, b, a - 1, p2)
                    vEsf = modestru.EsfSecLosas(l, b, a - 1, direccion, esfuerzo)

                    ScaleColorRGB(vesf, maxEscala,, 10, c2)

                    '4
                    modestru.GridLosas3D(l, b, a, P4)
                    vesf = modestru.EsfSecLosas(l, b, a, direccion, esfuerzo)

                    ScaleColorRGB(vesf, maxEscala,, 10, c4)

                    '3
                    modestru.GridLosas3D(l, b - 1, a, P3)
                    vEsf = modestru.EsfSecLosas(l, b - 1, a, direccion, esfuerzo)

                    ScaleColorRGB(vesf, maxEscala,, 10, c3)

                    ' Ahora genero el Quad Coloreado

                    GLQuadColor4F(p1, p2, p4, p3, c1, c2, c4, c3)

                Next

            Next

        End If
    Next

End

Public Sub GLQuadColor4F(p1 As Punto3d, p2 As Punto3d, p3 As Punto3d, p4 As Punto3d, Optional c1 As GLColorSt, Optional c2 As GLColorSt, Optional c3 As GLColorSt, Optional c4 As GLColorSt)

    ' Quad esta obsoleto , reemplazo por dos triangulos

    gl.begin(gl.TRIANGLES)

    Vertex3D(p1, c1)
    Vertex3D(p2, c2)
    Vertex3D(p3, c3)
    gl.End

    gl.begin(gl.TRIANGLEs)
    Vertex3D(p1, c1)
    Vertex3D(p3, c3)
    Vertex3D(p4, c4)

    gl.end

    Dim r As Float, g As Float, b As Float
    Dim n1 As New Punto3d, n2 As New Punto3d, nr As New Punto3d
    Dim CC4F As New GLColorSt

    If doVR Then

        Print #FileTriangles, "," & Format$(p1.x, "0.00") & "," & Format$(p1.y, "0.00") & "," & Format$(p1.z, "0.00") & "," & Format$(p2.x, "0.00") & "," & Format$(p2.y, "0.00") & "," & Format$(p2.z, "0.00") & "," & Format$(p3.x, "0.00") & "," & Format$(p3.y, "0.00") & "," & Format$(p3.z, "0.00")

        If c1 Then
            cc4f = c1
        Else
            cc4f = GLColor4fCurrent
        Endif

        Print #FileTriangleColors, "," & Format$(CC4F.r, "0") & "," & Format$(CC4F.g, "0.00") & "," & Format$(CC4F.b, "0.00")

        If c2 Then
            cc4f = c2

        Endif
        Print #FileTriangleColors, "," & Format$(CC4F.r, "0") & "," & Format$(CC4F.g, "0.00") & "," & Format$(CC4F.b, "0.00")

        If c3 Then
            cc4f = c3

        Endif
        Print #FileTriangleColors, "," & Format$(CC4F.r, "0") & "," & Format$(CC4F.g, "0.00") & "," & Format$(CC4F.b, "0.00")

        Print #FileTriangles, "," & Format$(p1.x, "0.00") & "," & Format$(p1.y, "0.00") & "," & Format$(p1.z, "0.00") & "," & Format$(p3.x, "0.00") & "," & Format$(p3.y, "0.00") & "," & Format$(p3.z, "0.00") & "," & Format$(p4.x, "0.00") & "," & Format$(p4.y, "0.00") & "," & Format$(p4.z, "0.00")

        If c1 Then
            cc4f = c1
        Else
            cc4f = GLColor4fCurrent
        Endif

        Print #FileTriangleColors, "," & Format$(CC4F.r, "0") & "," & Format$(CC4F.g, "0.00") & "," & Format$(CC4F.b, "0.00")

        If c3 Then
            cc4f = c3

        Endif
        Print #FileTriangleColors, "," & Format$(CC4F.r, "0") & "," & Format$(CC4F.g, "0.00") & "," & Format$(CC4F.b, "0.00")

        If c2 Then
            cc4f = c4

        Endif
        Print #FileTriangleColors, "," & Format$(CC4F.r, "0") & "," & Format$(CC4F.g, "0.00") & "," & Format$(CC4F.b, "0.00")

        ' las normales ahora se calculan en JS

        ' n1.x = p2.x - p1.x
        ' n1.y = p2.y - p1.y
        ' n1.z = p2.z - p1.z
        '
        '
        ' n2.x = p3.x - p1.x
        ' n2.y = p3.y - p1.y
        ' n2.z = p3.z - p1.z
        '
        ' modAlgebra.Cross(n1, n2, nr)
        ' Print #FileTriangleNormals, "," & Format$(nr.x, "0.00") & "," & Format$(nr.y, "0.00") & "," & Format$(nr.z, "0.00") & "," & Format$(nr.x, "0.00") & "," & Format$(nr.y, "0.00") & "," & Format$(nr.z, "0.00") & "," & Format$(nr.x, "0.00") & "," & Format$(nr.y, "0.00") & "," & Format$(nr.z, "0.00")
        '
        '
        ' n1.x = p3.x - p1.x
        ' n1.y = p3.y - p1.y
        ' n1.z = p3.z - p1.z
        '
        '
        ' n2.x = p4.x - p1.x
        ' n2.y = p4.y - p1.y
        ' n2.z = p4.z - p1.z
        '
        ' modAlgebra.Cross(n1, n2, nr)
        ' Print #FileTriangleNormals, "," & Format$(nr.x, "0.00") & "," & Format$(nr.y, "0.00") & "," & Format$(nr.z, "0.00") & "," & Format$(nr.x, "0.00") & "," & Format$(nr.y, "0.00") & "," & Format$(nr.z, "0.00") & "," & Format$(nr.x, "0.00") & "," & Format$(nr.y, "0.00") & "," & Format$(nr.z, "0.00")

        ' y las UVs

        ' TExtura hormigon vista: supongo que un cuadrado de 0.20m de la sera lo que represente mi textura , una imagen real de hormigon
        ' o sea que tendre los siguietnes casos
        ' Para encofrado comun, la textura5 es de 1mx1m, o sea hago 1 en 1

        '       p4                     p3
        '       + - - - - - - - - - - - +
        '       |0,1                 1,1|
        '       |                       |
        '       |0,0                 1,0|
        '       +-----------------------+
        '       p1                      p2
        '
        '
        '       Si p1-p4 es > 0.20m entonces el Uv es abs(p1-p4)/0.2 , idem p1-p2
        '
        Dim dx As Float, dy As Float

        dx = modAlgebra.Distancia(p1, p2)
        dy = modAlgebra.Distancia(p1, p4)

        'Debug dx, dy, P1.x, p1.y, p2.x, p2.Y, p3.x, p3.y, p4.x, p4.Y

        Print #FileUVs, "," & "0,0 , " & Format$(dx, " 0.00 ") & ",0 , " & Format$(dx, " 0.00 ") & ", " & Format$(dy, " 0.00 ")

        Print #FileUVs, ", 0,0, " & Format$(dx, " 0.00 ") & ", " & Format$(dy, " 0.00 ") & ", 0, " & Format$(dy, " 0.00 ")  'ok

    Endif

End

Public Sub glColor4f(r As Float, g As Float, b As Float, Optional Alpha As Float = 1)

    gl.Color4f(r, g, b, Alpha)
    ' ademas lo guardo

    glcolor4fcurrent.r = r
    glcolor4fcurrent.g = g
    glcolor4fcurrent.b = b
    glcolor4fcurrent.Alpha = Alpha

End
