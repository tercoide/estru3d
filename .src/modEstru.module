' Gambas module file

'
' estru3D
' Software para cálculo de estructuras mediante el método de la rigidez. Calcula estructuras tridimensionales, representa esfuerzos y solicitaciones en apoyos. Gráficas elásticas.
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 2 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
'

'Declaracion de constantes

Public Const N As Integer = 1
Public Const Qy As Integer = 2
Public Const Qz As Integer = 3
Public Const T As Integer = 4
Public Const My As Integer = 5
Public Const Mz As Integer = 6

Public Const coefgraf As Float = 1.1
Public mucho As Float = 10 ^ 200
Public Const Poco As Float = 1E-5
Public Const reticuladoplano As Integer = 1
Public Const pensando As Integer = 11
Public Const reticuladoespacial As Integer = 2
Public Const MEF As Integer = 5
Public Const serial_number As Integer = 1
Public Const porticoplano As Integer = 3
Public Const porticoespacial As Integer = 4
Public Const magic404 As String = "Estructural-4.1"
Public Const rotula As Integer = 0
Public Const empo As Integer = 1
Public Const magic As String = "Estructural-1.0"
Public Const magic2 As String = "Estructural-2.0"
Public Const magic3 As String = "Estructural-3.0"
Public Const magic4 As String = "Estructural-4.0" ' version 32 bits, distinto formato de cargas
Public Const magic5 As String = "Estructural-5.0" ' version Linux
Public Const magic6 As String = "Estructural-6.0" ' version Linux con handles
Public Const vanterior As Integer = 0
Public Const vsuperior As Integer = 1
Public Const vlateral As Integer = 2
Public Const caballera As Integer = 3
Public Const isometrica As Integer = 4
Public Const impresora As Integer = 1
Public Const pantalla As Integer = 2
Public Const check_nudos As Integer = 1
Public Const check_barras As Integer = 2
Public Const check_apoyos As Integer = 4
Public Const check_datos As Integer = 8
Public Const check_vars As Integer = 16
Public Const modo_design As Integer = 0
Public Const modo_calculo As Integer = 1
Public Const modo_real As Integer = 2
Public Const modo_ayuda As Integer = 3

Public Const tipo_indef As Integer = 0
Public Const tipo_columna As Integer = 1
Public Const tipo_viga As Integer = 2
Public Const tipo_losa As Integer = 3
Public Const tipo_tabique As Integer = 4
Public Const tipo_xxx As Integer = 5

' errores
Public Const error_nudossueltos As Integer = 1
Public Const error_nudosduplicados As Integer = 2
Public Const error_nudosinsuficientes As Integer = 4
Public Const error_barrasinsuficientes As Integer = 8
Public Const error_barrassueltas As Integer = 16
Public Const error_barrassindatos As Integer = 32
Public Const error_apoyosinsuficientes As Integer = 32
Public Const error_rotulas As Integer = 64
Public Const error_nimayor As Integer = 128
Public Const PUNTUAL As Integer = 1
Public Const REPTOT As Integer = 2
Public Const REPpar As Integer = 3
Public Const tem As Integer = 4
Public Const pxy As Integer = 1
Public Const pxz As Integer = 2

Public tipocarga As Integer
Public plano As Integer

'Declaracion de variables de ambiente

Public paso_p As Long
Public paso_q As Long
Public paso_n As Integer
Public paso_t As Long
Public paso_qc As Long

Public paso_pc As Long
Public paso_pe As Long
Public totalqc As Long
Public totalpc As Long
Public totalpe As Long
Public porcentaje As Long 'esto lo paso al C
Public auxiliar1 As String = Space$(1240)

' zooms
'Public rectangulo.x0 As Single, rectangulo.y0 As Single, rectangulo.x1 As Single, rectangulo.y1 As Single

Public zooming As Integer
Public anterior_barrita As Integer
Public ZOOMED As Integer
Public use_filter As Integer
Public filter_x0 As Float
Public filter_x1 As Float
Public filter_y0 As Float
Public filter_y1 As Float
Public filter_z0 As Float
Public filter_z1 As Float

Public Struct extremosStruct
    empoempo As String
    empofijo As String
    fijoempo As String
    fijofijo As String
    tensor As String
End Struct

' factores para las unidades
Public pirata As Integer
Public pasolon As Float
Public tipodia As Integer
Public ordmatrig As Integer
Public estructura As Integer

'
Public escribiendo As Integer
Public textgrid As String
Public egc As Integer
Public egr As Integer

Public a_abrir As String
Public vermatriz As Integer
Public viendomatrig As Integer
Public pathproys As String

'Declaracion de variable tipo
'
''================================================================
' Nuevos tipos

Public Struct envolventestype4
    Estado As Integer       ' estado o combinacion que se calcula ademas
    peso_propio As Boolean  'uso ademas esto
    paso_puntuales As Float
    paso_repartida As Float
    tiempo_minimo As Float 'espera entre pasos del tren
    secciones As Float ' puede ser secciones por barra o cada cuanto
    usar_tren As Boolean
    usar_repartida As Boolean
    nCargas As Integer
    repartida As Float
    EjesGlobales As Integer

End Struct

Public Struct flechatype4
    fy As Float
    fz As Float
End Struct

Public Struct segordtype4    ' son los dos momentos que se ue
    My As Float
    Mz As Float
End Struct

Public Struct gruposSTRUCT
    nombre As String ' * 30 'TODO
    tipo As Integer '1=viga, 2=losa, 3=fundacion
    seccion As Integer
    material As Integer
    xg As Float    ' son las coord del centro de gravedad, para
    yg As Float    ' poder graficar el numero
    zg As Float
    aux3 As Float
    aux4 As Float
    aux5 As Float
End Struct

Public Struct informeSTRUCT
    encabezado1 As String '* 80
    encabezado2 As String '* 80
    encabezado3 As String '* 80
    encabezado4 As String '* 80
    logo As String '* 128 ' nombre del archivo
    pie1 As String '* 80
    pie2 As String '* 80
    pie3 As String '* 80
    pie4 As String '* 80
    au1 As String '*  256 ' aux
    au2 As String '* 256 ' aux
End Struct

Public Struct colorStruct
    barras As Integer
    columnas As Integer
    seleccion As Integer

    N As Integer
    Qy As Integer
    Qz As Integer
    T As Integer
    My As Integer
    Mz As Integer

    elastica As Integer
    tension As Integer
End Struct

Public Struct zoomSTRUCT
    FiltroSector As Integer
    FiltroTipo As Integer
    barra_larga As Single ' la barra más larga
    barra_corta As Single ' la mas corta
    maxe As Single
    maxMz As Single
    maxMy As Single
    maxT As Single     ' maximos valores absolutos [en nudos]
    maxQz As Single    ' 28 bytes
    maxQy As Single     ' los obtengo depues de calcular
    maxN As Single

    maxELosas As Single
    maxMzLosas As Single
    maxMyLosas As Single
    maxTLosas As Single     ' maximos valores absolutos [en nudos]
    maxQzLosas As Single    ' 28 bytes
    maxQyLosas As Single     ' los obtengo depues de calcular
    maxNLosas As Single

    ESCe As Single
    ESCmz As Single
    ESCmy As Single
    ESCt As Single     ' estas son las escalas particularesde cada esf
    ESCqz As Single    ' 28 bytes
    ESCqy As Single
    ESCn As Single

    e As Boolean
    Mz As Boolean
    My As Boolean
    t As Boolean        ' aca se determina si muestro o no
    Qz As Boolean       ' 7 bytes
    Qy As Boolean
    n As Boolean

    eMz As Boolean
    eMy As Boolean
    et As Boolean        ' aca se determina si muestro o no
    eQz As Boolean       ' 7 bytes
    eQy As Boolean
    en As Boolean

    ultimo As String ' * 20 ' último boton presionado

    escala_esf As Single ' escala general de esfuerzos

    cambios As Boolean

    largo_estructura As Single

    ZoomActual As Integer
    ZoomUltimo As Integer

    x0 As Float
    y0 As Float
    fMax As Float

    sedibujanejes As Integer
    SeDibujanNudos As Integer
    sedibujanbarras As Integer
    SeDibujanCargas As Integer
    SeDibujanApoyos As Integer

    SeDibujanSubElementos As Boolean
    SeDibujanSeccciones As Boolean

    FactorFlecha As Float
    vista As Integer
    ColorBarras As Long
    ColorApoyos As Long
    colorflecha As Long

    render As Boolean
    wireframe As Boolean
    colores As Struct ColorStruct

    DibujarDetalles As Boolean

End Struct

Public Struct unidadesSTRUCT
    '  TODO
    long_nombre As String ' metr , cmtr, inch, feet
    peso_nombre As String ' kilo, tons, poun, kntw 'no guardo mas un "indice" , solo guardo los nombres en 4 carcteres
    ang_nombre As String  ' grad , rads
    factorEG As Float          '8
    factorSUP As Float         '8
    factorDEN As Float         '8
    factorLONG As Float        '8
    factorANG As Float         '8  agregue 40 bytes--> total 64 bytes
End Struct

Public Struct datosSTRUCT
    ' Parametros del PROYECTO en cuestion, que deben guardarse en el proyecto.

    magic As String
    proyecto As String
    descripcion As String

    totalcargasnudo As Integer
    totalcargasplacas As Integer
    totalplacas As Integer
    TotalGrupos As Integer

    totalSectores As Integer
    tipo As Integer
    totalcargasbarra As Integer
    unidades As Struct UnidadesSTRUCT
End Struct

Public Struct settingsSTRUCT
    ' esta estructura debera alojar todos lo parametros relativos a Estru3D y la PC en que corre.

    PasoCalcularEsfuerzos As Long
    PuntosInterpolados As Integer 'los puntos en que interpolo en la grid de losas
    PasoGrid As Integer
    PasoEsf As Long     ' 4 cuantas flechitas por barra
    Pasocargarep As Long                 ' 4 cuantas flechitas por barra
    IntervaloElastica As Integer    '
    formato As String
    formato_datos As String
    lastopen1 As String
    lastopen2 As String
    lastopen3 As String
    lastopen4 As String
    lastopen5 As String
    lenguaje As Integer

    solver As String

End Struct

Public Struct maxSTRUCT
    p As Float
    n As Float
    e As Float
End Struct

Public Struct estadoSTRUCT
    usar As Integer
    coef As Float
End Struct

Public Struct flagsSTRUCT
    LogFile As File   ' 0 = cerrado
    LogFileName As String
    Perfil As Integer
    Pausa As Boolean
    PerfilTipo As String
    LogOn As Boolean
    palabra_clave As String
    lenguaje As String
    parar_calculos As Integer
    carga As Integer
    barra As Integer
    nudo As Integer
    material As Integer
    dibujar As Boolean
    Calculando As Boolean
    CalculandoEnvolventes As Boolean
    CalculandoSismos As Boolean
    CalculadoSismos As Boolean
    checked As Boolean ' la uso para no chequearla muchas veces
    ayuda_ok As Boolean
    redibujar As Boolean
    calculo_tipo As Integer
    seccion As String
    dibujado As Boolean
    dibujable As Boolean
    calculado As Boolean
    CalculadoEnvolventes As Boolean
    resultado As Integer
    modo As Integer
    cambios As Boolean
    dibujando As Integer
    ayuda As String
    ayuda_mostrar As Boolean
    Estado As Integer
    ' control del texto en la linea de entrada
    Entrada As String
    EntradaLista As Boolean
    EntradaCancel As Boolean
    asistente_copletado As Integer
    asistente_actual As Integer
    MostrarDespuesCalculo As Integer
    OcultarCargas As Boolean

    estadoAccidental As Integer
    estadoPermanente As Integer

End Struct

Public Struct SismoStruct

    frecuencia As Float
    duracion As Float
    amplitud As Float
    subFrecuencia As Float
    direccion As Float
    dt As Float
    amortiguacion As Float

End Struct

'nuevos arrays para losas

Public vigas As New ClsViga[]

Public losas As New ClsLosa[]

Public LosasPuntos As New Float[][][]

Public tabiques As New ClsTabique[]

Public sisMasas As New Float[]
Public sisFuerzas As New Float[]
Public sisDezplazamientos As New Float[]
Public sisMovimiento As New Float[]

Public sSismo As New SismoStruct

Public flags As New FlagsSTRUCT

'Public extremos as new ExtremosStruct

Public graficos As New ZoomSTRUCT
Public informe As New InformeSTRUCT
Public setting As New SettingsSTRUCT

'Declaracion de arrays
'TODO
Public estados_nombre As New String[21]  ' * 30 ' =120
Public extremos As New String[5]  ' * 6

Public barra As New Collection
Public nudo As New Collection

Public combinacion As New Float[11, 11]
Public secciones As New Collection

Public material As New Collection
Public Grupos As New GruposSTRUCT[] ' new 2017

Public datos As New DatosSTRUCT

'acumuladores de escfuerzos en secciones de barras, estoy arrays pueden ser gigantes
Public EsfSecArray As New Float[]
Public EsfSecArrayPos As New Float[]
Public EsfSecArrayNeg As New Float[]

'acumuladores de escfuerzos en Losas, estoy arrays pueden ser gigantes

Public GridLosasIndex As New Integer[]
Public arrGridLosas As New Float[]

Public EsfSecArrayLosasIndex As New Integer[]
Public EsfSecArrayLosas As New Float[]
Public EsfSecArrayPosLosas As New Float[]
Public EsfSecArrayNegLosas As New Float[]

' Envolventes y tren de cargas
Public envolventes As New Envolventestype4
Public trenCargas As New Float[]
Public trenDistancia As New Float[]
Public Camino As New Integer[]

' elementos de array, pero Unitarios

Public maximos As New MaxSTRUCT[] ' TODO esto iba de -6 a 8

'vectores para la elastica, limito a 101 puntos por barra (10 suelen ser suficientes)
Public vectorE As New Punto3d[]
Public elasticaXcargas As New Punto3d[]
Public elastica As New Punto3d[]

Public Parametros As New Settings(User.Home &/ ".estru3d/estru3d.conf", "Parametros de Estru3D")

Public Tutoriales As New Settings
Public Mats As New Settings(User.Home &/ ".estru3d/Librerias/materiales.estru3d-lib", "Materiales")

' variables globales de graficos

Public Sub PonerEnCero()
    ' pongo en cero todos los valores de todo lo que hay
    ' Esta rutina deberia llamarse cuando arranca el programa y antes de
    ' crear un proyecto nuevo, y de llamar al asistente. El asistente
    ' automaticamente crea un nuevo proyecto.

    Dim o As Integer, oo As Integer, a As Integer, e As Integer, b As Integer
    Dim hkey As String, resultado As String

    fmain.debuginfo("Poniendo en cero")

    setting.pasocargarep = 20 '
    setting.IntervaloElastica = 10 '
    setting.PasoCalcularEsfuerzos = 25 ' cuantas secciones por barra se evaluan
    setting.PasoEsf = 20 'cuando dibujo esfuerzos, este es la cantidad de flechitas que grafico

    ordmatrig = 0
    estructura = 0
    modCalculus.gr = 0
    flags.Estado = 1

    graficos.sedibujanejes = True
    graficos.SeDibujanApoyos = True
    graficos.SeDibujanCargas = True
    graficos.SeDibujanNudos = True
    graficos.sedibujanbarras = True
    graficos.vista = 0
    graficos.fMax = 0

    escribiendo = 0
    textgrid = ""
    egc = 0
    egr = 0
    datos.proyecto = ""
    datos.unidades.factorEG = 1
    datos.unidades.factorSUP = 1
    datos.unidades.factorLONG = 1
    datos.unidades.factorDEN = 1
    datos.unidades.ang_nombre = "rads"
    datos.unidades.long_nombre = "metr"
    datos.unidades.peso_nombre = "kilo"
    datos.descripcion = ""

    barra.Clear
    nudo.Clear

    trenCargas.Clear
    trenDistancia.Clear
    losas.Clear
    vigas.Clear
    tabiques.Clear

    datos.tipo = 0

    datos.tipo = porticoespacial
    tipocarga = 0
    plano = 0

    modCalculus.vecesf.Fill(0)
    modCalculus.VecAux.Fill(0)
    modCalculus.vecCarBar.Fill(0)
    modCalculus.vecdezbar.Fill(0)
    modCalculus.mataux.Fill(0)
    modCalculus.matrot.Fill(0)
    modCalculus.matrotT.Fill(0)

    estados_nombre[1] = ("Peso propio")
    estados_nombre[2] = ("Permanente")
    estados_nombre[3] = ("Accidental")
    flags.estadoAccidental = 3
    flags.estadoPermanente = 2
    For o = 4 To 10
        estados_nombre[o] = ("Estado") & Str$(o)
    Next

    For o = 11 To 20
        estados_nombre[o] = ("Combinacion") & Str$(o - 10)
    Next

    pasolon = 0
    tipodia = 0
    'Screen.MousePointer = 0

    'envolventes
    envolventes.repartida = 0
    envolventes.nCargas = 00
    trenCargas.Clear
    trenDistancia.Clear
    Camino.Clear
    envolventes.paso_puntuales = 0
    envolventes.paso_repartida = 0
    datos.proyecto = User.Home &/ "estru3d" &/ "calculo1.ce5"
    flags.dibujado = False
    flags.dibujando = False
    flags.calculando = False
    flags.calculado = False
    flags.cambios = False
    'fmain.gEstru.Clear
    flags.modo = 0 ' disenio
    graficos.cambios = True
    ' cargo los materiales

    '2020
    modUtils.ResizeStruct(maximos, 101)
    modUtils.ResizeStruct(vectorE, 101)
    modUtils.ResizeStruct(elasticaXcargas, 101)
    modUtils.ResizeStruct(elastica, 101)
    calcular_factores ' esto corrige problemas con los factores

    mats_load2()

End Sub

Public Function barras_coincidentes(Optional modo As Integer = 1) As Integer
    ' ' esta rutina corrige el problema de barras en el mismo lugar físico
    ' ' devuelve el total de barras eliminadas
    '
    ' Dim a As Integer, b As Integer, c As Integer, d As Integer, t As Integer
    ' ' modo=1 se elimina la segunda barra
    ' ' modo=2 se suman  los datos de las barras antes de eliminar
    ' ' modo=3 se promedian
    '
    ' ' V4  modo es obsoleto porque ahora defino mats y secciones
    ' a = 0
    ' Do
    '     If a >= (barra.max - 1) Then Break
    '     a = a + 1
    '     b = a
    '     Do
    '         If b >= barra.Max Then Exit
    '         b = b + 1
    '         If ((barra[a].ni = barra[b].ni) And (barra[a].nF = barra[b].nF)) Or ((barra[a].ni = barra[b].nf) And (barra[a].nF = barra[b].ni)) Then
    '             'es coincidente
    '             t = t + 1
    '             ' Eleimino la barra segun la siguiente prelacion
    '             'tabique
    '             'columa
    '             'viga
    '             'losa
    '             'barra simple
    '             'If (barra[a].ni = 629) And (barra[a].nf = 714) Then Stop
    '
    '             If barra[b].Invertida Then barra[a].Invertida = True
    '             If barra[b].tipo = tipo_indef Then
    '                 EliminarBarra(b)
    '             Else If (barra[b].tipo = tipo_losa) And ((barra[a].tipo = tipo_viga) Or (barra[a].tipo = tipo_tabique)) Then
    '                 If barra[B].restriccion > 0 Then Stop
    '                 EliminarBarra(b)
    '             Else If (barra[b].tipo = tipo_viga) And (barra[a].tipo = tipo_tabique) Then
    '                 EliminarBarra(b)
    '             Else
    '                 EliminarBarra(a)
    '             End If
    '
    '             a = a - 1
    '         End If
    '     Loop
    ' Loop
    ' flags.cambios = True
    ' ' y tiene que recalcular
    ' flags.calculado = False
    ' fmain.SetStatus
    ' Debug t
    '
    ' Return t

End Function

Public Function ColinealBars(Optional modo As Integer) As Integer
    '     ' Look for superposed bars, blend them in such case
    '
    '     'VERY IMPORTANT,
    '
    '     Dim a As Integer, b As Integer, Found As Boolean, d As Integer, t As Integer, nt As Integer
    '     ' modo=1 se elimina la segunda barra
    '     ' modo=2 se suman  los datos de las barras antes de eliminar
    '     ' modo=3 se promedian
    '
    '     'we need to check for unused stuff first
    '
    '     If barra.Count = 0 Then Return
    '
    '     modestru.flags.dibujable = False
    '
    '     a = 1 'first bar
    '     Do
    '
    '         fmain.debugInfo(("Verificando barras colineales") & Format$(a / barra.Count, "0%"), True)
    '
    '         Found = False
    '         For b = 1 To modEstru.nudo.max
    '
    '             'check if node is in between the bar
    '             If modAlgebra.IsBetween(nudo[barra[a].ni], nudo[barra[a].nf], nudo[b], 0.0005) Then
    '
    '                 ' we need to split that bar, but only if it's not one of then
    '
    '                 If b <> barra[a].ni And b <> barra[a].nf Then
    '
    '                     If modAlgebra.Distancia(nudo[barra[a].ni], nudo[b]) < 0.0005 Then Goto NudosJuntos
    '                     If modAlgebra.Distancia(nudo[barra[a].nf], nudo[b]) < 0.0005 Then Goto NudosJuntos
    '
    '                     'now we split the bar
    '
    '                     d = AddBarra(b, barra[a].nF, barra[a].seccion, barra[a].material,, False) 'NO chequear x existentes
    '
    '                     barra[a].nf = b
    '
    '                     barra[d].grupo = barra[a].grupo
    '                     barra[d].sector = barra[a].sector
    '                     barra[d].tipo = barra[a].tipo
    '                     barra[d].restriccion = barra[a].restriccion
    '                     Found = True
    '                     t += 1
    '
    '                     Break
    '
    '                 End If
    '
    '             Endif
    '
    '         Next
    '         If Not Found Then a += 1
    '
    '     Loop Until a > barra.Count
    '
    '     ' now we need to remove those bars in the same place again
    '
    '     flags.cambios = True
    '     ' y tiene que recalcular
    '     flags.calculado = False
    '     fmain.debugInfo(("Encontradas ") & Format$(t, "0"), False)
    '
    '     Return t
    '
    ' NudosJuntos:
    '
    '     fmain.debugInfo(("Hay nudos demasiado juntos, eliminar nudos duplicados primero"), False)
    '     Return -1

End Function

Public Sub CorregirNumeracionBarras()

    For Each bar As Clsbarra In barra
        If nudo[bar.ni].indice > nudo[bar.nF].indice Then
            Swap bar.ni, bar.nf

            bar.Invertida = True
        Endif

    Next

End Sub

Public Function cpVal(numero As String) As Float

    Dim p As Integer, separador As String, busco As String
    Dim fPi As Float

    ' Reemplaza las , por . y saca el Val
    fpi = Pi  '3,1415 blablabla

    separador = Mid$(Trim$(Str$(fpi)), 2, 1)
    If separador = "," Then busco = "." Else busco = ","

    Do
        p = InStr(numero, busco)
        If p > 0 Then
            Mid$(numero, p, 1) = separador
        Else
            Exit
        End If
    Loop
    Try Return Val(numero)

End Function

Public Function cargar5(archivo As String) As Integer
    'On Error GoTo quepasoaca

    Dim t As Integer, sinerror As Integer, codigo As Integer
    Dim a As Integer, b As Integer, ok As Boolean, sdk As String
    Dim f As File, magia As String, entry As String

    Dim l1 As New ClsLosa
    Dim v1 As New ClsViga
    Dim apoyoU As ClsApoyo
    Dim nudou As ClsNudo
    Dim barrau As ClsBarra
    Dim seccu As ClsSeccion
    Dim cnu As ClsCargaNudo
    Dim cbu As ClsCargaBarra

    sinerror = True
    codigo = True   'supongo todo ok
    magia = Space$(15)

    'Stop
    fmain.debuginfo(("Abriendo archivo ") & archivo)

    If LCase$(Right$(archivo, 3)) = "dxf" Then
        'If fActivProce(archivo) Then 'TODO ver modulo DXF
        '    gGravResult
        '    Goto saliendos:
        'Else
        '    Goto quepasoaca:
        'End If
    End If
    If Not Exist(archivo) Then Goto quepasoaca

    f = Open archivo For Read

    If sinerror Then

        Input #f, magiA
        If magia <> magic5 Then
            Message.Warning(("Archivo no válido"))
            Return False
        Else
            datos.magic = magia
        End If

        Do
            If Eof(f) Then Exit
            Line Input #f, entry
            'If entry <> "" Then Exit
            entry = Trim$(entry)

            Select Case LCase$(modUtils.getparam(entry, 1))
                Case "nodes"

                    'nudo.max = CInt(modUtils.getparam(entry, 2))

                Case "desc"
                    datos.descripcion = modUtils.getparam(entry, 2)
                Case "bars"
                    'barra.Count = CInt(modUtils.getparam(entry, 2))

                Case "slabs"
                    datos.totalplacas = CInt(modUtils.getparam(entry, 2))
                Case "groups"
                    datos.TotalGrupos = CInt(modUtils.getparam(entry, 2))
                Case "sectors"
                    datos.totalSectores = CInt(modUtils.getparam(entry, 2))
                Case "shapes"
                    ' 2020 no interesa mas este dato
                    'secciones.count = CInt(modUtils.getparam(entry, 2))

                    'secciones.Resize(secciones.count + 1)
                    'secciones.Fill(seccU)

                Case "nloads"
                    datos.totalcargasnudo = CInt(modUtils.getparam(entry, 2))

                Case "bloads"
                    datos.totalcargasbarra = CInt(modUtils.getparam(entry, 2))

                Case "ploads"
                    datos.totalcargasplacas = CInt(modUtils.getparam(entry, 2))
                Case "tloadrep"
                    envolventes.repartida = CFloat(modUtils.getparam(entry, 2))

                Case "restrs"
                    'datos.totalapoyos = CInt(modUtils.getparam(entry, 2))

                Case "type"
                    datos.tipo = CInt(modUtils.getparam(entry, 2))
                Case "units"
                    With datos.unidades
                        .long_nombre = modUtils.getparam(entry, 2)
                        .peso_nombre = modUtils.getparam(entry, 3)
                        .ang_nombre = modUtils.getparam(entry, 4)
                    End With

                Case Like "nstate*"

                    a = Val(Mid$(modUtils.getparam(entry, 1), 7))
                    estados_nombre[a] = modUtils.getparam(entry, 2) ' & modUtils.getparam(entry, 3)

                Case Like "mstate*"

                    a = Val(Mid$(modUtils.getparam(entry, 1), 7))

                    For b = 1 To 10
                        combinacion[a, b] = CFloat(modUtils.getparam(entry, b + 1))
                    Next

                Case "node"

                    nudou = Null
                    nudou = New ClsNudo ' Punto3d 'nudotype4
                    nudou.handle = CStr(nudo.Count + 1)
                    nudo.add(nudou, CStr(nudo.Count + 1))

                    With nudoU
                        .x = CFloat(modUtils.getparam(entry, 2))
                        .y = CFloat(modUtils.getparam(entry, 3))
                        .z = CFloat(modUtils.getparam(entry, 4))
                        '.grupo = cint(modUtils.getparam(entry, 5))
                        '.sector = cint(modUtils.getparam(entry, 6))
                        'FMain.debugInfo("nudo", .x, .y, .z, .grupo, .sector)
                    End With

                Case "bar"
                    barrau = Null
                    barrau = New ClsBarra
                    barrau.handle = CStr(barra.Count + 1)   ' en este momento .Count es 0

                    With barrau

                        .ni = (modUtils.getparam(entry, 2))
                        .nf = (modUtils.getparam(entry, 3))
                        .material = (modUtils.getparam(entry, 4))
                        .seccion = (modUtils.getparam(entry, 5))
                        .restriccion = CInt(modUtils.getparam(entry, 6))
                        .grupo = CInt(modUtils.getparam(entry, 7))
                        .sector = CInt(modUtils.getparam(entry, 8))
                        .tipo = CInt(modUtils.getparam(entry, 9))
                        .Invertida = -CInt(modUtils.getparam(entry, 10))
                        .Eje = CInt(modUtils.getparam(entry, 11))
                        .PosX = CInt(modUtils.getparam(entry, 12))
                        .PosZ = CInt(modUtils.getparam(entry, 13))

                        'FMain.debugInfo("barra", .ni, .nf, .material, .seccion, .restriccion, .grupo, .sector)
                    End With
                    barra.Add(barraU, CStr(barra.Count + 1))
                    ' TODO aca iria la seccion de Placas
                    ' TODO aca iria la seccion de Grupos
                    ' TODO aca iria la seccion de Sectores

                Case "restr"
                    ' ahora los apoyos pertenecen a los nudos
                    ' debo encontrar el nudo en la Coleccion
                    ' de nudos, que ya esta cargada
                    If nudo.Exist(modUtils.getparam(entry, 2)) Then     ' verifico que el nudo exista

                        Nudo[modUtils.getparam(entry, 2)].apoyo = New ClsApoyo
                        With Nudo[modUtils.getparam(entry, 2)].apoyo
                            .rx = CFloat(modUtils.getparam(entry, 3))
                            .ry = CFloat(modUtils.getparam(entry, 4))
                            .rz = CFloat(modUtils.getparam(entry, 5))
                            .rmx = CFloat(modUtils.getparam(entry, 6))
                            .rmy = CFloat(modUtils.getparam(entry, 7))
                            .rmz = CFloat(modUtils.getparam(entry, 8))

                            'fmain.debugInfo("apoyo", .nudo, .rx, .ry, .rz, .rmx, .rmy, .rmz)
                        End With
                    End If

                Case "slab"
                    'Print #f, "Slabs", "name", "p1", "p2, " p3 ", " p4 ", "e
                    l1 = Null
                    l1 = New ClsLosa
                    With l1
                        .nombre = modUtils.getparam(entry, 2)
                        .numero = CInt(modUtils.getparam())
                        .piso = CInt(modUtils.getparam())
                        .sector = CInt(modUtils.getparam())
                        .Nudo1 = (modUtils.getparam())
                        .Nudo2 = (modUtils.getparam())
                        .Nudo3 = (modUtils.getparam())
                        .Nudo4 = (modUtils.getparam())
                        .d = CFloat(modUtils.getparam())
                        .material = (modUtils.getparam())
                        .g = CFloat(modUtils.getparam())
                        .p = CFloat(modUtils.getparam())
                        .alivianado = CFloat(modUtils.getparam())
                        .dxGrid = CFloat(modUtils.getparam())
                        .dzGrid = CFloat(modUtils.getparam())
                        .nxGrid = CFloat(modUtils.getparam())
                        .nzGrid = CFloat(modUtils.getparam())
                        ' If .alivianado = 0 Then .alivianado = 1
                    End With

                    losas.Add(l1)
                Case "wall"

                    modUtils.AddStruct(tabiques)
                    With tabiques[tabiques.max]
                        .nombre = modUtils.getparam(entry, 2)
                        .numero = CInt(modUtils.getparam())
                        .piso = CInt(modUtils.getparam())
                        .sector = CInt(modUtils.getparam())
                        .Nudo1 = CInt(modUtils.getparam())
                        .Nudo2 = CInt(modUtils.getparam())
                        .Nudo3 = CInt(modUtils.getparam())
                        .Nudo4 = CInt(modUtils.getparam())
                        .d = CFloat(modUtils.getparam())
                        .material = CInt(modUtils.getparam())
                        .g = CFloat(modUtils.getparam())
                        .p = CFloat(modUtils.getparam())

                    End With

                Case "beam"

                    v1 = Null
                    v1 = New ClsViga

                    v1.nombre = modUtils.getparam(entry, 2)
                    v1.numero = CInt(modUtils.getparam(entry, 3))
                    v1.piso = CInt(modUtils.getparam(entry, 4))
                    v1.sector = CInt(modUtils.getparam(entry, 5))
                    v1.nudo1 = (modUtils.getparam(entry, 6))
                    v1.nudo2 = (modUtils.getparam(entry, 7))
                    v1.seccion = (modUtils.getparam(entry, 8))
                    v1.g = CFloat(modUtils.getparam(entry, 9))
                    vigas.Add(v1)

                Case "nload"

                    cnu = New ClsCargaNudo
                    Nudo[modUtils.getparam(entry, 2)].cargas.add(cnu)
                    With Nudo[modUtils.getparam(entry, 2)].cargas.Last
                        .fx = CFloat(modUtils.getparam(entry, 3))
                        .fy = CFloat(modUtils.getparam(entry, 4))
                        .fz = CFloat(modUtils.getparam(entry, 5))
                        .mx = CFloat(modUtils.getparam(entry, 6))
                        .my = CFloat(modUtils.getparam(entry, 7))
                        .mz = CFloat(modUtils.getparam(entry, 8))
                        .Estado = CInt(modUtils.getparam(entry, 9))
                        'fmain.debugInfo("Carganudo", .nudo, .fx, .fy, .fz, .mx, .my, .mz, .Estado)
                    End With

                Case "bload"
                    cbu = New ClsCargaBarra
                    If barra.Exist(modUtils.getparam(entry, 2)) Then
                        Barra[modUtils.getparam(entry, 2)].cargas.add(cbu)
                        With Barra[modUtils.getparam(entry, 2)].cargas.Last
                            '.barra = CInt(modUtils.getparam(entry, 2))
                            .tipo = CInt(modUtils.getparam(entry, 3))
                            .px = CFloat(modUtils.getparam(entry, 4))
                            .py = CFloat(modUtils.getparam(entry, 5))
                            .pz = CFloat(modUtils.getparam(entry, 6))
                            .a = CFloat(modUtils.getparam(entry, 7))
                            .b = CFloat(modUtils.getparam(entry, 8))
                            .c = CFloat(modUtils.getparam(entry, 9))
                            .e = CFloat(modUtils.getparam(entry, 10)) 'estado

                        End With
                    End If

                Case "tload"
                    trenCargas.Add(CFloat(modUtils.getparam(entry, 2)))
                    trenDistancia.Add(CFloat(modUtils.getparam(entry, 3)))

                Case "tpathbar"
                    camino.Add(CInt(modUtils.getparam(entry, 2)))
                Case "tstep"
                    envolventes.paso_puntuales = CFloat(modUtils.getparam(entry, 2))
                Case "tloadrep"
                    envolventes.repartida = CFloat(modUtils.getparam(entry, 2))

                Case "shape"
                    seccu = Null
                    seccu = New ClsSeccion
                    With seccu
                        .nombre = modUtils.getparam(entry, 2)
                        .tipo = modUtils.getparam(entry, 3)
                        .area = CFloat(modUtils.getparam(entry, 4))
                        .Ip = CFloat(modUtils.getparam(entry, 5))
                        .iy = CFloat(modUtils.getparam(entry, 6))
                        .iz = CFloat(modUtils.getparam(entry, 7))
                        .Wp = CFloat(modUtils.getparam(entry, 8))
                        .wy = CFloat(modUtils.getparam(entry, 9))
                        .wz = CFloat(modUtils.getparam(entry, 10))
                        .a = CFloat(modUtils.getparam(entry, 11))
                        .b = CFloat(modUtils.getparam(entry, 12))
                        .c = CFloat(modUtils.getparam(entry, 13))
                        .d = CFloat(modUtils.getparam(entry, 14))
                        .e = CFloat(modUtils.getparam(entry, 15))
                        .f = CFloat(modUtils.getparam(entry, 16))
                        'fmain.debugInfo("Seccion", .nombre, .tipo, .area, .Ip, .iy, .iz, .Wp, .wy, .wz, .a, .b, .c, .d, .e, .f)
                    End With
                    seccu.handle = CStr(secciones.Count + 1)   ' en este momento .Count es 0

                    secciones.Add(seccu, CStr(secciones.Count + 1))

            End Select
        Loop

    End If
    Close f

    fmain.debuginfo(("Se abrio exitosamente"))
    fmain.debuginfo(("Tipo de estructura: ") & Str$(datos.tipo))
    fmain.debuginfo(("Nodos:") & Str$(modEstru.nudo.count))
    fmain.debuginfo(("Barras:") & Str$(modestru.barra.count))
    fmain.debuginfo(("Cargas:") & Str$(datos.totalcargasbarra + datos.totalcargasnudo))
    'fmain.debuginfo(("Apoyos:") & Str$(apoyos.count))

    ' pongo lo que cargue en las tablas

    'TODO

saliendos:

    ' modgraphics.ResetMatrizRotacion  'TODO implementar

    'ok = chequeoestructura(check_vars Or check_barras Or check_nudos)

    ' verifico los materiales y los pongo en unitario
    t = get_material("unitario")
    If t = 0 Then t = 1 ' por si no tiene definido un mat unitario
    For a = 1 To barra.count
        If barra[a].material = "" Then
            barra[a].material = t
            flags.cambios = True
        End If
    Next

    Return codigo

quepasoaca:
    'esta es la rutina de errores
    ' debería seleccionar el tipo de error y avisar
    'pero no tengo ganas,asi que voy a devolver el error

    fmain.debuginfo(("Hubo un problema al abrir."), Logger.Error)
    sinerror = False
    codigo = Error
    Return

End Function

Public Function chequeoestructura(tipo As Integer, Optional detallado As Boolean = False, Optional Reparar As Boolean = False) As Integer
    ' lo que voy a ver es:
    '   + si tiene los datos de las barras completos
    '   + si existen los nudos de cada barra
    '   + si no hay nudos sueltos
    '
    '----------------------------------------------------
    ' PROCESO COMUN PARA TODOS LOS TIPOS

    'On Error Resume Next
    ' TODO Try?
    Dim xxx As Float, ok As Integer, a As Integer, tabien As Boolean, ok2 As Integer
    Dim t1 As Date
    Dim TotalSectores As Integer
    Dim n As ClsNudo, b As ClsBarra
    Dim hNudo, hBarra As String

    ok = 0

    ' ERRORES CRITICOS: los chequeo si o si
    ' chequeo que todas las variables tengan valores correctos o tolerables
    ' valores minimos en las variables almacenadas en 'datos'
    If (datos.tipo <= 0) Then datos.tipo = 1

    'If datos.totalcargasplacas = 0 Then ok = 1

    ' idem opcionales
    If flags.asistente_actual < 0 Then flags.asistente_actual = 0
    If flags.asistente_copletado < 0 Then flags.asistente_copletado = 0

    '
    SetGL

    If (tipo And check_nudos) = check_nudos Then
        ' tiene suficientes?
        If nudo.Count < 2 Then
            ok = ok Or error_nudosinsuficientes
            'GoTo salida:
        End If
        ' estan todos ocupador

        a = 0
        For Each n In nudo
            hnudo = n.handle
            Inc a
            fmain.debuginfo(("Chequeando nudos ") & Format$(a / nudo.count, "0%"), True)
            ok2 = False
            For Each b In barra
                If b.ni = hNudo Then
                    ok2 = True
                    Break
                End If
                If b.nf = hNudo Then
                    ok2 = True
                    Break
                End If
            Next
            If ok2 = False Then
                ' el nudo no esta ocupado
                ok = ok Or error_nudossueltos
                fmain.debuginfo((" nudo suelto ") & hNudo, True, True)

                If Reparar Then
                    nudo[n.hNudo] = Null 'EliminarNudo](a)
                    fmain.debuginfo("(eliminado)", False, True)

                Endif
            End If

        Next

    End If
    fmain.debuginfo(" ")
    If (tipo And check_barras) = check_barras Then

        If barra.Count < 1 Then
            ok = ok Or error_barrasinsuficientes
            'GoTo salida:
        End If
        a = 0
        For Each b In barra
            Inc a
            fmain.debuginfo(("Chequeando barras: ") & Format$(a / barra.Count, "0%"), True)
            If b.sector > totalsectores Then totalSectores = barra[a].sector
            ' If barra[a].nF < barra[a].ni Then
            '
            '     ok = ok Or error_nimayor
            '     fmain.debuginfo((" barra con ni>nf ->") & Format$(a, "0"), True, False)
            '     fmain.debuginfo("->", False, False)
            '
            ' End If

            If Not (nudo.Exist(b.nF) Or nudo.Exist(b.ni)) Then
                ok = ok Or error_barrassueltas
                fmain.debuginfo((" barra suelta ->") & n.handle, True, False)
                fmain.debuginfo("->", False, False)
            End If

            If longitud(b) = 0 Then
                ok = ok Or error_barrassueltas
                fmain.debuginfo((" barra de largo 0 ->") & b.handle, True, False)
                fmain.debuginfo("->", False, False)
            End If

        Next
    End If
    fmain.debuginfo(" ")
    If (tipo And check_datos) = check_datos Then

        Select Case datos.tipo
            Case porticoplano, porticoespacial

                ' ACA SE VERIFICABA LO DE LAS ROTULAS, PERO LO MODIFIQUE PONIENDO UN 1 EN LA DIAGONAL PPAL
                ' For a = 1 To modEstru.nudo.max
                '     tabien = False
                '     For b = 1 To barra.Count
                '         If barra[b].ni = a Then ' la barra tiene el nudo considerado
                '             If (barra[b].restriccion And 1) = 0 Then tabien = True
                '         Else If barra[b].nF = a Then ' la barra tiene el nudo considerado
                '             If (barra[b].restriccion And 2) = 0 Then tabien = True
                '         End If
                '         If tabien Then Exit 'For
                '     Next
                '     If Not tabien Then
                '         ' verifico que no haya un apoyo empotrado en ese lugar
                '         For b = 1 To modEstru.apoyos.max
                '             If apoyos[b].nudo = a Then
                '                 If (apoyos[b].rmx Or apoyos[b].rmy Or apoyos[b].rmz) <> 0 Then tabien = True
                '             End If
                '             If tabien Then Exit 'For
                '         Next
                '
                '         If Not tabien Then ok = ok Or error_rotulas
                '         'GoTo salida:
                '
                '     End If
                ' Next

        End Select

        ' verifico que estén todos los datos de las barras
        If (datos.tipo = reticuladoplano) Or (datos.tipo = reticuladoespacial) Or (datos.tipo = porticoplano) Or (datos.tipo = porticoespacial) Then
            For a = 1 To barra.Count
                If (secciones[barra[a].seccion].area <= 0) Or (material[barra[a].material].e <= 0) Then
                    ok = ok Or error_barrassindatos
                    fmain.debuginfo((" barra sin datos ") & Format$(a, "0"), True, False)
                    fmain.debuginfo("->", False, False)
                End If
            Next
        End If
        If (datos.tipo = porticoplano) Or (datos.tipo = porticoespacial) Then
            For a = 1 To barra.Count
                If secciones[barra[a].seccion].iz <= 0 Then
                    ok = ok Or error_barrassindatos
                    fmain.debuginfo((" barra sin datos ") & Format$(a, "0"), True, False)
                    fmain.debuginfo("->", False, False)
                End If
            Next
        End If
        If (datos.tipo = porticoespacial) Then
            For a = 1 To barra.Count
                fmain.debuginfo(("Chequeando parametros: ") & Format$(a / barra.Count, "%00.00"), True)
                If (secciones[barra[a].seccion].Ip <= 0) Or (secciones[barra[a].seccion].iy <= 0) Or (secciones[barra[a].seccion].iz <= 0) Or (material[barra[a].material].g <= 0) Then
                    ok = ok Or error_barrassindatos
                    '
                    fmain.debuginfo((" barra sin datos ") & Format$(a, "0"), True, False)
                    fmain.debuginfo("->", False, False)
                End If

            Next

        End If

    End If
salida:
    'Stop
    fmain.debuginfo(("Chequeado en ") & Format$(Timer - t1, "0.00") & "--> " & Str$(ok), True)
    fmain.debuginfo(ErrorString(ok), True)
    fmain.cmbSectorModelo.clear
    fmain.cmbSectorModelo.Add("Todos pisos")
    For a = 1 To totalsectores
        fmain.cmbSectorModelo.Add(Format(a, "##0") & " Piso")

    Next

    Return ok

End Function

Public Function esapoyo(hnudo As Integer) As Integer

End Function

Public Function grabar(archivo As String) As Integer

    'Internacionalizacion: grabo y cargo en modo US

    ' Orden en que grabo
    '-------------------
    '   datos
    '   opcionales
    '   estados_nombre
    '   nudo
    '   barra
    '   auxiliar
    '   cargasnudo
    '   cargasbarra
    '   combinaciones
    '   informe
    '   seciones
    '   apoyos

    'obsoleto
    'If (UCase$(Right$(archivo$, 4)) <> ".CER") And (UCase$(Right$(archivo$, 4)) <> ".CE4") Then archivo$ = archivo$ + ".ce4"

    Dim t As Integer, sinerror As Integer, codigo As Integer, f As File
    Dim a As Integer, b As Integer
    Dim unNudo As ClsNudo, unaBarra As ClsBarra

    Dim cn As ClsCargaNudo, cb As ClsCargaBarra
    'Stop
    fmain.debuginfo(("Guardando el archivo ") & archivo)

    'On Error Goto quepaso
    'TODO implementar control de errores

    sinerror = True
    codigo = True   'supongo todo ok
    f = Open archivo For Write Create
    If sinerror Then
        ' paso al nuevo formato
        datos.magic = magic6

        Print #f, datos.magic
        Print #f, "Desc", datos.descripcion
        Print #f, "Nodes", nudo.Count
        Print #f, "Bars", barra.Count
        Print #f, "Slabs", losas.Count
        Print #f, "Walls", tabiques.Count
        Print #f, "Groups", datos.TotalGrupos
        Print #f, "Sectors", datos.totalsectores
        Print #f, "Shapes", secciones.count
        Print #f, "Restrs", modEstru.apoyos.Count
        Print #f, "nLoads", datos.totalcargasnudo
        Print #f, "bLoads", datos.totalcargasbarra
        Print #f, "pLoads", datos.totalcargasplacas
        Print #f, "tLoads", trenCargas.Count
        Print #f, "Beams", vigas.Count
        'Print #f, "Columns", columvigas.Count

        Print #f, "Type", datos.tipo

        Print #f, "lSlabs", "name", "numero", "piso", "Sector", "p1", "p2", "p3", "p4", " d", " material", "g", "p", "alivianado"
        For a = 0 To losas.Max
            Print #f, "Slab", losas[a].nombre, losas[a].numero, losas[a].piso, losas[a].sector, losas[a].Nudo1, losas[a].Nudo2, losas[a].Nudo3, losas[a].Nudo4, CStr(losas[a].d), losas[a].material, CStr(losas[a].g), CStr(losas[a].p), CStr(losas[a].alivianado), losas[a].dxgrid, losas[a].dzgrid, losas[a].nxgrid, losas[a].nzgrid
        Next

        Print #f, "lWalls", "name", "numero", "piso", "p1", "p2", "p3", "p4", " d", " material"
        For a = 0 To Tabiques.Max
            Print #f, "Wall", Tabiques[a].nombre, Tabiques[a].numero, tabiques[a].piso, Tabiques[a].sector, Tabiques[a].Nudo1, Tabiques[a].Nudo2, Tabiques[a].Nudo3, Tabiques[a].Nudo4, CStr(Tabiques[a].d), Tabiques[a].material, CStr(Tabiques[a].g), CStr(Tabiques[a].p)
        Next

        Print #f, "lBeams", "name", "p1", "p2", "p3", "p4"
        For a = 0 To vigas.Max
            Print #f, "Beam", vigas[a].nombre, vigas[a].numero, vigas[a].piso, vigas[a].sector, vigas[a].nudo1, vigas[a].nudo2, vigas[a].seccion, vigas[a].g
        Next

        With datos.unidades
            Print #f, "Units", .long_nombre, .peso_nombre, .ang_nombre
        End With
        For a = 1 To 10
            Print #f, "nState" & Format$(a, "00"), estados_nombre[a]
        Next
        ' combinaciones
        For a = 1 To 10
            Print #f, "mState" & Format$(a, "00"),

                For b = 1 To 9
                Print #f, CStr(combinacion[a, b]),
                    If Not sinerror Then Goto saliendo
            Next
            Print #f, CStr(combinacion[a, 10])
        Next

        Print #f, "lNodes", "X", "Y", "Z", "Group", "Sector"
        For Each unNudo In nudo

            Print #f, "Node", unNudo.handle, CStr(unNudo.x), CStr(unNudo.y), CStr(unNudo.z)

        Next
        Print #f, "lBars", "Ni", "Nf", "Mat", "Shape", "Restr", "Group", "Sector", "Tipo", "Inv", "Eje", "PosX", "PosY"
        For Each unaBarra In barra
            With unaBarra
                Print #f, "Bar", .handle, .ni, .nf, .material, .seccion, .restriccion, .grupo, .sector, .tipo, CInt(.Invertida), .Eje, .PosX, .posZ
            End With
            If Not sinerror Then Goto saliendo
        Next

        ' TODO aca iria la seccion de Placas
        ' TODO aca iria la seccion de Grupos
        ' TODO aca iria la seccion de Sectores
        Print #f, "lRestr", "Node", "rX", "rY", "rZ", "rmX", "rmY", "rmZ"
        For Each unNudo In nudo 'a = 0 To modEstru.apoyos.max
            If Not IsNull(unNudo.apoyo) Then
                With unNudo.apoyo
                    Print #f, "Restr", unNudo.handle, .rx, .ry, .rz, .rmx, .rmy, .rmz ', .mx, .My, .Mz, .cex, .cey, .cez, .cefix, .cefiy, .cefiz, .efix, .efiy, .efiz, .mfix, .mfiy, .mfiz
                End With
            End If

            If Not sinerror Then Goto saliendo
        Next

        Print #f, "lnLoads", "Node", "Fx", "Fy", "Fz", "Mx", "My", "Mz", "State"
        For Each unNudo In nudo ' a = 1 To datos.totalcargasnudo
            For Each cn In unNudo.cargas

                With cn
                    Print #f, "nLoad", unNudo.handle, CStr(.fx), CStr(.fy), CStr(.fz), CStr(.mx), CStr(.my), CStr(.mz), .Estado

                End With
            Next

        Next

        Print #f, "lbLoads", "Bar", "Type", "Px", "Py", "Pz", "a", "b", "c", "State"
        For Each unaBarra In barra ' a = 1 To datos.totalcargasbarra
            For Each cb In unaBarra.cargas
                With cb
                    ' no grabo las combinaciones porque se recalculan al cargar
                    If .e <= 10 Then Print #f, "bLoad", unaBarra.handle, .tipo, CStr(.px), CStr(.py), CStr(.pz), CStr(.a), CStr(.b), CStr(.c), .e 'estado

                End With
            Next
        Next

        Print #f, "tLoadRep", CStr(envolventes.repartida)  ' TODO ubicar esto en el lugar correspondiente
        Print #f, "tStep", envolventes.paso_puntuales
        Print #f, "tLoads", "tLoad", "tDistance"
        For a = 1 To trenCargas.Count

            Print #f, "tLoad", CStr(trenCargas[a - 1]), CStr(trenDistancia[a - 1])

        Next

        ' cargo el camino del tren
        Print #f, "tPathBars", "tBar"

        For a = 1 To Camino.Count

            Print #f, "tPathBar", CStr(camino[a - 1])

        Next

        Print #f, "lShapes", "Name", "Type", "Area", "Ipolar", "Iy", "Iz", "Wp", "Wy", "Wz", "a", "b", "c", "d", "e", "f"
        For a = 1 To secciones.count
            With secciones[a]
                Print #f, "Shape", .nombre, .tipo, CStr(.area), CStr(.Ip), CStr(.iy), CStr(.iz), CStr(.Wp), CStr(.wy), CStr(.wz), CStr(.a), CStr(.b), CStr(.c), CStr(.d), CStr(.e), CStr(.f)

            End With
        Next
        flags.cambios = False

    Else    'o sea que ni pudo abrir el archivo

        Goto saliendo

    End If
    Close f
    fmain.debuginfo(("Se guardo con exito"))

    Goto saliendo

quepaso:
    'esta es la rutina de errores
    ' debería seleccionar el tipo de error y avisar
    'pero no tengo ganas,asi que voy a devolver el error

    sinerror = False
    codigo = Error
    'Resume Next 'TODO implementar
saliendo:
    Return codigo

End Function

Public Function longitud(b As ClsBarra) As Float
    ' devuelve la longitud de la barra

    ' en caso de no existir alguno de los nudos, la siguiente instruccion dara error
    Try Return (((nudo[b.nF].x - nudo[b.ni].x) ^ 2 + (nudo[b.nF].y - nudo[b.ni].y) ^ 2 + (nudo[b.nF].z - nudo[b.ni].z) ^ 2)) ^ 0.5
    Return 0

End Function

Public Function lx(bar As ClsBarra) As Float

    Try Return nudo[bar.nF].x - nudo[bar.ni].x
    Return 0

End Function

Public Function ly(bar As ClsBarra) As Float

    Try Return nudo[bar.nF].y - nudo[bar.ni].y
    Return 0

End Function

Public Function lz(bar As ClsBarra) As Float

    Try Return nudo[bar.nF].z - nudo[bar.ni].z
    Return 0

End Function

Public Sub no_escribe_mas()

    escribiendo = False
    textgrid = ""
    egr = 0
    egc = 0

End Sub

Public Function nudos_dobles(Optional tol As Float = 10e-5) As Integer
    ' esta rutina corrige el problema de nudos en el mismo lugar físico

    Dim a As Integer, b As Integer, c As Integer, d As Integer, t As Integer

    a = 0
    For Each nudo1 As ClsNudo In nudo

        For Each nudo2 As ClsNudo In nudo
            If nudo1.handle = nudo2.handle Then Continue
            If Abs(nudo1.x - nudo2.x) < tol And Abs(nudo1.Y - nudo2.Y) < tol And Abs(nudo1.z - nudo2.z) < tol Then
                ' esta es la rutina que reemplaza los valores en el array barras
                ' 1-debo eliminar el nudo b de todas la barras y reemplazarlo por el a

                For Each bar As ClsBarra In barra
                    '1
                    If bar.ni = nudo1.handle Then bar.ni = nudo2.handle
                    If bar.nF = nudo1.handle Then bar.nF = nudo2.handle

                Next

                nudo.Remove(nudo1.handle)

            End If
        Next
    Next

    flags.cambios = True
    ' y tiene que recalcular
    flags.calculado = False

    fmain.SetStatus
    Return t

End Function

Public Sub dibujable()
    ' Verifica si la estructura se puede dibujar y llama a setstatus

    Dim a As Integer

    If graficos.cambios Then
        If chequeoestructura(check_barras Or check_nudos) = 0 Then
            flags.dibujable = True
            graficos.cambios = False
        Else
            ' si no la puedo dibujar, es que hay cambios
            flags.dibujable = False
            flags.dibujado = False
            graficos.cambios = True

        End If
    End If

End Sub

Public Sub escalar()

    Dim a As Integer, b As Integer, Dyz As Float
    Dim unaBarra As ClsBarra, unNudo As ClsNudo
    ' Calculo las escalas de los esfuerzos
    ' obtengo los máximos genereales

    '[pero primero pongo en cero]
    graficos.maxMz = 0
    graficos.maxMy = 0
    graficos.maxT = 0
    graficos.maxQy = 0
    graficos.maxN = 0
    graficos.maxQz = 0

    'Stop
    graficos.escala_esf = 0
    graficos.ESCmz = 1
    graficos.ESCmy = 1
    graficos.ESCt = 1
    graficos.ESCqy = 1
    graficos.ESCn = 1
    graficos.ESCqz = 1

    For Each unaBarra In barra ' a = 1 To barra.Count
        With unaBarra.EsfExtBar
            If Abs(.maxMz) > graficos.maxMz Then graficos.maxMz = Abs(.maxMz)
            If Abs(.maxMy) > graficos.maxMy Then graficos.maxMy = Abs(.maxMy)
            If Abs(.maxT) > graficos.maxT Then graficos.maxT = Abs(.maxT)
            If Abs(.maxQy) > graficos.maxQy Then graficos.maxQy = Abs(.maxQy)
            If Abs(.maxN) > graficos.maxN Then graficos.maxN = Abs(.maxN)
            If Abs(.maxQz) > graficos.maxQz Then graficos.maxQz = Abs(.maxQz)

            If Abs(.minMz) > graficos.maxMz Then graficos.maxMz = Abs(.minMz)
            If Abs(.minMy) > graficos.maxMy Then graficos.maxMy = Abs(.minMy)
            If Abs(.minT) > graficos.maxT Then graficos.maxT = Abs(.minT)
            If Abs(.minQy) > graficos.maxQy Then graficos.maxQy = Abs(.minQy)
            If Abs(.minN) > graficos.maxN Then graficos.maxN = Abs(.minN)
            If Abs(.minQz) > graficos.maxQz Then graficos.maxQz = Abs(.minQz)
        End With

    Next
    If graficos.escala_esf < graficos.maxMz Then graficos.escala_esf = graficos.maxMz
    If graficos.escala_esf < graficos.maxMy Then graficos.escala_esf = graficos.maxMy
    If graficos.escala_esf < graficos.maxT Then graficos.escala_esf = graficos.maxT
    If graficos.escala_esf < graficos.maxQy Then graficos.escala_esf = graficos.maxQy
    If graficos.escala_esf < graficos.maxN Then graficos.escala_esf = graficos.maxN
    If graficos.escala_esf < graficos.maxQz Then graficos.escala_esf = graficos.maxQz
    If graficos.escala_esf = 0 Then graficos.escala_esf = 1

    ' el maximo esf sera la mitad de la barra mas corta
    graficos.escala_esf = (graficos.barra_larga * 0.5 + graficos.barra_corta * 0.5 + graficos.largo_estructura * 0.25) / 3 / graficos.escala_esf

    ' ahora lo de la elastica
    graficos.FactorFlecha = 0
    For Each unNudo In nudo '  a = 1 To modEstru.nudo.max
        If graficos.FactorFlecha < Sqr(unNudo.dezplazamientos.dz ^ 2 + unNudo.dezplazamientos.dy ^ 2 + unNudo.dezplazamientos.dx ^ 2) Then graficos.FactorFlecha = Sqr(unNudo.dezplazamientos.dz ^ 2 + unNudo.dezplazamientos.dy ^ 2 + unNudo.dezplazamientos.dx ^ 2)
    Next

    ' que pasa si todos los nudos son apoyos?
    For Each unNudo In nudo '  a = 1 To modEstru.nudo.max
        If graficos.FactorFlecha < Sqr(unNudo.dezplazamientos.dfiy ^ 2 + unNudo.dezplazamientos.dfiz ^ 2) / 2 Then
            graficos.FactorFlecha = Sqr(unNudo.dezplazamientos.dfiz ^ 2 + unNudo.dezplazamientos.dfiy ^ 2) / 2

        End If
    Next

    'pero si son todos apoyos, y ademas son todos empotramientos
    If graficos.FactorFlecha = 0 Then
        For Each aBar As ClsBarra In barra
            modcalculus.generar_elastica(aBar)
            fmain.debugInfo(("Generando elastica ") & Format$(aBar.indice / barra.count, "0.00%"), True)
            dyz = Sqr(vectorE[modestru.setting.IntervaloElastica / 2].Y ^ 2 + vectorE[modestru.setting.IntervaloElastica / 2].z ^ 2)

            If graficos.FactorFlecha < dyz * longitud(aBar) / 2 Then
                graficos.FactorFlecha = dyz * longitud(aBar) / 2

            End If

        Next

    Endif

    If graficos.FactorFlecha < 1E-40 Then graficos.FactorFlecha = 1
    If graficos.FactorFlecha > 1E+40 Then graficos.FactorFlecha = 1

    ' ahora lo relaciono con la barra mas corta
    graficos.FactorFlecha = graficos.barra_larga * 0.05 / graficos.FactorFlecha

End Sub

Public Sub Check_consistencia()
    ' Esta rutina verifica las constantes en datos, opciones, dibujar, etc
    ' y reemplaza valores si es necesario.
    'DATOS

End Sub

Public Sub SetStatusHTM()
    ' ' para indicar el estado de la estructura
    '
    ' Dim a As Integer, ok As Integer, ok2 As Integer, nF As String, nfo As String, er As String
    ' Dim t As Long
    '
    ' nF = Application.Path &/ "/hlp" &/ flags.lenguaje &/ "status.mod"
    ' nFo = User.Home &/ ".estru3d/status.htm"
    '
    ' Try Kill nfo
    ' Copy nf To Nfo
    '
    ' If datos.proyecto <> "" Then
    '     ok2 = modUtils.file_replace(nfo, "__archivo", datos.proyecto)
    ' Else
    '     ok2 = modUtils.file_replace(nfo, "__archivo", "[no definido]")
    ' End If
    ' If Left$(datos.descripcion, 1) = Chr$(0) Then
    '     ok2 = modUtils.file_replace(nFo, "__descripcion", "[no definido]")
    ' Else
    '     ok2 = modUtils.file_replace(nFo, "__descripcion", datos.descripcion)
    ' End If
    ' ok2 = modUtils.file_replace(nFo, "__totalnudos", Str$(modEstru.nudo.max))
    ' ok2 = modUtils.file_replace(nFo, "__totalbarras", Str$(barra.Count))
    '
    ' ok2 = modUtils.file_replace(nFo, "__cargasbarra", Str$(datos.totalcargasbarra))
    ' ok2 = modUtils.file_replace(nFo, "__cargasnudo", Str$(datos.totalcargasnudo))
    ' ok2 = modUtils.file_replace(nFo, "__apoyos", Str$(modEstru.apoyos.count))
    ' ok2 = modUtils.file_replace(nFo, "__secciones", Str$(secciones.count))
    ' ok2 = modUtils.file_replace(nFo, "__materiales", Str$(material_count()))
    ' Select Case datos.tipo
    '     Case 1
    '         ok2 = modUtils.file_replace(nFo, "__tipo", ("Reticulado plano"))
    '     Case 3
    '         ok2 = modUtils.file_replace(nFo, "__tipo", ("Portico plano"))
    '     Case 2
    '         ok2 = modUtils.file_replace(nFo, "__tipo", ("Reticulado espacial"))
    '     Case 4
    '         ok2 = modUtils.file_replace(nFo, "__tipo", ("Portico espacial"))
    '     Case Else
    '         ok2 = modUtils.file_replace(nFo, "__tipo", ("[no definido]"))
    ' End Select
    '
    ' For a = 1 To 8
    '     t = t + cargasnudo_count(a)
    ' Next
    '
    ' ok2 = modUtils.file_replace(nFo, "__cargasnudo", Str$(t))
    '
    ' ok = chequeoestructura(check_nudos Or check_barras Or check_datos Or check_apoyos)
    ' ' error_nudossueltos = 1, error_nudosduplicados = 2, error_nudosinsuficientes = 4
    ' ' error_barrasinsuficientes = 8, error_barrassueltas = 16, error_barrassindatos = 32
    ' ' error_apoyosinsuficientes = 32, error_rotulas = 64 ', error_barrassindatos = 32
    ' t = 1 ' problemas
    ' If ok <> 0 Then
    '     If (ok And error_nudossueltos) = error_nudossueltos Then
    '         ok2 = modUtils.file_replace(nFo, "__problemas" & Format$(t, "0"), (" - Hay nudos a los que no llegan barras."))
    '         t = t + 1
    '     End If
    '     If (ok And error_nudosduplicados) = error_nudosduplicados Then
    '         er = ("- Hay nudos en la misma posición.")
    '         ok2 = modUtils.file_replace(nFo, "__problemas" & Format$(t, "0"), er)
    '         t = t + 1
    '     End If
    '     If (ok And error_nudosinsuficientes) = error_nudosinsuficientes Then
    '         er = ("- No hay nudos suficientes.")
    '         ok2 = modUtils.file_replace(nFo, "__problemas" & Format$(t, "0"), er)
    '         t = t + 1
    '     End If
    '     If (ok And error_barrasinsuficientes) = error_barrasinsuficientes Then
    '         er = ("- Barras insuficientes.")
    '         ok2 = modUtils.file_replace(nFo, "__problemas" & Format$(t, "0"), er)
    '         t = t + 1
    '     End If
    '     If (ok And error_nimayor) = error_nimayor Then
    '         er = ("- Hay barras con el nudo inicial mayor que el final.")
    '         ok2 = modUtils.file_replace(nFo, "__problemas" & Format$(t, "0"), er)
    '         t = t + 1
    '     End If
    '
    '     If (ok And error_barrassueltas) = error_barrassueltas Then
    '         er = ("- Barras no tienen los nudos definidos.")
    '         ok2 = modUtils.file_replace(nFo, "__problemas" & Format$(t, "0"), er)
    '         t = t + 1
    '     End If
    '     If (ok And error_barrassindatos) = error_barrassindatos Then
    '         er = ("- Barras no tienen los datos definidos.")
    '         ok2 = modUtils.file_replace(nFo, "__problemas" & Format$(t, "0"), er)
    '         t = t + 1
    '     End If
    '     If (ok And error_rotulas) = error_rotulas Then
    '         er = ("- Hay rótulas que generan un mecanismo.")
    '         ok2 = modUtils.file_replace(nFo, "__problemas" & Format$(t, "0"), er)
    '         t = t + 1
    '     End If
    ' Else
    '     ok2 = modUtils.file_replace(nFo, "__problemas1", ("No hay problemas que informar. Puede calcularse."))
    '     t = t + 1
    ' End If
    ' For a = t To 6
    '     ok2 = modUtils.file_replace(nFo, "__problemas" & Format$(a, "0"), " ")
    ' Next

End Sub

Public Function cargasnudo_count(e As Integer) As Long

    ' devuelve la cantidad de cargas en nudo para ese estado
    Dim a As Integer, b As Long
    Dim n As ClsNudo

    For Each n In nudo 'a = 0 To cargasnudo.Count - 1
        For a = 0 To n.cargas.Max
            If n.cargas[a].Estado = e Then
                If n.cargas[a].fx <> 0 Then b = b + 1
                If n.cargas[a].fy <> 0 Then b = b + 1
                If n.cargas[a].fz <> 0 Then b = b + 1
                If n.cargas[a].mx <> 0 Then b = b + 1
                If n.cargas[a].My <> 0 Then b = b + 1
                If n.cargas[a].Mz <> 0 Then b = b + 1
            End If
        Next
    Next
    Return b

End Function

Public Sub mats_save()
    ' guarda los materiales

    Dim f As File, paso As Integer, a As Integer
    'On Error GoTo nopude1:

    paso = 1
    fmain.debuginfo(("Guardando tabla de materiales"))

    'f = Open App.Path & "\\material.lib" For Write
    f = Open User.Home &/ ".estru3d" &/ "Librerias/material.lib" For Create
    For a = 1 To 20
        ' paso todo a mis unidades [ver mats_load]
        material[a].e = material[a].e / datos.unidades.factorEG
        material[a].g = material[a].g / datos.unidades.factorEG
        material[a].fluencia = material[a].fluencia / datos.unidades.factorEG
        material[a].densidad = material[a].densidad / datos.unidades.factorDEN
        Write #f, material[a] As MaterialSTRUCT
    Next
    Close f

    Return

nopude1:
    'MsgBox("No puede grabarse la libreria de materiales.")
    'TODO

    Return

End Sub

Public Sub mats_load()
    ' carga la tabla de materiales

    Dim f As File, paso As Integer, a As Integer, nnn As String
    'On Error Goto nopude1:
    Dim matU As New MaterialSTRUCT

    paso = 1
    material.clear

    ' cargo el material cero

    matu = Null
    matu = New MaterialSTRUCT
    matu.nombre = ("Unitario")
    matu.densidad = 1
    matu.e = 1
    matu.g = 1
    matu.fluencia = 1

    material.Add(matu)
    nnn = User.Home &/ ".estru3d/Librerias/material.estru3d-lib"
    fmain.debuginfo(("Cargando tabla de materiales") & nnn)
    f = Open nnn For Read

    For a = 1 To 20
        matu = Read #f As MaterialSTRUCT  ' what a sintax, Benoit!
        material.Add(matu)
        matu = Null
        matu = New MaterialSTRUCT

        ' E , G y Fluencia en ton/m2
        ' Densidad en ton/m3
        ' Los factores multiplican estas unidades para llevarlas a las
        ' del usuario
        material[a].e = material[a].e * datos.unidades.factorEG
        material[a].g = material[a].g * datos.unidades.factorEG
        material[a].fluencia = material[a].fluencia * datos.unidades.factorEG
        material[a].densidad = material[a].densidad * datos.unidades.factorDEN
    Next
    Close f

    Return

nopude1:
    'MsgBox "No puede abrirse la libreria de materiales."

End Sub

Public Sub mats_load2()
    ' using params component

    Dim paso As Integer, a As Integer, nnn As String
    Dim matU As New ClsMaterial

    paso = 1
    material.clear

    ' cargo el material cero

    matu = Null
    matu = New ClsMaterial
    matu.nombre = ("Unitario")
    matu.densidad = 1
    matu.e = 1
    matu.g = 1
    matu.fluencia = 1
    matu.handle = "0"

    material.Add(matu, matu.handle)

    fmain.debuginfo(("Cargando tabla de materiales") & nnn)

    For a = 1 To 20
        matu = Null
        matu = New ClsMaterial
        matu.handle = CStr(a)
        matu.nombre = Mats["Material" & Format$(a, "0") & "/Name", "<unnamed>"]
        matu.e = Mats["Material" & Format$(a, "0") & "/E", "1"]
        matu.g = Mats["Material" & Format$(a, "0") & "/G", "1"]
        matu.fluencia = Mats["Material" & Format$(a, "0") & "/F", "1"]
        matu.densidad = Mats["Material" & Format$(a, "0") & "/D", "1"]

        ' E , G y Fluencia en kilo/cm2
        ' Densidad en kilo/m3
        ' Los factores multiplican estas unidades para llevarlas a las
        ' del usuario
        matu.e *= datos.unidades.factorEG
        matu.g *= datos.unidades.factorEG
        matu.fluencia *= datos.unidades.factorEG
        matu.densidad *= datos.unidades.factorDEN
        material.Add(matu, matu.handle)

    Next

    Return

nopude1:
    'MsgBox "No puede abrirse la libreria de materiales."

End Sub

Public Sub calcular_factores()
    ' calcula los factores de las unidades
    ' Primero las pongo en uno

    datos.unidades.factorEG = 1
    datos.unidades.factorDEN = 1
    datos.unidades.factorSUP = 1
    datos.unidades.factorLONG = 1
    fmain.debuginfo(("Calculando los factores de las unidades"))

    'Stop
    Select Case LCase$(datos.unidades.peso_nombre)
        Case "tons"
            datos.unidades.factorEG = datos.unidades.factorEG / 1000
            datos.unidades.factorDEN = datos.unidades.factorDEN / 1000

        Case "kilo"
            ' nada!!! porque es default
        Case "pndf"
            datos.unidades.factorEG = datos.unidades.factorEG * 2.2046
            datos.unidades.factorDEN = datos.unidades.factorDEN * 2.2046
        Case "knwt"
            datos.unidades.factorEG = datos.unidades.factorEG * 0.00980665
            datos.unidades.factorDEN = datos.unidades.factorDEN * 0.00980665
        Case Else
            datos.unidades.peso_nombre = "kilo"
    End Select

    Select Case LCase$(datos.unidades.long_nombre)
        Case "metr"

            datos.unidades.factorLONG = datos.unidades.factorLONG
            datos.unidades.factorSUP = datos.unidades.factorSUP
            datos.unidades.factorEG = datos.unidades.factorEG * 100 ^ 2

        Case "cent"
            datos.unidades.factorLONG = datos.unidades.factorLONG * 100
            datos.unidades.factorSUP = datos.unidades.factorSUP * 100 ^ 2
            datos.unidades.factorEG = 1  'default
            datos.unidades.factorDEN = datos.unidades.factorDEN / 100 ^ 3
        Case "inch"
            datos.unidades.factorLONG = datos.unidades.factorLONG * 39.37007874015748
            datos.unidades.factorSUP = datos.unidades.factorSUP * 39.37007874015748 ^ 2
            datos.unidades.factorEG = datos.unidades.factorEG / 39.37007874015748 ^ 2
            datos.unidades.factorDEN = datos.unidades.factorDEN / 39.37007874015748 ^ 3
        Case "feet"
            datos.unidades.factorLONG = datos.unidades.factorLONG * 3.280839895013123
            datos.unidades.factorSUP = datos.unidades.factorSUP * 3.280839895013123 ^ 2
            datos.unidades.factorEG = datos.unidades.factorEG / 3.280839895013123 ^ 2
            datos.unidades.factorDEN = datos.unidades.factorDEN / 3.280839895013123 ^ 3
        Case Else
            datos.unidades.long_nombre = "metr"
    End Select

    Select Case LCase$(datos.unidades.ang_nombre)
        Case "rads"
            ' nada!!! porque es default
        Case "grad"
            datos.unidades.factorANG = datos.unidades.factorANG * 180 / 3.141567
        Case Else
            datos.unidades.ang_nombre = "rads"

    End Select

End Sub

' Public Sub logear(linea As String)
'
'     Try Print #flags.LogFile, Format$(Now, "hh:mm:ss") & "-" & linea
'     'fmain.pl.Text = fmain.pl.Text + linea + Chr$(13) + Chr$(10)
'
' End Sub

' Public Function openlog() As Boolean
'
'     Dim a As Integer
'
'     If flags.LogFileName = "" Then flags.LogFilename = "log.txt"
'     'On Error Goto err_log:
'     'If existe[flags.LogFile] Then Kill flags.LogFile
'
'     flags.LogFile = Open user.home &/  ".estru3d" &/ flags.LogFilename For Create
'
'     Return
'
' Catch
'     Message.Warning(("No puedo abrir el archivo log"))
'
'     Return False
'
' End Function

Public Sub closelog()

    Try Close #flags.LogFileNumber

End Sub

Public Sub DetectarMasas() 'As Integer

    Dim a As Integer, b As Integer, n As Integer

    b = 0
    For n = 1 To modEstru.nudo.max
        sisMasas[n] = 0

        For a = 1 To modEstru.barra.Count
            If (barra[a].ni = n) Or (barra[a].nf = n) Then
                sisMasas[n] += 0.5 * longitud(a) * material[barra[a].material].densidad * secciones[barra[a].seccion].area

            End If
        Next
    Next

End Sub

Public Sub BorrarEstado(e As Integer)
    ' borras todas las cargas de ese estado

    Dim a As Integer
    Dim bar As ClsBarra, nud As ClsNudo, p As Integer
    Dim carga As ClsCargaBarra

    For Each nud In nudo ' a = 1 To cargasnudo.max
        For a = nud.cargas.Max To 0 Step -1
            If nud.cargas[a].Estado = e Then nud.cargas.Remove(a) ' BorrarCargaNudo(a)
        Next

    Next

    'ListarCargasBarras(1)
    For Each bar In barra 'a = 1 To cargasbarra.max
        For a = bar.cargas.Max To 0 Step -1
            If bar.cargas[a].e = e Then bar.cargas.Remove(a) '           BorrarCargaBarra(a)
        Next
    Next

End Sub

Public Function get_material(cual As String) As Integer

    Dim a As Integer

    cual = LCase$(cual)
    For a = 1 To 20
        If InStr(LCase$(material[a].nombre), cual) > 0 Then
            Return a

        End If
    Next

End Function

Public Function AddNudo(x As Float, Y As Float, z As Float, Optional CheckExisting As Boolean, Optional Tolerance As Float = 1e-5) As String
    ' devuelve el numero de nudo o cero en caso de error

    'Tolerance: to surpass numerical tricks comparing coordinates,
    'ie: x = 12.50 tests True against x0 = 12.50001 if tolerance = 0.005
    'then no new node is created

    Dim a As Integer
    Dim n As ClsNudo
    ' primero chequeo que no exista
    If CheckExisting Then

        For Each n In nudo ' a = 01 To modEstru.nudo.max
            If (Abs(n.x - x) <= Tolerance) And (Abs(n.Y - Y) <= tolerance) And (Abs(n.z - z) <= Tolerance) Then

                ' encontre un nudo con las mismas coordenadas, devuelvo su posicion

                Return n.handle

            End If
        Next
    End If

    ' ahora veo si el array tiene elementos extra disponibles

    Dim nudou As New ClsNudo 'nudotype4
    Dim LastIndex As Integer
    Try LastIndex = nudo[nudo.Last].indice
    nudou.handle = GetNewHandle(nudo)
    nudoU.x = x
    nudoU.Y = Y
    nudoU.z = z
    nudou.Indice = LastIndex + 1

    nudo.Add(nudou)

    flags.cambios = True
    flags.calculado = False

    Return nudou.handle

End Function

'' Devuelve un handle disponible
Fast Public Function GetNewHandle(c As Collection) As String

    Dim i As Integer, s As String

    i = c.Count
    Try i = Val(c[c.Last].handle)
    Do
        Inc i
        s = CStr(i) ' esto podria ser Hex
        If Not c.Exist(s) Then
            Return s
        Endif

    Loop

End

Fast Public Function ReIndexNodes() As Boolean
    ' los indices de los nudos van de 1 a nNudos

    Dim i As Integer

    For Each n As ClsNudo In nudo
        Inc i
        n.indice = i

    Next
    i = 0
    For Each b As Clsbarra In barra
        Inc i
        b.indice = i

    Next

End

Public Function addLosa() As Integer

    Dim l1 As New ClsLosa

    losas.Add(l1)

    Return losas.Count

End

Public Function AddBarra(nudo_inicial As String, nudo_final As String, Optional hSeccion As String = "", hMaterial As String = "", rotulas As Integer = 0, CheckExisting As Boolean = False) As String
    ' devuelve el numero de barra o cero en caso de error
    ' rotulas:  0=sin rotulas, 1=rotula en nudo inicial, 2=en nudo final, 3=en ambos
    ' material y seccion: numero de orden o cero

    Dim d As Integer
    Dim b As ClsBarra
    ' primero chequeo que no exista
    If CheckExisting Then
        For Each b In barra 'd = 1 To barra.Count
            If (b.nF = nudo_final) And (b.ni = nudo_inicial) Then
                Return b.handle

            End If
        Next
    End If

    ' agrego una barra
    flags.cambios = True
    flags.calculado = False

    Dim barrau As New ClsBarra
    barra.Add(barrau)

    barrau.ni = nudo_inicial  '2020 what if node doesnt exist?
    barrau.nF = nudo_final
    barrau.handle = GetNewHandle(barra)

    If hmaterial = "" Then

        barrau.material = "unitario"
    Else

        barrau.material = hMaterial

    End If

    If hseccion = "" Then
        barrau.seccion = "unitario"
    Else
        barrau.seccion = hseccion

    End If

    barrau.grupo = 0
    barrau.restriccion = rotulas

    Return barrau.handle

End Function

Public Sub Decir(loque As String)
    'fmain.texto.Caption = loque
    'fmain.texto.Enabled = False

End Sub

Public Sub PurgarBarras()
    ' corrige barras con:
    ' ni>nf
    ' .seccion = nada
    ' .material = nada

    Dim a As Integer, b As Integer, t As Integer

    For a = 1 To barra.Count
        ' ni>nf
        If barra[a].ni > barra[a].nF Then
            b = barra[a].ni
            barra[a].ni = barra[a].nF
            barra[a].nF = b
            t += 1

        End If

    Next
    fmain.debugInfo(("Barras corregidas ") & Str$(t), False)

End Sub

'' Elimina todos los nudos que no esten agarrados de alguna barra
Public Function PurgarNudos() As Integer

    Dim a As Integer, e As Integer, tengo As Boolean
    Dim t As Integer
    Dim n As ClsNudo
    Dim b As ClsBarra

    For Each n In nudo 'e = 1 To modEstru.nud
        tengo = False
        For Each b In barra ' a = 1 To barra.Count
            '3
            If b.ni = n.handle Then tengo = True
            If b.nF = n.handle Then tengo = True
            If tengo Then Break
        Next
        If Not tengo Then
            Inc t

            nudo.Remove(n.handle)
            'reacomodo las barras
            ' 2020 obsooleto
            ' For a = 1 To barra.Count
            '     '3
            '     If barra[a].ni >= e Then barra[a].ni -= 1
            '     If barra[a].nF >= e Then barra[a].nF -= 1
            ' Next

        End If

    Next
    fmain.debugInfo(("Nudos sueltos purgados ") & Str$(t), False)

    Return t

End Function

Public Sub Asistir()
    ' aca vamops a sistir al user para q pueda disenie\
    ' para indicar el estado de la estructura
    ' TODO: hace una nueva version de esto estilo Console

    '
    '     Dim a As Integer, ok As Integer, ok2 As Integer, nF As String, nFo As String, er As String
    '     Dim ve As String, cmd As String, cmdl As String
    '     Dim t As Long
    ' paso1:
    '
    '     nF = Application.Path &/ "/hlp" &/ flags.lenguaje &/ "asis_1.htm"
    '
    '     nFo = User.Home &/ ".estru3d/asis_1.htm"
    '
    '     If Exist(nfo) Then
    '         Try Kill nfo
    '         If Error > 0 Then
    '             Message(("No puedo mostrar el asistente"))
    '             Return
    '         Endif
    '     Endif
    '     Copy nF To nFo
    '     'If datos.proyecto <> "" Then
    '     '    ok2 = modUtils.file_replace(nFo, "__archivo", datos.proyecto]
    '     'Else
    '     '    ok2 = modUtils.file_replace(nFo, "__archivo", "[no definido]"]
    '     'End If
    '     'If Left$[opcionales.descripcion, 1] = Chr$[0] Then
    '     '    ok2 = modUtils.file_replace(nFo, "__descripcion", "[no definido]"]
    '     'Else
    '     '    ok2 = modUtils.file_replace(nFo, "__descripcion", opcionales.descripcion]
    '     'End If
    '     ok2 = modUtils.file_replace(nFo, "__nudos", Str$(modEstru.nudo.max))
    '     ok2 = modUtils.file_replace(nFo, "__barras", Str$(barra.Count))
    '
    '     ok2 = modUtils.file_replace(nFo, "__carbar", Str$(datos.totalcargasbarra))
    '     ok2 = modUtils.file_replace(nFo, "__cargas", Str$(datos.totalcargasnudo))
    '     ok2 = modUtils.file_replace(nFo, "__apoyos", Str$(modestru.apoyos.count))
    '     ok2 = modUtils.file_replace(nFo, "__secciones", Str$(secciones.count))
    '     ok2 = modUtils.file_replace(nFo, "__materiales", Str$(material_count()))
    '
    '     ok2 = modUtils.file_replace(nFo, "__cargas", Str$(t))
    '     SetGL
    '     Select Case datos.tipo
    '         Case 1
    '             ok2 = modUtils.file_replace(nFo, "__tipo", ("Reticulado plano"))
    '
    '         Case 3
    '             ok2 = modUtils.file_replace(nFo, "__tipo", ("Portico plano"))
    '
    '         Case 2
    '             ok2 = modUtils.file_replace(nFo, "__tipo", ("Reticulado espacial"))
    '
    '         Case 4
    '             ok2 = modUtils.file_replace(nFo, "__tipo", ("Portico espacial"))
    '
    '         Case Else
    '             ok2 = modUtils.file_replace(nFo, "__tipo", ("[no definido]"))
    '             ve = ("No esta definido el tipo de estructura, este es el primer paso que debe hacerse para empezar el modelado")
    '             cmd = "info.cmd"
    '             cmdl = ("Definir el tipo de estructura")
    '             Goto salida
    '     End Select
    '
    '     ok = chequeoestructura(check_nudos Or check_barras Or check_datos Or check_apoyos)
    '
    '     ' error_nudossueltos = 1, error_nudosduplicados = 2, error_nudosinsuficientes = 4
    '     ' error_barrasinsuficientes = 8, error_barrassueltas = 16, error_barrassindatos = 32
    '     ' error_apoyosinsuficientes = 32, error_rotulas = 64 ', error_barrassindatos = 32
    '     t = 0 ' problemas
    '     'verifico el numero de nudos
    '     ok = chequeoestructura(check_nudos)
    '     If (ok And error_nudosinsuficientes) = error_nudosinsuficientes Then
    '         ve = ("No hay nudos suficientes debe haber como minimo 2 nudos y una barra.")
    '         cmd = "info.cmd"
    '         cmdl = ("Definir el numero de nudos")
    '         Goto salida
    '     End If
    '     'y el de barras
    '     ok = chequeoestructura(check_barras)
    '     'Stop
    '     If (ok And error_barrasinsuficientes) = error_barrasinsuficientes Then
    '         ve = ("No hay barras suficientes debe haber como minimo 2 nudos y una barra.")
    '         cmd = "info.cmd"
    '         cmdl = ("Definir el numero de barras")
    '         Goto salida
    '     End If
    '
    '     ' definio los nudos?
    '     For a = 1 To modEstru.nudo.max
    '         If (nudo[a].x = 0) And (nudo[a].Y = 0) And (nudo[a].z = 0) Then t = t + 1
    '     Next
    '     'Stop
    '
    '     If t > 1 Then
    '         ve = ("Hay nudos que no estan definidos todavia, en la tabla de nudos se indican las coordenadas x,y,z de cada nudo.")
    '         cmd = "nudos.cmd"
    '         cmdl = ("Definir las coordenadas de los nudos")
    '         Goto salida
    '
    '     End If
    '
    '     ok = chequeoestructura(check_barras)
    '     If (ok And error_nimayor) = error_nimayor Then
    '         ve = ("Hay barras con el nudo inicial mayor que el final. Este programa usa como condicion que al")
    '         ve = ve & (" una barra el nudo inicial tenga un numero menor que el final.")
    '         cmd = "purgarbarras.cmd"
    '         cmdl = ("Corregir la numeracion de barras")
    '         Goto salida
    '
    '     End If
    '
    '     If (ok And error_barrassueltas) = error_barrassueltas Then
    '         ve = ("Barras no tienen los nudos definidos. Todas las barras deben tener nudo inicial y final.")
    '         cmd = "barras.cmd"
    '         cmdl = ("r la Tabla de Barras para completar los valores de nudo inicial y final")
    '         Goto salida
    '
    '     End If
    '
    '     ok = chequeoestructura(check_nudos)
    '     If (ok And error_nudossueltos) = error_nudossueltos Then
    '         ve = ("Hay nudos a los que no llegan barras.")
    '         cmd = "purgarnudos.cmd"
    '         cmdl = ("Haga click aqui para eliminar los nudos que estan sueltos")
    '         Goto salida
    '     Else If (ok And error_nudosduplicados) = error_nudosduplicados Then
    '         ve = ("Hay nudos en la misma posición.")
    '         cmd = "purgarnudos.cmd"
    '         cmdl = ("Haga click aqui para eliminar los nudos que estan en la misma posicion")
    '         Goto salida
    '     End If
    '
    '     ok = chequeoestructura(check_datos)
    '     If (ok And error_barrassindatos) = error_barrassindatos Then
    '         ve = ("Barras no tienen los datos definidos. Debe definirse la seccion de la barra y el material.")
    '         cmd = "barras.cmd"
    '         cmdl = ("Corregir la seccion y/o material de las barras")
    '         Goto salida
    '
    '     End If
    '     If (ok And error_rotulas) = error_rotulas Then
    '         ve = ("Hay rótulas que generan un mecanismo. Esto significa que a todas las barras que llegan a un nudo se las definio como rotula en dicho extremo.")
    '         cmd = "extremos.cmd"
    '         cmdl = ("Corregir los extremos de las barras")
    '         Goto salida
    '
    '     End If
    '
    '     t = 0
    '
    '     ' ahora verifico apoyos, o eso intento
    '     For a = 1 To modestru.apoyos.max
    '         If (apoyos[a].nudo <> 0) Then t = t + 1
    '     Next
    '     'Stop
    '
    '     If t = 0 Then
    '         ve = ("No se han colocado apoyos.")
    '         cmd = "apoyos.cmd"
    '         cmdl = ("Colocar apoyos")
    '         Goto salida
    '
    '     End If
    '
    '     'cargas
    '     t = 0
    '     For a = 0 To cargasnudo.max
    '         If (cargasnudo[a].nudo <> 0) Then t = t + 1
    '     Next
    '     For a = 0 To cargasbarra.max
    '         If (cargasbarra[a].barra <> 0) Then t = t + 1
    '     Next
    '
    '     If t = 0 Then
    '         ve = ("No se han colocado cargas.")
    '         cmd = "cargas.cmd"
    '         cmdl = ("Colocar cargas")
    '         Goto salida
    '
    '     End If
    '
    '     If ok = 0 Then
    '         ve = ("No hay problemas que informar. Puede calcularse.")
    '         cmd = "calcular.cmd"
    '         cmdl = ("Cerrar el asistente y calcular")
    '         Goto salida
    '
    '     End If
    '
    ' salida:
    '
    '     'Stop
    '     ok2 = modUtils.file_replace(nFo, "__veredicto", ve)
    '     ok2 = modUtils.file_replace(nFo, "__paso", cmdl)
    '     ok2 = modUtils.file_replace(nFo, "__cmd", cmd)

End Sub

Public Sub WebAction(cmd As String)

    Dim a As Integer

    Select Case cmd
        Case "info"
            ' muestro la ventana info
            formInfo.Showmodal

            If flags.modo = 3 Then Asistir

        Case "purgarnudos"
            PurgarNudos
            If flags.modo = 3 Then Asistir

        Case "purgarbarras"
            PurgarBarras
            If flags.modo = 3 Then Asistir

        Case "nudos"
            FormNudos.Showmodal

            If flags.modo = 3 Then Asistir
        Case "barras"
            FormBarras.Showmodal
            If flags.modo = 3 Then Asistir
        Case "extremos"
            'extremos.Show 1

            If flags.modo = 3 Then Asistir

        Case "apoyos"
            formApoyos.ShowModal

            If flags.modo = 3 Then Asistir
        Case "cargas"
            formCargasNudos.ShowModal

            If flags.modo = 3 Then Asistir
        Case "calcular"
            '
            flags.modo = 1
            fmain.SetStatus
            '    Stop
            modCalculus.IniciarCalculos

    End Select

End Sub

Public Sub SetGL()

    Select Case datos.tipo
        Case 0, porticoplano
            modCalculus.gr = 3
            datos.tipo = porticoplano

        Case reticuladoplano
            modcalculus.gr = 2
        Case porticoplano, reticuladoespacial
            modcalculus.gr = 3
        Case porticoespacial
            modcalculus.gr = 6
    End Select

End Sub

Public Sub main()

    'tareas en caso de que sea la primera vez que se corra el programa, o su actualizacion

    Debug Application.Args[0]
    Debug Application.Args[1]
    Debug Application.Args[2]
    Debug Application.Args[3]

    FirstRun

    ' todo en orden

    Inicializar

    fmain.Show

End

Public Function EscribeUnidadesDeMedida() As String
    'tiene que ser un textlabel para que admita etiquetas html

    Dim texto As String

    Texto = "<center>" & "<i>" & ("Unidades de Medidas:") & " </i>" & "<br>" & " <b>" & ("Longitud:") & "</b> " & datos.unidades.long_nombre
    texto &= " <b>" & ("Peso:") & "</b> " & datos.unidades.peso_nombre
    texto &= " <b>" & ("Angulo:") & "</b> " & datos.unidades.ang_nombre
    texto &= "</center>"

    Return texto

End

Public Sub Inicializar()
    'variables

    Dim a As Integer, p1 As New Punto3d, p2 As New Punto3d, px As New Punto3d
    Dim LibPath As String, LibVersion As Float
    'forzamos a utilizar ingles, esto sirve para usuarios de otro idioma que no tienen spanish instalado
    If Application.Args[1] = "-en" Then System.Language = "en_US.UTF-8"

    Tutoriales = New Settings(Application.Path &/ "/hlp" &/ flags.lenguaje &/ "tutorial.estru3d-lib", "Tutoriales")

    'Debug Application.Dir

    'Debug Application.Name

    extremos[0] = "+---+"  'empotrada
    extremos[1] = "o---+"  'empotrada-rotula
    extremos[2] = "+---o"
    extremos[3] = "o---o"
    extremos[4] = "<--->"  'tensor

    PonerEnCero()

    graficos.colores.barras = 180
    graficos.colores.seleccion = 60

    flags.OcultarCargas = True
    flags.MostrarDespuesCalculo = 1 ' Mz
    'Cargo los settings

    setting.formato_datos = parametros["Options/DataFormat", "0.00"]
    setting.formato = parametros["Options/ResultsFormat", "0.00"]
    modestru.flags.ayuda = Application.Path &/ "/hlp" &/ flags.lenguaje &/ "bienv.htm"
    modestru.flags.ayuda = Application.Path &/ "/hlp" &/ modestru.flags.lenguaje &/ "index.htm"
    modestru.setting.IntervaloElastica = 20
    setting.solver = parametros["Options/Solver", "4"]

    Return

End

Public Sub NuevoProyecto()

    PonerEnCero

    fmain.SetStatus

End Sub

Public Sub aEsfSec(hbarra As Integer, secc As Integer, esfuerzo As Integer, valor As Float)

    ' coloca el valor en la seccion
    ' como todo es 1 to xxxx, resto 1 a todo
    Dim pos As Long
    ' esfsecarray.resize ( barras * setting.pasoc * 6)
    ' 10 barras, 20 secciones + 1 , 6 espacial -> 10 * 21 * 6 = 1260 elementos
    '
    pos = (esfuerzo - 1) + secc * 6 + (hbarra - 1) * (setting.PasoCalcularEsfuerzos + 1) * 6

    EsfSecArray[pos] = valor

End

Public Function EsfSec(hbarra As Integer, secc As Integer, esfuerzo As Integer) As Float

    ' devuelve el valor en la seccion
    ' como todo es 1 to xxxx, resto 1 a todo
    Dim pos As Long

    pos = (esfuerzo - 1) + secc * 6 + (hbarra - 1) * (setting.PasoCalcularEsfuerzos + 1) * 6

    Return EsfSecArray[pos]

End

Public Function EsfSecNeg(hbarra As Integer, secc As Integer, esfuerzo As Integer) As Float

    ' devuelve el valor en la seccion
    ' como todo es 1 to xxxx, resto 1 a todo
    Dim pos As Long

    pos = (esfuerzo - 1) + secc * 6 + (hbarra - 1) * (setting.PasoCalcularEsfuerzos + 1) * 6

    Return EsfSecArrayNeg[pos]

End

Public Function EsfSecPos(hbarra As Integer, secc As Integer, esfuerzo As Integer) As Float

    ' devuelve el valor en la seccion
    ' como todo es 1 to xxxx, resto 1 a todo
    Dim pos As Long

    pos = (esfuerzo - 1) + secc * 6 + (hbarra - 1) * (setting.PasoCalcularEsfuerzos + 1) * 6

    Return EsfSecArrayPos[pos]

End

' idem losas
Public Sub aEsfSecLosas(hLosa As Integer, x As Integer, Z As Integer, direccion As Integer, esfuerzo As Integer, valor As Float)

    ' coloca el valor en la cuadricula de las losas
    ' las losas son de nX x nY cuadrados
    ' por lo tanto el array sera de: A = 6 esfuerzos x (nX + 1) x (nY + 1)
    ' cuando creo el array acumulador, sera de la sumatoria de A(l)
    '
    Dim pos As Long
    ' El indice en el array acumulador se obtiene por
    pos = EsfSecArrayLosasIndex[hLosa]

    ' y la posicion adecuada, considereando que acumulamos por filas X
    pos += (direccion - 1) + (esfuerzo - 1) * 2 + Z * (losas[hLosa].nxGrid + 1) * 6 * 2 + X * 6 * 2

    EsfSecArrayLosas[pos] = valor

End

Public Function EsfSecLosas(hLosa As Integer, x As Integer, Z As Integer, direccion As Integer, esfuerzo As Integer) As Float

    ' devuelve el valor en la cuadricula
    Dim pos As Long
    ' El indice en el array acumulador se obtiene por
    pos = EsfSecArrayLosasIndex[hLosa]

    ' y la posicion adecuada, considereando que acumulamos por filas X
    pos += (direccion - 1) + (esfuerzo - 1) * 2 + Z * (losas[hLosa].nxGrid + 1) * 6 * 2 + X * 6 * 2

    Return EsfSecArrayLosas[pos]

End

Public Sub LlenarGridLosas()

    ' llena el array de esfuerzos en las losas
    Dim l As Integer ' losa
    Dim pX As Integer ' posicion X
    Dim pZ As Integer ' posicion Z
    Dim d As Integer ' la direccion del esfuerzo a considerar
    Dim b As Integer ' barras
    Dim E As Float ' el esfuerzo
    Dim E2 As Float
    Dim esfuerzo As Integer
    Dim NudoI As Integer, nudoF As Integer

    Dim s As String

    GridLosasIndex.Resize(losas.Count)
    For l = 1 To losas.Max
        GridLosasIndex[l] = GridLosasIndex[l - 1] + 3 * (losas[l - 1].nxGrid + 1) * (losas[l - 1].nzGrid + 1)
    Next

    l = losas.Max
    arrGridLosas.Resize(GridLosasIndex[l] + 3 * (losas[l].nxGrid + 1) * (losas[l].nzGrid + 1))

    ' ahora empiezo a acumular
    For Each bar As ClsBarra In barra
        If bar.tipo = tipo_losa Then ' es parte de una losa?
            l = bar.grupo - 1 ' numero de losa
            pX = bar.PosX  ' en general las posiciones 0 y ultimas quedan reemplaadas por vigas
            pZ = bar.PosZ
            d = bar.Eje '1=X 2=Z
            NudoI = bar.ni
            NudoF = bar.Nf

            If bar.Invertida Then Swap NudoI, NudoF

            'veo que pasa con la posicion
            If (d = 1) And (pX = 1) Then
                '  ademas cargo el punto
                aGridLosas(l, 0, pZ, nudo[NudoI].x, nudo[Nudoi].y, nudo[Nudoi].z)
            Else If (d = 2) And (pZ = 1) Then ' tomo el esfuerzo en el inicio

                '  ademas cargo el punto
                aGridLosas(l, pX, 0, nudo[NudoI].x, nudo[NudoI].y, nudo[NudoI].z)
            End If

            aGridLosas(l, pX, pz, nudo[NudoF].x, nudo[NudoF].y, nudo[NudoF].z)

        End If
    Next

    For l = 0 To losas.Max
        ' acumulo los limites de las losas
        aGridLosas(l, 0, 0, nudo[losas[l].Nudo1].x, nudo[losas[l].Nudo1].y, nudo[losas[l].Nudo1].z)
        aGridLosas(l, 0, losas[l].nzgrid, nudo[losas[l].Nudo3].x, nudo[losas[l].Nudo3].y, nudo[losas[l].Nudo3].z)
        aGridLosas(l, losas[l].nxgrid, 0, nudo[losas[l].Nudo2].x, nudo[losas[l].Nudo2].y, nudo[losas[l].Nudo2].z)
        aGridLosas(l, losas[l].nxGrid, losas[l].nzgrid, nudo[losas[l].Nudo4].x, nudo[losas[l].Nudo4].y, nudo[losas[l].Nudo4].z)

    Next

    ' solo para Debug
    ' For l = 0 To losas.Max
    '     ' acumulo los limites de las losas
    '     For pz = 0 To losas[l].nzGrid
    '         For px = 0 To losas[l].nxGrid
    '                 s = s & Str$(px) & ";" & Str$(pz) & " " & Format(EsfSecLosas(l, px, pz, 1, 6), "0") & " | "
    '         Next
    '         Debug s
    '         s = ""
    '     Next
    '
    ' Next

End

' idem losas
Public Sub aGridLosas(hLosa As Integer, X As Integer, Z As Integer, x0 As Float, y0 As Float, z0 As Float)

    ' coloca el valor en la cuadricula de las losas
    ' las losas son de nX x nY cuadrados
    ' por lo tanto el array sera de: A = 6 esfuerzos x (nX + 1) x (nY + 1)
    ' cuando creo el array acumulador, sera de la sumatoria de A(l)
    '
    Dim pos As Long
    ' El indice en el array acumulador se obtiene por
    pos = GridLosasIndex[hLosa]

    ' y la posicion adecuada, considereando que acumulamos por filas X
    pos += Z * (losas[hLosa].nxGrid + 1) * 3 + X * 3

    arrGridLosas[pos] = x0
    arrGridLosas[pos + 1] = y0
    arrGridLosas[pos + 2] = z0

End

Public Sub GridLosas(hLosa As Integer, x As Integer, Z As Integer, ByRef X0 As Float, ByRef y0 As Float, ByRef z0 As Float)

    ' devuelve el valor en la cuadricula
    Dim pos As Long

    pos = GridLosasIndex[hLosa]

    ' y la posicion adecuada, considereando que acumulamos por filas X
    pos += Z * (losas[hLosa].nxGrid + 1) * 3 + X * 3

    x0 = arrGridLosas[pos]
    y0 = arrGridLosas[pos + 1]
    z0 = arrGridLosas[pos + 2]

End

Public Sub GridLosas3D(hLosa As Integer, x As Integer, Z As Integer, P3d As Punto3d)
    ' 2020
    ' TODO chequear qe P3D se pase ByRef
    ' devuelve el valor en la cuadricula

    Dim pos As Long

    pos = GridLosasIndex[hLosa]

    ' y la posicion adecuada, considereando que acumulamos por filas X
    pos += Z * (losas[hLosa].nxGrid + 1) * 3 + X * 3

    p3d.x = arrGridLosas[pos]
    p3d.y = arrGridLosas[pos + 1]
    p3d.z = arrGridLosas[pos + 2]

End

Public Function FirstRun()

    Dim archivo As String
    '
    ' copio la libreria C para poder usarla
    modestru.flags.lenguaje = Left$(System.Language, 2)  ' con esto accedo al folder correcto de la ayuda

    '2020
    'en alggunos ambientes como WLS esto puede dar un valor erroneo

    If InStr("en es ", modestru.flags.lenguaje) = 0 Then modestru.flags.lenguaje = "es"

    ' es la primera vez que corro el programa?
    If parametros["User/LocalVersion", ""] <> Application.Version Then ' a new version is beign installed

        ' user debe aceptar los terminos
        'If parametros["User/Agreed", "False"] <> "True" Then
        FormAgreement.ShowModal
        If parametros["User/Agreed", "False"] <> "True" Then Quit
        'End If
        parametros["User/LocalVersion"] = Application.Version
        If Not Exist(User.home &/ ".estru3d/") Then Mkdir User.home &/ ".estru3d"
        If Not Exist(User.home &/ ".estru3d/Librerias/") Then Mkdir User.home &/ ".estru3d/Librerias"

        If parametros["User/FirstRun", "True"] = "True" Then

            For Each archivo In RDir(Application.Path &/ "Librerias/")
                Try Kill User.home &/ ".estru3d/Librerias/" &/ archivo
                Copy Application.Path &/ "Librerias/" &/ archivo To User.home &/ ".estru3d/Librerias/" &/ archivo
            Next
            parametros["User/FirstRun"] = "False"
        Else If Message(("Reemplazamos las tablas de materiales?")) Then

            For Each archivo In RDir(Application.Path &/ "Librerias/")
                Try Kill User.home &/ ".estru3d/Librerias/" &/ archivo
                Copy Application.Path &/ "Librerias/" &/ archivo To User.home &/ ".estru3d/Librerias/" &/ archivo
            Next

        Else

            ' se mantienen las tablas

        End If

    Endif

End

Public Sub JoinBars(bar As Integer)
    ' esta rutina busca barras colineales con la barra bar y las no

End

Public Sub GenerarSobrecargas(estado As Integer)
    ' genera cargas gravitatorias basandose en el material y la seccion, y las coloca en el estado indicado

    Dim b As ClsBarra 'Integer ' la barra a cargar
    Dim p As Float 'el peso por ml
    Dim c As ClsCargaBarra ' Integer ' carga
    Dim l As Integer ' losas

    BorrarEstado(flags.estadoAccidental)
    BorrarEstado(flags.estadoPermanente)

    For l = 0 To losas.Max
        fmain.debugInfo(("Generando sobrecargas ") & Format$(l / losas.Max, "0.00%"), True)

        For Each b In barra ' = 1 To barra.Count

            If b.tipo = tipo_losa And b.grupo = l + 1 Then ' estoy en la losa adecuada

                ' la superficie de influencia es Lbarra * 0.5, porque la cuadricula es cuadrada
                ' permanente
                p = losas[l].g * longitud(b) * 0.5

                c = New ClsCargaBarra ' GetFreeCarga(flags.estadoPermanente)

                If IsNull(c) Then

                    fmain.debugInfo("No hay mas lugar para cargas.")
                    Return

                Endif

                b.cargas.Add(c)
                ' la linea siguiente es obsoleta
                ' cargasbarra[c].barra = b
                c.e = flags.estadoPermanente
                c.tipo = 22
                c.py = -p

                ' aaccidental
                p = losas[l].p * longitud(b) * 0.5

                c = New ClsCargaBarra ' GetFreeCarga(flags.estadoAccidental)

                If IsNull(c) Then

                    fmain.debugInfo("No hay mas lugar para cargas.")
                    Return

                Endif
                b.cargas.Add(c)
                'cargasbarra[c].barra = b
                c.e = flags.estadoAccidental
                c.tipo = 22
                c.py = -p
            End If
        Next 'barras
    Next ' losas

End

Public Sub GenerarPesoPropio(estado As Integer)
    ' genera cargas gravitatorias basandose en el material y la seccion, y las coloca en el estado indicado

    Dim p As Float 'el peso por ml
    Dim b As ClsBarra 'Integer ' la barra a cargar

    Dim c As ClsCargaBarra ' Integer ' carga
    Dim l As Integer ' losas

    ' fmain.debugInfo("Borre el estado?",, True)
    '
    ' modEstru.ListarCargasBarras(, 1138)

    BorrarEstado(estado)

    ' fmain.debugInfo("Borre el estado?",, True)
    '
    ' modEstru.ListarCargasBarras(, 1138)
    For Each b In barra ' = 1 To barra.Count

        p = secciones[b.seccion].area * material[b.material].densidad

        If (b.tipo = tipo_losa) Then
            l = barra[b].grupo - 1
            p *= losas[l].alivianado

        End If

        c = New ClsCargaBarra ' GetFreeCarga(estado)

        If IsNull(c) Then

            fmain.debugInfo("No hay mas lugar para cargas.")
            Return

        Endif
        b.cargas.Add(c)
        ' cargasbarra[c].barra = b
        c.e = estado
        c.tipo = 22
        c.py = -p

    Next

End

Public Function addViga(ni As Integer, nf As Integer, seccion As Integer, Optional material As Integer = 0, Optional b As Integer = 0, Optional d As Integer = 0) As Integer

    Dim viga1 As New ClsViga
    Dim bar1 As Integer

    viga1.nudo1 = ni
    viga1.nudo2 = nf
    viga1.seccion = seccion
    viga1.b = b
    viga1.d = d
    viga1.material = material

    vigas.Add(viga1)

    ' bar1 = AddBarra(ni, nf, seccion, material, 0, False)
    ' barra[bar1].grupo = vigas.Max
    ' barra[bar1].tipo = modEstru.tipo_viga
    ' barra[bar1].sector = piso ' primer planta tipo

    Return vigas.Max

End

Public Sub ToDo()
    ' Solo un contenedor de las cosas que quiero implementar

    ' Preview: podria aprovechar la ultima vez que el user haga un zoom extents, o cuando cierra o guarda el proyecto
    '           para generar una imagen .png o .jpg que pueda utilizar luego a modo de preview

    'Envolventes: limpiar arrays cuando hubo modificaciones y haya que recalcular

End

Public Function ProcesarComando(cmd As String) As String
    ' supongo un comando estilo:
    ' filter piso1
    ' select beam from piso1

    ' en todo caso el comando empieza por una palabra
    Dim cmdl As String, a As Integer, b As Integer, params As String[], contador As Integer

    cmdl = LCase$(cmd)
    params = Split(cmdl, " ")
    If params.Count = 0 Then Return
    contador = 0
    Select Case Trim$(params[0])
        Case "select", "sel"
            ' se van a visualizar solo los elementos que cumplan el criterio
            Select Case Trim$(params[1])
                Case "all"
                    For a = 1 To barra.Max
                        barra[a].seleccionado = True
                        contador += 1
                    Next
                Case "beams"
                    For a = 1 To barra.Max
                        If barra[a].tipo = tipo_viga Then
                            barra[a].seleccionado = True
                            contador += 1
                        End If
                    Next
                Case "nothing"
                    For a = 1 To barra.Max
                        barra[a].seleccionado = False
                    Next

            End Select

            modGraphics.valoresdelgrafico3D  'para que recalcule las escalas
            modGraphics.dibujar_estructura3D 'ahora dibujamos
            Return ("Seleccionadas: ") & Str$(contador) & (" barras.")

        Case Else
            Return ("Error: Comando desconocido.")
    End Select

End

Public Function ErrorString(codigo As Integer) As String

    Dim er As String

    If (codigo And error_nudossueltos) = error_nudossueltos Then er = er & ("- Nudos a los que no llegan barras.") & Chr$(13) & Chr$(10)
    If (codigo And error_nudosduplicados) = error_nudosduplicados Then er = er & ("- Hay nudos en la misma posición.") & Chr$(13) & Chr$(10)
    If (codigo And error_nudosinsuficientes) = error_nudosinsuficientes Then er = er & ("- No hay nudos suficientes.") & Chr$(13) & Chr$(10)
    If (codigo And error_barrasinsuficientes) = error_barrasinsuficientes Then er = er & ("- Barras insuficientes.") & Chr$(13) & Chr$(10)
    If (codigo And error_barrassueltas) = error_barrassueltas Then er = er & ("- Barras no tienen los nudos definidos.") & Chr$(13) & Chr$(10)
    If (codigo And error_barrassindatos) = error_barrassindatos Then er = er & ("- Barras no tienen los datos definidos.") & Chr$(13) & Chr$(10)
    If (codigo And error_nimayor) = error_nimayor Then er = er & ("- Barras con nudo inicial mayor que el final.") & Chr$(13) & Chr$(10)
    If (codigo And error_rotulas) = error_rotulas Then er = er & ("- Hay rótulas que generan un mecanismo.") & Chr$(13) & Chr$(10)

    If codigo = 0 Then er = ("Sin errores")

    Return er

End

Public Function GetElementTotalLength(element As Integer, type As Integer) As Float

    Dim b As Integer
    Dim l As Float

    For b = 1 To barra.Max
        If (barra[b].tipo = type) And (barra[b].grupo = element) Then
            l += longitud(b)

        Endif
    Next
    Return l

End

Public Sub ReLoadElement(element As Integer, type As Integer, carga As Float, state As Integer)

    ' busca las barras que componen el elemento y elimina las cargas que tenga para el estado en cuestion

    ' recarga los elementos con la carga especificada
    ' carga = kg/m2 o sea que tengo que distribuirlos en las barras
    ' En caso de losas la carga a aplicar en las barras seria repartida
    ' q = carga x sup / lTotal  , donde lTotal es la sumatoria de longitud de todas las barras que representan la losa

    Dim b As ClsBarra, ElSector As Integer
    Dim l As Float, lTotal As Float, fCarga As Float
    Dim c As ClsCargaBarra, grupo As Integer, i, index As Integer

    If type = tipo_losa Then
        index = element '  indexLosa(element)
        ElSector = losas[index].sector

        lTotal = GetElementTotalLength(element + 1, type) ' Warning: las barras [].grupo = index de losas/vigas + 1

        If lTotal = 0 Then
            fmain.debugInfo(("Elemento de largo 0"))
            Return
        Endif

        fCarga = carga * losas[index].area / lTotal

        fmain.debugInfo(("Recargando losa ") & Str$(losas[index].numero) & "-" & Str$(losas[index].sector) & ":")
        fmain.debugInfo(("  Area ") & Format$(losas[index].area, "0.00"),, True)
        fmain.debugInfo(("  Largo barras ") & Format$(lTotal, "0.00"),, True)
        fmain.debugInfo(("  Carga ") & Format$(fCarga, "0.00"),, True)

        ' primero elimino todas las cargas repartidas de esa losa del tipo gravitatorias
        For Each b In barra
            For i = 0 To b.cargas.Max  ' voy a borrar todas las cargas de esa barra para ese estado

                If (b.grupo = element + 1) And (b.tipo = type) And (b.sector = ElSector) And (b.cargas[i].tipo = 22) And (b.cargas[i].e = state) Then b.cargas.Remove(i)
            Next
        Next

        For Each b In barra
            If (b.grupo = element + 1) And (b.tipo = type) And (b.sector = ElSector) Then
                c = New ClsCargaBarra
                'c = GetFreeCarga(state)
                b.cargas.Add(c)
                c.py = -fCarga
                c.tipo = 22
                c.e = state

            Endif
        Next

    Else If type = tipo_viga Then

        index = vigas[element].numero ' vigas[element].numero '  indexLosa(element)
        ElSector = vigas[element].sector

        ' If (index = 1) And (ElSector = 2) Then Stop

        ' primero elimino todas las cargas repartidas de esa losa del tipo gravitatorias
        For Each b In barra
            For i = 0 To b.cargas.Max  ' voy a borrar todas las cargas de esa barra para ese estado

                If (b.grupo = index) And (b.tipo = type) And (b.sector = ElSector) And (b.cargas[i].tipo = 22) And (b.cargas[i].e = state) Then
                    ' If (index = 1) And (ElSector = 2) Then Stop

                    b.cargas.Remove(i) ' BorrarCargaBarra(c)
                End If
            Next

        Next

        For Each b In barra '= 1 To barra.Max
            If (b.grupo = index) And (b.tipo = type) And (b.sector = ElSector) And (Carga <> 0) Then
                ' If index = 1 And ElSector = 2 Then Stop

                c = New ClsCargaBarra ' GetFreeCarga(state)
                b.cargas.Add(c) 'cargasbarra[c].barra = b
                c.py = -Carga
                c.tipo = 22
                c.e = state

            Endif
        Next
    End If

End

Public Sub RecalcularAreaLosas()

    Dim a As Integer

    fmain.debugInfo(("Recalculando area de losas"))

    ' TODO sirve para algo esto?? tal vez no

    For a = 0 To losas.Max
        losas[a].area = modAlgebra.AreaRomboide3D(nudo[losas[a].Nudo1], nudo[losas[a].Nudo2], nudo[losas[a].Nudo4], nudo[losas[a].Nudo3])
        fmain.debugInfo(("Losa") & Str$(losas[a].piso) & "-" & Str$(losas[a].numero) & " " & Format$(losas[a].area, "0.00"))

    Next

End

Public Function indexLosa(numero As Integer) As Integer

    Dim a As Integer

    For a = 0 To losas.Max
        If losas[a].numero = numero Then Return a
    Next
    Return -1

End

Public Function GetMaxGrid() As Integer

    Dim a As Integer, c As Integer

    For a = 0 To losas.Max
        If losas[a].nxGrid > c Then c = losas[a].nxGrid
        If losas[a].nzGrid > c Then c = losas[a].nzGrid
    Next

    setting.PasoGrid = c
    setting.PuntosInterpolados = 2

    Return c

End

Public Sub ListarCargasBarras(Optional iEstado As Integer = -1, iBarra As String = "")

    Dim a As Integer
    Dim b As ClsBarra, c As ClsCargaBarra
    ' lista las cargas para ese estado por consola
    For Each b In barra 'a = 0 To cargasbarra.Max
        For Each c In b.cargas
            ' filtro
            If (c.e = iestado) Or (iEstado < 0) Then
                If (ibarra = "") Or (ibarra = b.handle) Then
                    fmain.debugInfo(" Carga en barra: " & Str(b.handle) & " Estado: " & Str(c.e) & " Tipo: " & Str(c.tipo) &
                        " P: " & Format$(c.px, "0.00") & Format$(c.py, "0.00") & Format$(c.pz, "0.00"))
                Endif
            End If
        Next
    Next

End

Public Sub ListarCargasNudos(estado As Integer)

    Dim a As Integer
    Dim n As ClsNudo
    Dim c As ClsCargaNudo
    ' lista las cargas para ese estado por consola
    For Each n In nudo 'a = 0 To cargasnudo.Max
        For Each c In n.cargas
            If c.Estado = estado Then
                fmain.debugInfo(" Carga en nudos " & Str(n.handle) & " P: " &
                    Format$(c.px, "0.00") & Format$(c.py, "0.00") & Format$(c.pz, "0.00") &
                    " M: " & Format$(c.mx, "0.00") & Format$(c.my, "0.00") & Format$(c.mz, "0.00"))
            Endif
        Next
    Next

End

Public Function FiltroBarra(iBarra As ClsBarra, Optional iSector As Integer = -1, Optional iGrupo As Integer = -1, Optional iTipo As Integer = -1) As Boolean

    If (ibarra.sector <> iSector) And (iSector >= 0) Then Return False
    If (ibarra.grupo <> iGrupo) And (iGrupo >= 0) Then Return False
    If (ibarra.tipo <> iTipo) And (iTipo >= 0) Then Return False

    Return True

End

Public Function GetSeccion(a As Float, b As Float) As Integer
    ' busca si tengo una seccion rectangular de esas caracteristicas, sino la crea y devuelve el indice

    Dim m As Integer

    For m = 1 To secciones.count

        If (secciones[m].a = a) And (secciones[m].b = b) And (secciones[m].tipo = "G-Rectangular") Then
            'tengo una seccion
            Return m

        End If
    Next

    Dim seccu As New ClsSeccion

    seccU.a = a
    seccU.b = b
    seccU.tipo = "G-Rectangular"
    seccU.area = a * b
    seccU.iz = a * b ^ 3 / 12
    seccU.iy = a ^ 3 * b / 12
    seccU.ip = a ^ 3 * b / 12 + a * b ^ 3 / 12
    seccU.wy = a ^ 2 * b / 8
    seccU.wz = a * b ^ 2 / 8
    seccU.nombre = "R" & Format$(a, "0.00") & "x" & Format$(b, "0.00")
    secciones.Add(seccU)

    secciones.count += 1
    Return secciones.Max

End

Public Function FiltrarBarras(YaSelecionada As Boolean, Optional tipo As Integer = -1, Optional grupo As Integer = -1, Optional sector As Integer = -1, Optional material As Integer = -1, Optional seccion As Integer = -1) As Integer
    ' pone .seleccionado = True en todas las barras que cumplas las condiciones de los parametros
    '
    'Devuelve el total de barras seleccionadas

    Dim a As Integer, n As Integer

    For a = 1 To barra.Max
        If barra[a].seleccionado Or Not YaSelecionada Then
            barra[a].seleccionado = True
            If tipo >= 0 And (barra[a].tipo <> tipo) Then barra[a].seleccionado = False ' no cumple
            If grupo >= 0 And (barra[a].grupo <> grupo) Then barra[a].seleccionado = False ' no cumple
            If material >= 0 And (barra[a].material <> material) Then barra[a].seleccionado = False ' no cumple
            If seccion >= 0 And (barra[a].seccion <> seccion) Then barra[a].seleccionado = False ' no cumple
            If sector >= 0 And (barra[a].sector <> sector) Then barra[a].seleccionado = False ' no cumple

            ' si sigue seleccionada, sumo

            If barra[a].seleccionado Then n += 1

        Endif
    Next
    Return n

End

Public Sub Esfuerzos_de_Barras_a_Vigas(Modo As Integer)

    'coloco en Vigas[] los esfuerzos del ultimo calculo, segun Modo
    'Modo=0 -> reemplazo los valores
    'Modo=1 -> comparo y reemplazo la peor condicion
    'Modo=2 -> Sumo los valores
    'Modo=4 -> Sumo solo si empeora la condicion

    Dim b As Clsbarra
    Dim v As Short
    Dim p As Integer
    Dim Inve As Float

    If Not flags.calculado Then
        fmain.debugInfo("No se ha calculado el proyecto aun")
        Return
    Endif

    For Each b In barra ' = 1 To barra.Max
        ' busco determino si pertenece a alguna viga
        If b.tipo = tipo_viga Then
            v = GetPosViga(b.grupo, b.sector)
            inve = 1 'IIf(barra[v].Invertida, -1, 1)
            ' comienzo a cargar los esfuerzos
            If modo = 0 Then
                If vigas[v].maxN < b.EsfExtBar.maxN * inve Then vigas[v].maxN = b.EsfExtBar.maxN * inve
                If vigas[v].maxQy < b.EsfExtBar.maxQy * inve Then vigas[v].maxQy = b.EsfExtBar.maxQy * inve
                If vigas[v].maxQz < b.EsfExtBar.maxQz * inve Then vigas[v].maxQz = b.EsfExtBar.maxQz * inve
                If vigas[v].maxT < b.EsfExtBar.maxT * inve Then vigas[v].maxT = b.EsfExtBar.maxT * inve
                If vigas[v].maxMy < b.EsfExtBar.maxMy Then vigas[v].maxMy = b.EsfExtBar.maxMy
                If vigas[v].maxMz < b.EsfExtBar.maxMz Then vigas[v].maxMz = b.EsfExtBar.maxMz

                If vigas[v].minN > b.EsfExtBar.minN * inve Then vigas[v].minN = b.EsfExtBar.minN * inve
                If vigas[v].minQy > b.EsfExtBar.minQy * inve Then vigas[v].minQy = b.EsfExtBar.minQy * inve
                If vigas[v].minQz > b.EsfExtBar.minQz * inve Then vigas[v].minQz = b.EsfExtBar.minQz * inve
                If vigas[v].minT > b.EsfExtBar.minT * inve Then vigas[v].minT = b.EsfExtBar.minT * inve
                If vigas[v].minMy > b.EsfExtBar.minMy Then vigas[v].minMy = b.EsfExtBar.minMy
                If vigas[v].minMz > b.EsfExtBar.minMz Then vigas[v].minMz = b.EsfExtBar.minMz

                ' tengo que ver si la barra es un extremo de la viga

                If b.ni = vigas[v].nudo1 Then
                    vigas[v].niN = b.EsfExtBar.nin * inve
                    vigas[v].niQy = b.EsfExtBar.niqy * inve
                    vigas[v].niQz = b.EsfExtBar.niqz * inve
                    vigas[v].niT = b.EsfExtBar.nit * inve
                    vigas[v].niMy = b.EsfExtBar.nimy
                    vigas[v].niMz = b.EsfExtBar.nimz
                Else If b.ni = vigas[v].nudo2 Then
                    vigas[v].nfN = b.EsfExtBar.nin * inve
                    vigas[v].nfQy = b.EsfExtBar.niqy * inve
                    vigas[v].nfQz = b.EsfExtBar.niqz * inve
                    vigas[v].nfT = b.EsfExtBar.nit * inve
                    vigas[v].nfMy = b.EsfExtBar.nimy
                    vigas[v].nfMz = b.EsfExtBar.nimz
                End If

                If b.nf = vigas[v].nudo1 Then
                    vigas[v].niN = b.EsfExtBar.nfn * inve
                    vigas[v].niQy = b.EsfExtBar.nfqy * inve
                    vigas[v].niQz = b.EsfExtBar.nfqz * inve
                    vigas[v].niT = b.EsfExtBar.nft * inve
                    vigas[v].niMy = b.EsfExtBar.nfmy
                    vigas[v].niMz = b.EsfExtBar.nfmz
                Else If b.nf = vigas[v].nudo2 Then
                    vigas[v].nfN = b.EsfExtBar.nfn * inve
                    vigas[v].nfQy = b.EsfExtBar.nfqy * inve
                    vigas[v].nfQz = b.EsfExtBar.nfqz * inve
                    vigas[v].nfT = b.EsfExtBar.nft * inve
                    vigas[v].nfMy = b.EsfExtBar.nfmy
                    vigas[v].nfMz = b.EsfExtBar.nfmz
                End If

            End If
        Endif

    Next

End

Public Function GetPosBar(LaViga As Integer, Xv As Float, ByRef LaBarra As Integer, ByRef Xb As Float) As Boolean

    '1 - - - - - - - - - - - - - - - - - - Xv - - - - - - - - - - - - - - - - - - - - - - - -2
    '                                         LaViga

    'i--------1------fi-----2-----fi--------Xb---3----------------fi-------------4--------------f
    '                          barras que forman la viga

    ' en este caso deberia devolver la barra=3 y Xb

    Dim Vbarras As New Integer[]
    Dim Blargos As New Float[]
    Dim Vnudos As New Integer[]

    Dim BarrasOrdenadas As New Integer[]
    Dim LargosOrdenados As New Float[]
    Dim NudoSiguiente As Integer

    Dim b As Integer, LTotal As Float
    Dim a As Integer, v As Integer

    If Xv < 0 Then Return False
    If vigas[LaViga].l <= 0 Then Return False

    ' primero buscamos las barras que forman la viga

    For b = 1 To barra.Count
        If barra[b].grupo = vigas[LaViga].grupo Then Vbarras.Add(b)

    Next

    If Vbarras.Count = 0 Then Return False  'no encontre barras que formen la viga

    ' calculo el largo
    For b = 0 To Vbarras.Max
        Blargos.Add(longitud(Vbarras[b]))
        LTotal += Blargos(b)
    Next

    If lTotal <> modAlgebra.Distancia(nudo[vigas[v].nudo1], nudo[vigas[v].nudo2]) Then
        ' no coinciden, o hay barras superpuestas
        Stop

    Endif

    ' ordeno las barras, de nudo 1 en adelante

    NudoSiguiente = vigas[LaViga].nudo1
    For a = 0 To Vbarras.Max
        For b = 0 To Vbarras.Max
            If barra[Vbarras[b]].ni = NudoSiguiente Then
                BarrasOrdenadas.Add(Vbarras[b])
                NudoSiguiente = barra[Vbarras[b]].nf
                Vbarras.Remove(b) ' para no repetir
                Break
            Else If barra[Vbarras[b]].nf = NudoSiguiente Then
                BarrasOrdenadas.Add(Vbarras[b])
                NudoSiguiente = barra[Vbarras[b]].ni
                Vbarras.Remove(b) ' para no repetir
                Break
            Endif
        Next
    Next

    ' aca ya estan ordenadas, entonces busco la seccion

    For a = 0 To BarrasOrdenadas.Max
        If Xv > longitud(BarrasOrdenadas[a]) Then
            Xv -= longitud(BarrasOrdenadas[a])
        Else 'encontre la seccion
            LaBarra = BarrasOrdenadas[a]
            Xb = Xv
            Return True
        Endif
    Next

End

Public Sub Esfuerzos_de_Barras_a_Losas(Modo As Integer)

    'coloco en Vigas[] los esfuerzos del ultimo calculo, segun Modo
    'Modo=0 -> reemplazo los valores
    'Modo=1 -> comparo y reemplazo la peor condicion
    'Modo=2 -> Sumo los valores
    'Modo=4 -> Sumo solo si empeora la condicion

    Dim b As ClsBarra
    Dim v As Short
    Dim w As Float

    Dim frase As String

    If Not flags.calculado Then
        fmain.debugInfo("No se ha calculado el proyecto aun")
        Return
    Endif

    For Each b In barra ' = 1 To barra.Max
        ' busco determino si pertenece a alguna viga
        If b.tipo = tipo_losa Then
            v = b.grupo - 1
            If b.Eje = 1 Then w = losas[v].dzGrid  'se divide por el otro sentido que es lo que representa la barra
            If b.Eje = 2 Then w = losas[v].dxGrid
            If w = 0 Then w = longitud(b) ' es una aproximacion

            ' comienzo a cargar los esfuerzos
            If modo = 0 Then
                If b.Eje = 1 Then ' la barra corresponde a la direccion local X en la losa
                    If losas[v].maxQx < (b.EsfExtBar.maxQy / w) Then losas[v].maxQx = b.EsfExtBar.maxQy / w
                    If losas[v].maxMx < (b.EsfExtBar.maxMz / w) Then
                        losas[v].maxMx = b.EsfExtBar.maxMz / w
                        'losas[v].barra_MXmax = b  ' TODO: esto no se para q lo puse
                    End If

                    If losas[v].minQx > (b.EsfExtBar.minQy / w) Then losas[v].minQx = b.EsfExtBar.minQy / w
                    If losas[v].minMx > (b.EsfExtBar.minMz / w) Then
                        losas[v].minMx = b.EsfExtBar.minMz / w
                        'losas[v].barra_MXmin = b
                    End If
                End If

                If losas[v].maxT < b.EsfExtBar.maxT Then losas[v].maxT = b.EsfExtBar.maxT
                If losas[v].minT > b.EsfExtBar.minT Then losas[v].minT = b.EsfExtBar.minT

                If b.eje = 2 Then ' la barra corresponde a la direccion local Z en la losa
                    If losas[v].maxQz < (b.EsfExtBar.maxQy / w) Then losas[v].maxQz = b.EsfExtBar.maxQy / w
                    If losas[v].maxMz < (b.EsfExtBar.maxMz / w) Then
                        losas[v].maxMz = b.EsfExtBar.maxMz / w
                        'losas[v].barra_MZmax = b
                    End If
                    If losas[v].minQz > (b.EsfExtBar.minQy / w) Then losas[v].minQz = b.EsfExtBar.minQy / w
                    If losas[v].minMz > (b.EsfExtBar.minMz / w) Then
                        losas[v].minMz = b.EsfExtBar.minMz / w
                        'losas[v].barra_MZmin = b
                    End If
                End If
            Endif

        Endif

    Next

    For v = 0 To losas.Max
        frase = frase & "Losa " & Str(losas[v].numero) & "-" & Str(losas[v].sector) & ":" & gb.Cr
        frase = frase & gb.Tab & "Lx" & Str(losas[v].dxGrid) & gb.Cr
        frase = frase & gb.Tab & "Lz" & Str(losas[v].dzGrid) & gb.Cr

        frase = frase & gb.Tab & "Mz min: " & Format(losas[v].minMz, setting.formato) & " en barra " & Str(losas[v].barra_MZmin) & gb.Cr

        fmain.debugInfo(frase)
        frase = ""

    Next

End

Public Sub Esfuerzos_de_Barras_a_Losas_en_Extremos(Modo As Integer)

    ' la diferencia conrespecto a la version 1 es que utilizo la posicion de la barra para ver en que parte estoy de la losa

    'coloco en Vigas[] los esfuerzos del ultimo calculo, segun Modo
    'Modo=0 -> reemplazo los valores
    'Modo=1 -> comparo y reemplazo la peor condicion
    'Modo=2 -> Sumo los valores
    'Modo=4 -> Sumo solo si empeora la condicion

    Dim b As ClsBarra
    Dim v As Short
    Dim w As Float

    'variables de maximos
    Dim barra_MXmax As Integer
    Dim barra_MZmax As Integer
    Dim barra_MXmin As Integer
    Dim barra_MZmin As Integer

    Dim frase As String

    If Not flags.calculado Then
        fmain.debugInfo("No se ha calculado el proyecto aun")
        Return
    Endif

    For Each b In barra ' = 1 To barra.Max
        ' busco determino si pertenece a alguna viga
        If b.tipo = tipo_losa Then
            v = b.grupo - 1
            If b.Eje = 1 Then w = losas[v].dzGrid
            If b.Eje = 2 Then w = losas[v].dxGrid

            If w = 0 Then w = longitud(b) ' es una aproximacion

            ' comienzo a cargar los esfuerzos
            If modo = 0 Then

                If b.Eje = 1 Then ' la barra corresponde a la direccion local X en la losa
                    If losas[v].maxQx < (b.EsfExtBar.maxQy / w) Then losas[v].maxQx = b.EsfExtBar.maxQy / w
                    If losas[v].maxMx < (b.EsfExtBar.maxMz / w) Then
                        losas[v].maxMx = b.EsfExtBar.maxMz / w
                        losas[v].barra_MXmax = b
                    End If

                    If losas[v].minQx > (b.EsfExtBar.minQy / w) Then losas[v].minQx = b.EsfExtBar.minQy / w
                    If losas[v].minMx > (b.EsfExtBar.minMz / w) Then
                        losas[v].minMx = b.EsfExtBar.minMz / w
                        losas[v].barra_MXmin = b
                    End If
                End If

                If losas[v].maxT < b.EsfExtBar.maxT Then losas[v].maxT = b.EsfExtBar.maxT
                If losas[v].minT > b.EsfExtBar.minT Then losas[v].minT = b.EsfExtBar.minT

                If barra[b].eje = 2 Then ' la barra corresponde a la direccion local Z en la losa
                    If losas[v].maxQz < (b.EsfExtBar.maxQy / w) Then losas[v].maxQz = b.EsfExtBar.maxQy / w
                    If losas[v].maxMz < (b.EsfExtBar.maxMz / w) Then
                        losas[v].maxMz = b.EsfExtBar.maxMz / w
                        losas[v].barra_MZmax = b
                    End If
                    If losas[v].minQz > (b.EsfExtBar.minQy / w) Then losas[v].minQz = b.EsfExtBar.minQy / w
                    If losas[v].minMz > (b.EsfExtBar.minMz / w) Then
                        losas[v].minMz = b.EsfExtBar.minMz / w
                        losas[v].barra_MZmin = b
                    End If
                End If

            End If
        Endif

    Next

End

Public Function GetPosViga(grupo As Integer, sector As Integer) As Integer

    Dim aa As Integer

    For aa = 0 To vigas.Max
        If (vigas[aa].numero = grupo) And (vigas[aa].sector = sector) Then Return aa
    Next
    Return -1

End

Public Function GetNodeHandle(iIndex As Integer) As String

    For Each n As ClsNudo In nudo
        If n.indice = iIndex Then Return n.handle
    Next

End
